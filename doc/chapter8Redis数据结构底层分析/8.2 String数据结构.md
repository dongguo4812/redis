# String数据结构的物理编码方式

String数据结构的物理编码方式：embstr、row、int

```shell
127.0.0.1:6379> set hello world
OK
127.0.0.1:6379> type hello
string
127.0.0.1:6379> OBJECT ENCODING hello
"embstr"
```



`embstr` 是 Redis 字符串对象的一种编码方式，它是 "embedded string" 的缩写。当字符串对象保存的是短字符串（小于44字节），并且这个字符串对象同时满足只被引用一次的条件时，Redis 会使用 `embstr` 编码来存储这个字符串对象。`embstr` 编码的字符串对象将实际字符串值和 RedisObject 结构连续存储在一起，这种紧凑的存储方式可以减少内存碎片，并可能提高某些操作的性能。

```shell
127.0.0.1:6379> set k1 v11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
OK
127.0.0.1:6379> OBJECT ENCODING k1
"raw"
```

与 `embstr` 编码相对的是 `raw` 编码，当字符串对象保存的是长字符串（大于44字节，存储上限为512mb），或者字符串对象被多次引用时，Redis 会使用 `raw` 编码。在 `raw` 编码中，字符串值和 RedisObject 结构是分开的，字符串值保存在堆上的另一块内存中。

```shell
127.0.0.1:6379> set age 18
OK
127.0.0.1:6379> type age
string
127.0.0.1:6379> OBJECT ENCODING age
"int"
```

从 Redis 6.0 开始，引入了一种新的字符串编码方式，称为 int 编码。这种编码方式用于存储整数值的字符串（最多20位），当字符串只包含数字且可以被解释为整数时，Redis 会使用 int 编码而不是 raw 或 embstr。int 编码的字符串对象直接将整数值存储在对象的结构体中，就像 embstr 一样，但它们占用的空间更小，并且可以表示的范围更大。

如果是浮点数值的字符串，会将浮点数转化为字符串值

```shell
127.0.0.1:6379> set score 80.6
OK
127.0.0.1:6379> OBJECT ENCODING score
"embstr"
```

## 底层实现方式

![image-20240318150242820](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403181825697.png)

前两种编码使⽤的是sds来存储，最后⼀种OBJ_ENCODING_INT编码直接把string存成了long型。在对string进行incr, decr等操作的时候，如果它内部是OBJ_ENCODING_INT编码，那么可以直接行加减操作；如果它内部是OBJ_ENCODING_RAW或OBJ_ENCODING_EMBSTR编码，那么Redis会先试图把sds存储的字符串转成long型，如果能转成功，再进行加减操作。对⼀个内部表示成long型的string执行append, setbit, getrange这些命令，针对的仍然是string的值（即⼗进制表示的字符串），而不是针对内部表⽰的long型进⾏操作。

比如字符串”32”，如果按照字符数组来解释，它包含两个字符，它们的ASCII码分别是0x33和0x32。当我们执行命令setbit key 7 0的时候，相当于把字符0x33变成了0x32，这样字符串的值就变成了”22”。⽽如果将字符串”32”按照内部的64位long型来解释，那么它是0x0000000000000020，在这个基础上执⾏setbit位操作，结果就完全不对了。因此，在这些命令的实现中，会把long型先转成字符串再进行相应的操作。

# SDS简单动态字符串

Redis没有直接使用C语言中的字符串，

C语言字符串存在很多问题：

获取字符串长度的需要从头开始遍历，直到遇到'\0'，时间复杂度O(n)

非二进制安全，如果字符数组中存在'\0'，那么读取到'\0'就结束了，只读了一部分内容。

不可修改，常量

![image-20240318151718826](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403181825910.png)

Redis构建了一种新的字符串结构（以空字符'\0'结尾的字符数组），称为简单动态字符串（Simple Dynamic String），简称SDS。

key、value都对应一个SDS。

例如：set name redis，redis会创建两个SDS，其中一个是包含'name'的SDS，另一个是包含'redis'的SDS.

![image-20240318151423802](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403181825797.png)



![image-20240318153317563](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403181825437.png)

## sds.h源码

![image-20240318151501199](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403181825262.png)

Redis中字符串的实现，SDS有多种结构（sds.h)：

sdshdr5  (2^5=32byte)  不会被使用 sdshdr5 is never used。

sdshdr8 (2^8=256byte)

sdshdr16 (2^16=65536byte=64KB)

sdshdr32 (2^32byte=4GB)

sdshdr64		2^64byte=17179869184G       用于存储不同的长度的字符串。

len表示SDS的长度,使我们在获取字符串长度的时候可以在O(1)情况下拿到,而不是像C那样需要遍历一遍字符串.

alloc可以用来计算字符串已经分配的未使用的空间，有了这个值就可以引入预分配空间的算法了，而不用去考虑内存分配的问题。

flags 用来表示SDS的类型是sdshdr8还是sdshdr16等等

![image-20240327100810800](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403271008524.png)

buf 表示字符串数组，真存数据的，由SDS管理。

### 动态扩容

SDS之所以叫做动态字符串，是因为它具备动态扩容的能力，例如一个内容为“hi”的SDS

![image-20240318154628648](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403181825478.png)

假如我们要给SDS追加一段字符串“,Amy”，这里首先会申请新内存空间 ,扩展后字符串6个字节，新空间则需要多申请6个字节，一共13个字节（6+2n+1）：

如果新字符串小于1M，则新空间为扩展后字符串长度的两倍+1；

如果新字符串大于1M，则新空间为扩展后字符串长度+1M+1。称为内存预分配。

注这里的+1是末尾的空字符'\0'

![image-20240318154649932](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403181825051.png)

## int编码格式源码

Redis 启动时会预先建立 10000 个分别存储 0~9999 的 redisObject 变量作为共享对象，这就意味着如果 set字符串的键值在 0~10000 之间的话，则可以 直接指向共享对象 而不需要再建立新对象，此时键值不占空间！

![image-20240318161046699](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403181825995.png)

底层调用的是setCommand

![image-20240318155256072](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403181825892.png)

tryObjectEncoding()根据传参进行编码类型转换  

![image-20240318160644938](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403181825158.png)



## embstr编码格式源码

![image-20240318161429112](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403181825083.png)

tryObjectEncoding()

![image-20240318161304518](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403181825852.png)

对于长度小于 44的字符串，Redis 对键值采用OBJ_ENCODING_EMBSTR 方式，EMBSTR 顾名思义即：embedded string，表示嵌入式的String。从内存结构上来讲 即字符串 

sds结构体与其对应的 redisObject 对象分配在同一块连续的内存空间，字符串sds嵌入在redisObject对象之中一样。

createEmbeddedStringObject()

![image-20240318161405867](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403181825804.png)

## raw编码格式源码

![image-20240318161503219](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403181825981.png)

![image-20240318162406948](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403181825195.png)

当字符串的键值为长度大于44的超长字符串时，Redis 则会将键值的内部编码方式改为OBJ_ENCODING_RAW格式，这与OBJ_ENCODING_EMBSTR编码方式的不同之处在于，此时动态字符串sds的内存与其依赖的redisObject的内存不再连续了 

## value没有超过阈值，为什么变成raw？

```shell
127.0.0.1:6379> set k3 a
OK
127.0.0.1:6379> OBJECT ENCODING k3
"embstr"
127.0.0.1:6379> append k3 b
(integer) 2
127.0.0.1:6379> get k3
"ab"
127.0.0.1:6379> OBJECT ENCODING k3
"raw"
```



对于 embstr，由于其实现是只读的，因此在对 embstr 对象进行修改时，都会先转化为raw再进行修改。因此,只要是修改embstr对象,修改后的对象一定是 raw的,无论是否达到了44个字节



## SDS编码格式流程



![image-20240318162909230](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403181825879.png)

只有整数才会使用 int，如果是浮点数， Redis 内部其实先将浮点数转化为字符串值，然后再保存。

embstr 与 raw 类型底层的数据结构其实都是 SDS (简单动态字符串，Redis 内部定义 sdshdr 一种结构)。

| int    | Long类型整数时，RedisObject中的ptr指针直接赋值为整数数据，不再额外的指针再指向整数了，节省了指针的空间开销。 |
| ------ | ------------------------------------------------------------ |
| embstr | 当保存的是字符串数据且字符串小于等于44字节时，embstr类型将会调用内存分配函数，只分配一块连续的内存空间，空间中依次包含 redisObject 与 sdshdr 两个数据结构，让元数据、指针和SDS是一块连续的内存区域，这样就可以避免内存碎片 |
| raw    | 当字符串大于44字节时，SDS的数据量变多变大了，SDS和RedisObject布局分家各自过，会给SDS分配多的空间并用指针指向SDS结构，raw 类型将会调用两次内存分配函数，分配两块内存空间，一块用于包含 redisObject结构，而另一块用于包含 sdshdr 结构 |



![image-20240318163047593](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403181826544.png)