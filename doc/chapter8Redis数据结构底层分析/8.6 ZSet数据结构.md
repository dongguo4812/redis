redis6使用ziplist和skiplist

redis7使用listpack和skiplist

# redis6

当有序集合中包含的元素数量超过服务器属性 server.zset_max_ziplist_entries 的值（默认值为 128 ），

或者有序集合中新添加元素的 member 的长度大于服务器属性 server.zset_max_ziplist_value 的值（默认值为 64 ）时，

redis会使用跳跃表作为有序集合的底层实现。

否则会使用ziplist作为有序集合的底层实现

![image-20240318205412852](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403182111388.png)

![image-20240318205423156](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403182111509.png)

![image-20240318205437879](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403182111628.png)

## 源码

t_zset.c

![image-20240318205611451](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403182111764.png)

![image-20240318205616123](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403182111134.png)

![image-20240318205623856](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403182111360.png)

# redis7

![image-20240318205638380](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403182111275.png)

![image-20240318205641985](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403182111974.png)

## 源码

![image-20240318205651928](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403182111069.png)

# SkipList

对于一个单链表来讲，即便链表中存储的数据是有序的，如果我们要想在其中查找某个数据，也只能从头到尾遍历链表。

这样查找效率就会很低，时间复杂度会很高O(N)

![image-20240318210002515](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403182111942.png)

![image-20240318210006501](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403182111351.png)

解决方法：升维，也叫空间换时间。

![image-20240318210022581](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403182111818.png)

从这个例子里，我们看出，加来一层索引之后，查找一个结点需要遍历的结点个数减少了，也就是说查找效率提高了。





画了一个包含64个结点的链表，按照前面讲的这种思路，建立了五级索引

![image-20240318210447343](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403182110813.png)

skiplist是一种以空间换取时间的结构。 

由于链表，无法进行二分查找，因此借鉴数据库索引的思想，提取出链表中关键节点（索引），先在关键节点上查找，再进入下层链表查找，提取多层关键节点，就形成了跳跃表



但是由于索引也要占据一定空间的，所以，索引添加的越多，空间占用的越多





## 跳表查询的时间复杂度分析

如果链表里有N个结点，会有多少级索引呢？

按照我们前面讲的，两两取首。每两个结点会抽出一个结点作为上一级索引的结点，以此估算：

第一级索引的结点个数大约就是n/2，

第二级索引的结点个数大约就是n/4，

第三级索引的结点个数大约就是n/8，依次类推......

也就是说，第k级索引的结点个数是第k-1级索引的结点个数的1/2，那第k级索引结点的个数就是n/(2^k)

![image-20240318210746853](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403182110349.png)

## 跳表查询的空间复杂度分析

比起单纯的单链表，跳表需要存储多级索引，肯定要消耗更多的存储空间。那到底需要消耗多少额外的存储空间呢？

 

我们来分析一下跳表的空间复杂度。

第一步：首先原始链表长度为n，

 

第二步：两两取首，每层索引的结点数：n/2, n/4, n/8 ... , 8, 4, 2 每上升一级就减少一半，直到剩下2个结点,以此类推；如果我们把每层索引的结点数写出来，就是一个等比数列。

![image-20240318210821005](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403182110842.png)

这几级索引的结点总和就是n/2+n/4+n/8…+8+4+2=n-2。所以，跳表的空间复杂度是O(n) 。也就是说，如果将包含n个结点的单链表构造成跳表，我们需要额外再用接近n个结点的存储空间。

 

第三步：思考三三取首，每层索引的结点数：n/3, n/9, n/27 ... , 9, 3, 1 以此类推；

第一级索引需要大约n/3个结点，第二级索引需要大约n/9个结点。每往上一级，索引结点个数都除以3。为了方便计算，我们假设最高一级的索

引结点个数是1。我们把每级索引的结点个数都写下来，也是一个等比数列

![image-20240318210826846](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403182110050.png)

通过等比数列求和公式，总的索引结点大约就是n/3+n/9+n/27+…+9+3+1=n/2。尽管空间复杂度还是O(n) ，但比上面的每两个结点抽一个结点的索引构建方法，要减少了一半的索引结点存储空间。

**所以空间复杂度是O(n)；**

SkipList（跳表）首先是链表，但与传统链表相比有几点差异：

元素按照升序排列存储

节点可能包含多个指针，指针跨度不同。

![image-20240318210934187](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403182110548.png)



![image-20240318210931410](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403182110774.png)

![image-20240318210846156](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403182110375.png)

**优点：**

跳表是一个最典型的空间换时间解决方案，而且只有在数据量较大的情况下才能体现出来优势。而且应该是读多写少的情况下才能使用，所以它的适用范围应该还是比较有限的

 

**缺点：** 

维护成本相对要高，

在单链表中，一旦定位好要插入的位置，插入结点的时间复杂度是很低的，就是O(1) 

but

新增或者删除时需要把所有索引都更新一遍，为了保证原始链表中数据的有序性，我们需要先找

到要动作的位置，这个查找操作就会比较耗时最后在新增和删除的过程中的更新，时间复杂度也是O(log n)