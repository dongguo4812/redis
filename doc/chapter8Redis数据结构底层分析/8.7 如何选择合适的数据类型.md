# 例1：比如存储一个User对象

缓存对象一般有两种存储方式：

## 方式一：json字符串

![image-20240326172631295](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403261754763.png)

优点：简单粗暴

缺点:数据耦合，不够灵活

## 方式二：hash

![image-20240326172704146](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403261754359.png)

优点：底层使用ziplist(redis6)，空间占用小，可以灵活访问对象的任意字段

缺点：结构代码相对复杂

## 例2：hash类型的key，其中有100万对field和value，field是自增id

这个key存在什么问题？如何优化？

![image-20240326173423621](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403261754614.png)

hash的entry数量超过500时，会使用哈希表而不是ziplist，内存占用较多，约62.23M。

方案一：可以适当调整hash-max-ziplist-entries的大小

注意不要设置过多导致bigkey问题

方案二：拆分成string类型

![image-20240326173952485](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403261754609.png)

1.解决了bigkey的问题，但是内存占用较多，约77.54M。

2.批量获取这些数据比较麻烦

方案三：拆分为小的hash，如将id/100作为key，将id%100作为field，这样每100个元素为一个hash

![image-20240326174428587](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403261754390.png)

拆分后大概24.46M

![image-20240326174906889](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403261755815.png)
