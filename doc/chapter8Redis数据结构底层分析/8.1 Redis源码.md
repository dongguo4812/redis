

在Redis中，主要的数据类型包括string（字符串）、hash（哈希）、list（列表）、set（集合）和zset（有序集合）。

此外Bitmap是基于Redis的字符串（string）类型实现的位图数据结构;HyperLogLog是基于字符串（string）类型实现的。Geo功能基于Redis的有序集合（sorted set）实现; Stream是Redis 5.0版本新增加的数据结构。

可使用`type key`查看

| bitmap     | string |
| ---------- | ------ |
| hypeloglog | string |
| geo        | zset   |
| stream     | stream |



# Redis源码

## Redis数据类型的底层数据结构

![image-20240318094302912](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403181824990.png)



## 源码地址

https://github.com/redis/redis/releases/tag/6.2.6

![image-20240318095254492](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403181824987.png)

源码阅读推荐书：《Redis设计与实现》、《Redis5设计与源码分析》

## Redis源代码的核心部分

![image-20240318094033534](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403181824167.png)

## redisObject结构体

Redis是Key-Value数据库，key一般都是String类型的字符串对象，value则是redis对象(redisObject)

![image-20240318101105824](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403181824707.png)

Redis定义了redisObject结构体来表示string、hash、list、set、zset等数据结构。即redis中每个对象都是一个redisObject结构。

C语言中的结构体（`struct`）与Java中的类（`class`）在概念上有一些相似之处，`redisObject`实际上是用C语言`struct`关键字定义的结构体

![image-20240318104709004](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403181824062.png)

  

在Redis的字典结构中，`dictEntry`用于存储键值对，其中值部分是一个指向`redisObject`的指针；而`redisObject`则用于表示实际的数据对象，包含了数据的类型、编码和具体内容等信息。

`dictEntry`用于存储键值对，其中值部分是一个指向`redisObject`的指针；而`redisObject`则是实际数据的持有者，表示了Redis中的对象。

在源码dict.h(hashtable的实现):  

![image-20240318110850320](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403181824452.png)

server.h

![image-20240318111257340](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403181824106.png)

因为dictEntry是hashtable的实现，所以Redis读写操作的时间复杂度是O(1)

![image-20240318111750141](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403181824387.png)





以set hello word为例，因为Redis是KV键值对的数据库，每个键值对都会有一个dictEntry（源码位置：dict.h），里面指向了key和value的指针, next指向下一个dictEntry.

key 是字符串，但是 Redis 没有直接使用 C语言的字符数组，而是存储在redis自定义的 SDS中。value 既不是直接作为字符串存储，也不是直接存储在 SDS中，而是存储在redisObject 中。



```shell
127.0.0.1:6379> set hello world
OK
127.0.0.1:6379> type hello
string
127.0.0.1:6379> OBJECT ENCODING hello
"embstr"
```

## `OBJECT ENCODING <key>` 

`OBJECT ENCODING <key>` 命令，Redis 会返回与指定键相关联的值的内部编码。

![image-20240318133859960](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403181824517.png)



实际上五种常用的数据类型的任何一种，都是通过redisobject 来存储的。这样所有的数据类型就都可以以相同的形式在函数间传递而不用使用特定的类型结构。同时,为了识别不同的数据类型,redisObjec中定义了type和encoding字段对不同的数据类型加以区别。简单地说, redisObjec就是string, hash, list, set, zset的父类,可以在函数间传递时隐藏具体的类型信息,所以作者抽象了redisObjec结构来到达同样的目的。

```c
typedef struct redisObject {  
    unsigned type:4;  
    unsigned encoding:4;  
    unsigned lru:LRU_BITS; /* LRU time (relative to global lru_clock) or  
                             * LFU data (least and most frequently used bits). */  
    int refcount;  
    void *ptr;  
} robj;
```

`redisObject` 结构体是定义在 `server.h` 文件中的，用于表示 Redis 中的所有对象

1. type:

   - **描述**：对象的类型。
   - **取值**：这是一个 4 位的无符号整数，代表对象的类型，如字符串（`OBJ_STRING`）、列表（`OBJ_LIST`）、集合（`OBJ_SET`）、哈希（`OBJ_HASH`）、有序集合（`OBJ_ZSET`）等。这些类型在 `objecttype.h` 文件中定义为枚举值。

2. encoding:

   - **描述**：对象的编码方式。

   - **取值**：这也是一个 4 位的无符号整数，表示对象在内存中的表示形式。不同的对象类型可以有不同的编码方式。例如，字符串对象可以有 "raw" 和 "embstr" 两种编码，而列表对象可以有 "ziplist" 和 "linkedlist" 两种编码。这些编码方式在 `objecttype.h` 文件中也有定义。

     在server.h定义了这些数据结构的编码常量

     ![image-20240318114524533](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403181825506.png)

     各个类型的数据结构的编码映射和定义

     

     ![image-20240318140725106](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403181825706.png)

     ​       

3. lru:

   - **描述**：LRU（Least Recently Used）时间戳或 LFU（Least Frequently Used）数据。
   - **取值**：这是一个无符号整数，用于实现 LRU 或 LFU 缓存淘汰策略。在 LRU 模式下，它记录了对象最后一次被访问的时间（相对于全局的 `lru_clock`）。在 LFU 模式下，它包含了对象被访问的频率信息。具体的位数（`LRU_BITS`）在配置文件中定义，通常是 24 位。

4. refcount:

   - **描述**：对象的引用计数。
   - **取值**：这是一个整数，表示当前对象被引用的次数。当 `refcount` 为 0 时，对象可以被安全地释放。通过引用计数，Redis 实现了对象的共享和内存管理。

5. ptr:

   - **描述**：指向实际数据的指针。
   - **取值**：这是一个通用指针，根据对象的类型和编码方式，它指向不同的数据结构。例如，对于字符串对象，它可能指向一个 SDS（简单动态字符串）结构；对于列表对象，它可能指向一个双端队列等。

## Debug Object key

`Debug Object key`是调试命令，当key存在时，返回有关信息，key不存在时，返回一个错误。

```shell
127.0.0.1:6379> debug object age
Value at:0x7fe700c4a6b0 refcount:2147483647 encoding:int serializedlength:2 lru:16217792 lru_seconds_idle:25688
127.0.0.1:6379> debug object hello
Value at:0x7fe6ef7fb200 refcount:1 encoding:embstr serializedlength:6 lru:16241399 lru_seconds_idle:2710
```

- `Value at:0x7fe700c4a6b0`：表示`age`键的值存储在内存地址为0x7fe700c4a6b0的位置。

- `refcount:2147483647`：表示`age`键的引用计数为2147483647。在Redis中，引用计数用于跟踪一个对象被引用的次数。当引用计数变为0时，该对象将被回收。

- `encoding:int`：表示`age`键的值使用整数编码方式进行存储。

- `serializedlength:2`：表示`age`键的值序列化后占用的字节数为2。

- `lru:16217792`：表示`age`键最近最少使用（LRU）的时间戳为16217792。LRU是一种缓存淘汰策略，用于确定哪些数据应该从缓存中移除以释放空间。

  为什么age的引用计数是2147483647？

在Redis中，整数对象有一个特殊的概念叫做“共享整数”，这是为了优化内存使用。当一个整数的值在-10000到10000之间时，Redis会预先分配这个范围内的所有整数对象，并将它们的引用计数设置为`INT_MAX`，即2147483647。这样做的目的是为了在需要这些整数时可以直接使用，而不需要为每个整数创建一个新的整数对象。

​	为什么age的lru时间戳是16217792？

当一个整数的值在-10000到10000之间时，Redis会直接使用预分配的整数对象来存储这个值，而不是为每个整数都创建一个新的整数对象。这也意味着这些常用的整数对象的LRU时间戳可能会被更新。即redis服务端启动的时间戳。

redis7.0以后这个命令默认不允许使用

![image-20240318141707889](F:\note\image\image-20240318141707889.png)

需要在redis.conf中配置`enable-dug-command local`







# Redis数据类型与数据结构之间的关系

1. SDS动态字符串2. 双向链表3.压缩列表ziplist4.哈希表hashtable5. 跳表skiplist6.整数集合intset7.快速列表quicklist8.紧凑列表listpack



![image-20240318112935315](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403181825605.png)









listpack是用来替代ziplist的新数据结构,在7.0版本已经没有ziplist的配置了(6.0版本仅部分数据类型作为过渡阶段在使用）

listpack 已经替换了 ziplist 

在 Redis 7 中，尽管内部使用了 `listpack`，但许多配置选项和文档仍然使用 `ziplist` 的术语，因为这两个编码在功能上是相似的，并且更改名称可能会引入混淆。因此，`hash-max-ziplist-entries` 实际上控制的是哈希表中字段和值何时从 `listpack` 编码转换为另一种编码（如 `hashtable`）。

![image-20240318112941897](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403181825818.png)











