单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从模式，实现读写分离。

主从复制也叫主从模式，当用户往Master端写入数据时，通过Redis Sync机制将数据文件发送至Slave，Slave也会通过Redis Sync机制将数据文件发送至Master以确保数据一致，来实现Redis的主从复制。如果Master和Slave之间的链接出现断连现象，Slave可以自动重连Master，但是在连接成功之后，一次完全同步将被自动执行。

在主从复制配置后，Master（主节点）可以负责读写服务，Slave（从节点）只负责读服务。Redis复制在Master 这一端是非阻塞的，也就是说在和Slave 同步数据的时候，Master仍然可以执行客户端的操作命令而不受其影响

# 作用

- 读写分离：master负责读，slave负责写。
- 数据备份：从节点可以同步主节点的数据
- 容灾恢复：主节点上的数据丢失或损坏，可以从从节点上恢复。可以结合Sentinel来实现（故障转移）容灾恢复
- 水平扩容支撑高并发：通过增加更多的从节点来分散系统的负载，从而提高系统的并发处理能力。

# 相关细节

## 1.配置从库

主从复制只需要配置从库即可，不用配置主库

## 2.权限细节

master如果配置了requirepass密码参数，需要密码登录。

那么slave就要配置masterauth来设置校验密码，否则master会拒绝slave的访问请求

## 3.操作命令

### info  replication

查看复制节点的主从关系和配置信息

### replicaof 主库ip 主库端口

指定主库，一般在redis.conf配置文件中配置

### slaveof 主库ip 主库端口

`replicaof` 和 `slaveof` 都是用来配置从服务器（slave）追踪主服务器（master）的命令。不过，`slaveof` 是早期Redis版本中的命令，而 `replicaof` 是在较新的版本中引入的，作为 `slaveof` 的替代品。

从Redis 6开始，`slaveof` 命令已被弃用，并推荐使用 `replicaof` 命令来配置主从复制。

### slaveof no one

使当前数据库停止与其他数据库的同步，转成主数据库（单机）

# 搭建主从架构

![image-20240305141100882](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403051411833.png)

本次主从架构共包含三个节点，一个主节点，两个从节点。

三台虚拟机对应3个redis实例，模拟主从集群，信息如下：

| IP              | PORT | 角色   |
| --------------- | ---- | ------ |
| 192.168.122.132 | 7001 | master |
| 192.168.122.133 | 7002 | slave  |
| 192.168.122.134 | 7003 | slave  |

三个redis实例都是从Redis环境搭建时虚拟机拷贝来的。



在配置之前要确保三台机器能够互相ping通

## 通用配置

这里只展示了master的配置，slave配置适当修改即可

1.关闭redis的开机自启

```shell
[root@redis-7001 opt]# systemctl disable redis
Removed symlink /etc/systemd/system/multi-user.target.wants/redis.service.
```

2.将redis.conf拷贝为redis7001.conf，剩下两个对应端口即可

```shell
[root@redis-7001 opt]# cd /opt/redis-6.2.6
[root@redis-7001 redis-6.2.6]# cp redis.conf redis7001.conf
```

## 配置master

修改redis7001.conf配置

1. daemonize yes  #开启守护进程模式，Redis在后台运行
2. bind  0.0.0.0    #也可以注掉
3. port 7001  #指定端口
4. dir /myredis  #指定当前工作目录
5. pidfile /var/run/redis_7001.pid  #PID写入的文件目录
6. logfile "/myredis/redis.log"   #日志文件地址
7. requirepass  root  #密码
8. dbfilename dump7001.rdb   #RDB文件，为区分可加端口号进行区分，也可以不改 

## 配置slave

修改redis7002.conf配置，slave7003配置适当修改即可

1. daemonize yes  #开启守护进程模式，Redis在后台运行
2. bind  0.0.0.0    #也可以注掉
3. port 7001  #指定端口
4. dir /myredis  #指定当前工作目录
5. pidfile /var/run/redis_7002.pid  #PID写入的文件目录
6. logfile "/myredis/redis.log"   #日志文件地址
7. requirepass  root  #密码
8. masterauth root #若master主机设置了密码  slave从机必须配置masterauth
9. replicaof 192.168.122.132 7001  #指定master的ip 端口



可选参数设置：

1. appendonly no #主从 此次不开启aof持久化

1. dbfilename dump7002.rdb   #RDB文件，为区分可加端口号进行区分，也可以不改 
10. slave-read-only yes #为了防止slave被误写，可以在Slave上设置写权限为no

## 启动redis

master7001

```shell
[root@redis-7001 redis-6.2.6]# redis-server /opt/redis-6.2.6/redis7001.conf 
[root@redis-7001 redis-6.2.6]# redis-cli -a root -p 7001
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.
127.0.0.1:7001> 
```

slave7002

```shell
[root@redis-7002 redis-6.2.6]# redis-server /opt/redis-6.2.6/redis7002.conf 
[root@redis-7002 redis-6.2.6]# redis-cli -a root -p 7002
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.
127.0.0.1:7002> 
```

slave7003

```shell
[root@redis-7003 redis-6.2.6]# redis-server /opt/redis-6.2.6/redis7003.conf 
[root@redis-7003 redis-6.2.6]# redis-cli -a root -p 7003
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.
127.0.0.1:7003> 
```

## 主从关系查看

查看master7001的日志

```shell
1183:C 05 Mar 2024 19:36:18.031 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo
1183:C 05 Mar 2024 19:36:18.031 # Redis version=6.2.6, bits=64, commit=00000000, modified=0, pid=1183, just started
1183:C 05 Mar 2024 19:36:18.031 # Configuration loaded
1183:M 05 Mar 2024 19:36:18.033 * Increased maximum number of open files to 10032 (it was originally set to 1024).
1183:M 05 Mar 2024 19:36:18.033 * monotonic clock: POSIX clock_gettime
1183:M 05 Mar 2024 19:36:18.034 * Running mode=standalone, port=7001.
1183:M 05 Mar 2024 19:36:18.034 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.
1183:M 05 Mar 2024 19:36:18.034 # Server initialized
1183:M 05 Mar 2024 19:36:18.034 # WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.
1183:M 05 Mar 2024 19:36:18.034 * Ready to accept connections
1183:M 05 Mar 2024 19:36:24.169 * Replica 192.168.122.133:7002 asks for synchronization
1183:M 05 Mar 2024 19:36:24.169 * Full resync requested by replica 192.168.122.133:7002
1183:M 05 Mar 2024 19:36:24.169 * Replication backlog created, my new replication IDs are 'fead4b22a898c6b853b85981b0b8934f9ed633ea' and '0000000000000000000000000000000000000000'
1183:M 05 Mar 2024 19:36:24.169 * Starting BGSAVE for SYNC with target: disk
1183:M 05 Mar 2024 19:36:24.170 * Background saving started by pid 1190
1190:C 05 Mar 2024 19:36:24.171 * DB saved on disk
1190:C 05 Mar 2024 19:36:24.171 * RDB: 2 MB of memory used by copy-on-write
1183:M 05 Mar 2024 19:36:24.269 * Background saving terminated with success
1183:M 05 Mar 2024 19:36:24.270 * Synchronization with replica 192.168.122.133:7002 succeeded
1183:M 05 Mar 2024 19:36:31.476 * Replica 192.168.122.134:7003 asks for synchronization
1183:M 05 Mar 2024 19:36:31.476 * Full resync requested by replica 192.168.122.134:7003
1183:M 05 Mar 2024 19:36:31.476 * Starting BGSAVE for SYNC with target: disk
1183:M 05 Mar 2024 19:36:31.476 * Background saving started by pid 1191
1191:C 05 Mar 2024 19:36:31.477 * DB saved on disk
1191:C 05 Mar 2024 19:36:31.477 * RDB: 2 MB of memory used by copy-on-write
1183:M 05 Mar 2024 19:36:31.539 * Background saving terminated with success
1183:M 05 Mar 2024 19:36:31.539 * Synchronization with replica 192.168.122.134:7003 succeeded
```

Synchronization with replica 192.168.122.133:7002 succeeded

Synchronization with replica 192.168.122.134:7003 succeeded

从以上两行日志说明，salve7002、slave7003成功的与master7001进行了同步。

查看slave7002的日志

```shell
1189:C 05 Mar 2024 19:36:24.184 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo
1189:C 05 Mar 2024 19:36:24.184 # Redis version=6.2.6, bits=64, commit=00000000, modified=0, pid=1189, just started
1189:C 05 Mar 2024 19:36:24.184 # Configuration loaded
1189:S 05 Mar 2024 19:36:24.185 * Increased maximum number of open files to 10032 (it was originally set to 1024).
1189:S 05 Mar 2024 19:36:24.185 * monotonic clock: POSIX clock_gettime
1189:S 05 Mar 2024 19:36:24.187 * Running mode=standalone, port=7002.
1189:S 05 Mar 2024 19:36:24.187 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.
1189:S 05 Mar 2024 19:36:24.187 # Server initialized
1189:S 05 Mar 2024 19:36:24.187 # WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.
1189:S 05 Mar 2024 19:36:24.187 * Ready to accept connections
1189:S 05 Mar 2024 19:36:24.188 * Connecting to MASTER 192.168.122.132:7001
1189:S 05 Mar 2024 19:36:24.188 * MASTER <-> REPLICA sync started
1189:S 05 Mar 2024 19:36:24.189 * Non blocking connect for SYNC fired the event.
1189:S 05 Mar 2024 19:36:24.189 * Master replied to PING, replication can continue...
1189:S 05 Mar 2024 19:36:24.189 * Partial resynchronization not possible (no cached master)
1189:S 05 Mar 2024 19:36:24.190 * Full resync from master: fead4b22a898c6b853b85981b0b8934f9ed633ea:0
1189:S 05 Mar 2024 19:36:24.290 * MASTER <-> REPLICA sync: receiving 175 bytes from master to disk
1189:S 05 Mar 2024 19:36:24.290 * MASTER <-> REPLICA sync: Flushing old data
1189:S 05 Mar 2024 19:36:24.290 * MASTER <-> REPLICA sync: Loading DB in memory
1189:S 05 Mar 2024 19:36:24.291 * Loading RDB produced by version 6.2.6
1189:S 05 Mar 2024 19:36:24.291 * RDB age 0 seconds
1189:S 05 Mar 2024 19:36:24.291 * RDB memory usage when created 1.85 Mb
1189:S 05 Mar 2024 19:36:24.291 # Done loading RDB, keys loaded: 0, keys expired: 0.
1189:S 05 Mar 2024 19:36:24.291 * MASTER <-> REPLICA sync: Finished with success
```

Connecting to MASTER 192.168.122.132:7001 该行日志说明slave7002与master7001成功连接

MASTER <-> REPLICA sync: Finished with success  同步成功

查看slave7003的日志

```shell
1191:C 05 Mar 2024 19:36:31.466 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo
1191:C 05 Mar 2024 19:36:31.466 # Redis version=6.2.6, bits=64, commit=00000000, modified=0, pid=1191, just started
1191:C 05 Mar 2024 19:36:31.466 # Configuration loaded
1191:S 05 Mar 2024 19:36:31.467 * Increased maximum number of open files to 10032 (it was originally set to 1024).
1191:S 05 Mar 2024 19:36:31.467 * monotonic clock: POSIX clock_gettime
1191:S 05 Mar 2024 19:36:31.469 * Running mode=standalone, port=7003.
1191:S 05 Mar 2024 19:36:31.469 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.
1191:S 05 Mar 2024 19:36:31.469 # Server initialized
1191:S 05 Mar 2024 19:36:31.469 # WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.
1191:S 05 Mar 2024 19:36:31.469 * Ready to accept connections
1191:S 05 Mar 2024 19:36:31.470 * Connecting to MASTER 192.168.122.132:7001
1191:S 05 Mar 2024 19:36:31.470 * MASTER <-> REPLICA sync started
1191:S 05 Mar 2024 19:36:31.470 * Non blocking connect for SYNC fired the event.
1191:S 05 Mar 2024 19:36:31.470 * Master replied to PING, replication can continue...
1191:S 05 Mar 2024 19:36:31.471 * Partial resynchronization not possible (no cached master)
1191:S 05 Mar 2024 19:36:31.471 * Full resync from master: fead4b22a898c6b853b85981b0b8934f9ed633ea:14
1191:S 05 Mar 2024 19:36:31.535 * MASTER <-> REPLICA sync: receiving 175 bytes from master to disk
1191:S 05 Mar 2024 19:36:31.535 * MASTER <-> REPLICA sync: Flushing old data
1191:S 05 Mar 2024 19:36:31.535 * MASTER <-> REPLICA sync: Loading DB in memory
1191:S 05 Mar 2024 19:36:31.535 * Loading RDB produced by version 6.2.6
1191:S 05 Mar 2024 19:36:31.535 * RDB age 0 seconds
1191:S 05 Mar 2024 19:36:31.535 * RDB memory usage when created 1.87 Mb
1191:S 05 Mar 2024 19:36:31.535 # Done loading RDB, keys loaded: 0, keys expired: 0.
1191:S 05 Mar 2024 19:36:31.535 * MASTER <-> REPLICA sync: Finished with success
```

Connecting to MASTER 192.168.122.132:7001 该行日志说明slave7003与master7001成功连接

MASTER <-> REPLICA sync: Finished with success  同步成功

### info  replication

还可以使用info  replication命令查看主从关系

master7001：

```shell
127.0.0.1:7001> info  replication
# Replication
role:master
connected_slaves:2
slave0:ip=192.168.122.133,port=7002,state=online,offset=924,lag=0
slave1:ip=192.168.122.134,port=7003,state=online,offset=924,lag=0
master_failover_state:no-failover
master_replid:fead4b22a898c6b853b85981b0b8934f9ed633ea
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:924
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:924
```

slave7002：

```shell
127.0.0.1:7002> info  replication
# Replication
role:slave
master_host:192.168.122.132
master_port:7001
master_link_status:up
master_last_io_seconds_ago:9
master_sync_in_progress:0
slave_read_repl_offset:1134
slave_repl_offset:1134
slave_priority:100
slave_read_only:1
replica_announced:1
connected_slaves:0
master_failover_state:no-failover
master_replid:fead4b22a898c6b853b85981b0b8934f9ed633ea
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:1134
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:1134
```

slave7003：

```shell
127.0.0.1:7003> info  replication
# Replication
role:slave
master_host:192.168.122.132
master_port:7001
master_link_status:up
master_last_io_seconds_ago:0
master_sync_in_progress:0
slave_read_repl_offset:1190
slave_repl_offset:1190
slave_priority:100
slave_read_only:1
replica_announced:1
connected_slaves:0
master_failover_state:no-failover
master_replid:fead4b22a898c6b853b85981b0b8934f9ed633ea
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:1190
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:15
repl_backlog_histlen:1176
```

# 测试一

## master可读写，slave可读

master7001执行set k1 v1

```shell
127.0.0.1:7001> set k1 v1
OK
127.0.0.1:7001> get k1
"v1"
```

slave7002执行get k1

```shell
127.0.0.1:7002> get k1
"v1"
```

slave7003执行get k1

```shell
127.0.0.1:7003> get k1
"v1"
```

在master中写入，在master中可以读到，在slave中也可以读到。

## slave不可写

在slave中写入k2

```shell
127.0.0.1:7002> set k2 v2
(error) READONLY You can't write against a read only replica.
```

slave节点不能执行写操作，只能执行读操作

这样我们就可以master负责执行写操作，slave负责执行读操作，实现读写分离。

## slave是从头开始赋值还是从切入点开始复制

master启动写入k3，slave7002跟着master同时启动，跟着写入k3

slave7003写入k3后才启动，那么值钱的是否也会进行复制？

1.先将slave7003关闭redis服务端

```shell
127.0.0.1:7003> shutdown
not connected> quit
```

2.master写入k2、k3

```shell
127.0.0.1:7001> set k2 v2
OK
127.0.0.1:7001> set k3 v3
OK
```

3.slave7002能够获取到k2、k3

```shell
127.0.0.1:7002> get k2
"v2"
127.0.0.1:7002> get k3
"v3"
```

4.启动slave7003的redis服务端，连接客户端后，也可以读到k2、k3

```shell
[root@redis-7003 ~]# redis-server /opt/redis-6.2.6/redis7003.conf 
[root@redis-7003 ~]# redis-cli -a root -p 7003
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.
127.0.0.1:7003> get k2
"v2"
127.0.0.1:7003> get k3
"v3"
```

5.master写入k4

```shell
127.0.0.1:7001> set k4 v4
OK
```

6.slave7002读到k4

```shell
127.0.0.1:7002> get k4
"v4"
```

7.slave7003读到k4

```shell
127.0.0.1:7003> get k4
"v4"
```

结论：salve第一次同步所有内容，后续跟随master， master写一个，slave跟着同步一个

## 主机宕机后，从机是否变为主机？

1.master关闭redis服务端

```shell
127.0.0.1:7001> shutdown
not connected> quit
```

2.查看slave7002的主从关系

```shell
127.0.0.1:7002> info  replication
# Replication
role:slave
master_host:192.168.122.132
master_port:7001
master_link_status:down
master_last_io_seconds_ago:-1
master_sync_in_progress:0
slave_read_repl_offset:3345
slave_repl_offset:3345
master_link_down_since_seconds:74
slave_priority:100
slave_read_only:1
replica_announced:1
connected_slaves:0
master_failover_state:no-failover
master_replid:fead4b22a898c6b853b85981b0b8934f9ed633ea
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:3345
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:3345
```

master_link_status:down表示与master之间的连接断开

3.查看slave7003的主从关系

```shell
127.0.0.1:7003> info  replication
# Replication
role:slave
master_host:192.168.122.132
master_port:7001
master_link_status:down
master_last_io_seconds_ago:-1
master_sync_in_progress:0
slave_read_repl_offset:3345
slave_repl_offset:3345
master_link_down_since_seconds:116
slave_priority:100
slave_read_only:1
replica_announced:1
connected_slaves:0
master_failover_state:no-failover
master_replid:fead4b22a898c6b853b85981b0b8934f9ed633ea
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:3345
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:2349
repl_backlog_histlen:997
```

master_link_status:down表示也与master之间的连接断开



结论：主从不会自动重新选举，一直等待主机恢复重启

## 主机宕机重启后主从关系还在吗？

1.master启动redis服务端

```shell
[root@redis-7001 ~]# redis-server /opt/redis-6.2.6/redis7001.conf 
[root@redis-7001 ~]# redis-cli -a root -p 7001
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.
127.0.0.1:7001> 
```

2.查看master7001的主从关系，依然是master，有两个slave

```shell
127.0.0.1:7001> info  replication
# Replication
role:master
connected_slaves:2
slave0:ip=192.168.122.134,port=7003,state=online,offset=70,lag=1
slave1:ip=192.168.122.133,port=7002,state=online,offset=70,lag=0
master_failover_state:no-failover
master_replid:750d7b9e308af4a181fafaee782587b96dd75fdb
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:70
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:70
```

2.查看slave7002的主从关系

```shell
127.0.0.1:7002> info  replication
# Replication
role:slave
master_host:192.168.122.132
master_port:7001
master_link_status:up
master_last_io_seconds_ago:9
master_sync_in_progress:0
slave_read_repl_offset:140
slave_repl_offset:140
slave_priority:100
slave_read_only:1
replica_announced:1
connected_slaves:0
master_failover_state:no-failover
master_replid:750d7b9e308af4a181fafaee782587b96dd75fdb
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:140
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:140
```


3.查看slave7003的主从关系

```shell
127.0.0.1:7003> info  replication
# Replication
role:slave
master_host:192.168.122.132
master_port:7001
master_link_status:up
master_last_io_seconds_ago:1
master_sync_in_progress:0
slave_read_repl_offset:154
slave_repl_offset:154
slave_priority:100
slave_read_only:1
replica_announced:1
connected_slaves:0
master_failover_state:no-failover
master_replid:750d7b9e308af4a181fafaee782587b96dd75fdb
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:154
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:154
```

4.master写入k5

```shell
127.0.0.1:7001> set k5 v5
OK
```

5.slave依然能够正常同步读取到k5

```shell
127.0.0.1:7002> get k5
"v5"
```

```shell
127.0.0.1:7003> get k5
"v5"
```

结论：主机宕机重启后主从关系还在，从机依然能够顺利复制同步。

## 从机宕机后，主机写入新的数据，从机重启后还能同步宕机时产生的数据吗

slave是从头开始赋值还是从切入点开始复制时已经验证，从机重启后会同步之前的所有数据。

# 测试二

从机停机去掉配置文件中slave相关的配置，恢复成3台都是主机的状态。

1.两个从机关闭redis服务端

```shell
127.0.0.1:7002> shutdown
not connected> quit
```

```shell
127.0.0.1:7003> shutdown
not connected> quit
```

2.查看master的主从关系，有0个slave连接

```shell
127.0.0.1:7001> info  replication
# Replication
role:master
connected_slaves:0
master_failover_state:no-failover
master_replid:750d7b9e308af4a181fafaee782587b96dd75fdb
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:1508
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:1508
```

3.注释掉从机的主从配置

slave7002的redis7002.conf注释掉replicaof 192.168.122.132 7001

slave7003的redis7002.conf注释掉replicaof 192.168.122.132 7001

4.重新启动slave7002、slave7003，查看他们都是独自的主机状态

```shell
[root@redis-7002 ~]# redis-server /opt/redis-6.2.6/redis7002.conf 
[root@redis-7002 ~]# redis-cli -a root -p 7002
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.
127.0.0.1:7002> info  replication
# Replication
role:master
connected_slaves:0
master_failover_state:no-failover
master_replid:ca699c1b3daf3b06bd96763ad5e95593a4542367
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:0
second_repl_offset:-1
repl_backlog_active:0
repl_backlog_size:1048576
repl_backlog_first_byte_offset:0
repl_backlog_histlen:0
```

```shell
[root@redis-7003 ~]# redis-server /opt/redis-6.2.6/redis7003.conf 
[root@redis-7003 ~]# redis-cli -a root -p 7003
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.
127.0.0.1:7003> info  replication
# Replication
role:master
connected_slaves:0
master_failover_state:no-failover
master_replid:03646644da51b9da16234221b63813ebbd84ae28
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:0
second_repl_offset:-1
repl_backlog_active:0
repl_backlog_size:1048576
repl_backlog_first_byte_offset:0
repl_backlog_histlen:0
```

## 指定7002是7001的从机

7001作为主机，7002作为从机

```shell
127.0.0.1:7002> replicaof 192.168.122.132 7001
OK
127.0.0.1:7002> info  replication
# Replication
role:slave
master_host:192.168.122.132
master_port:7001
master_link_status:up
master_last_io_seconds_ago:9
master_sync_in_progress:0
slave_read_repl_offset:1550
slave_repl_offset:1550
slave_priority:100
slave_read_only:1
replica_announced:1
connected_slaves:0
master_failover_state:no-failover
master_replid:750d7b9e308af4a181fafaee782587b96dd75fdb
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:1550
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1509
repl_backlog_histlen:42
```

## 指定7003是7001的从机

```shell
127.0.0.1:7003> replicaof 192.168.122.132 7001
OK
127.0.0.1:7003> info  replication
# Replication
role:slave
master_host:192.168.122.132
master_port:7001
master_link_status:up
master_last_io_seconds_ago:1
master_sync_in_progress:0
slave_read_repl_offset:1788
slave_repl_offset:1788
slave_priority:100
slave_read_only:1
replica_announced:1
connected_slaves:0
master_failover_state:no-failover
master_replid:750d7b9e308af4a181fafaee782587b96dd75fdb
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:1788
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1789
repl_backlog_histlen:0
```

查看7001的主从关系

```shell
127.0.0.1:7001> info  replication
# Replication
role:master
connected_slaves:2
slave0:ip=192.168.122.133,port=7002,state=online,offset=2446,lag=1
slave1:ip=192.168.122.134,port=7003,state=online,offset=2446,lag=1
master_failover_state:no-failover
master_replid:750d7b9e308af4a181fafaee782587b96dd75fdb
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:2446
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:2446
```



## 使用命令的主从，从机重启后，主从关系还存在吗

1.关闭7002、7003的redis服务端

```quit
127.0.0.1:7002> shutdown
not connected> quit
```

```shell
127.0.0.1:7003> shutdown
not connected> quit
```

2.查看7001的主从关系

```shell
127.0.0.1:7001> info  replication
# Replication
role:master
connected_slaves:0
master_failover_state:no-failover
master_replid:750d7b9e308af4a181fafaee782587b96dd75fdb
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:2740
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:2740
```

3.启动7002、7003的redis服务端

```shell
[root@redis-7002 ~]# redis-server /opt/redis-6.2.6/redis7002.conf 
[root@redis-7002 ~]# redis-cli -a root -p 7002
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.
127.0.0.1:7002> 
```

```shell
[root@redis-7003 ~]# redis-server /opt/redis-6.2.6/redis7003.conf 
[root@redis-7003 ~]# redis-cli -a root -p 7003
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.
127.0.0.1:7003> 
```

4.查看7001的主从关系

```shell
127.0.0.1:7001> info  replication
# Replication
role:master
connected_slaves:0
master_failover_state:no-failover
master_replid:750d7b9e308af4a181fafaee782587b96dd75fdb
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:2740
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:2740
```

结论：使用命令的方式实现主从，本次生效，重启失效。如果想要永久生效，要使用配置的方式实现主从。

## slave可以作为别的机器的maste

![img](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403052145468.jpeg)

上一个slave可以是下一个slave的master,slave同样可以接收其他slaves的连接和同步请求，那么该slave作为了链条中下一个的master,可以有效减轻主master的写压力。

从机变更所属主机，会清除之前的数据，重新建立拷贝最新的数据。

1.两个从机关闭redis服务端

```shell
127.0.0.1:7002> shutdown
not connected> quit
```

```shell
127.0.0.1:7003> shutdown
not connected> quit
```

2.恢复之前的主从配置

取消注释从机的主从配置

slave7002的redis7002.conf取消注释replicaof 192.168.122.132 7001

slave7003的redis7002.conf取消注释掉replicaof 192.168.122.132 7001

3.重启启动两个从机

```shell
[root@redis-7002 ~]# redis-server /opt/redis-6.2.6/redis7002.conf 
[root@redis-7002 ~]# redis-cli -a root -p 7002
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.
127.0.0.1:7002> 
```

```shell
[root@redis-7003 ~]# redis-server /opt/redis-6.2.6/redis7003.conf 
[root@redis-7003 ~]# redis-cli -a root -p 7003
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.
127.0.0.1:7003> 
```

4.查看master的主从信息

```shell
127.0.0.1:7001> info  replication
# Replication
role:master
connected_slaves:2
slave0:ip=192.168.122.133,port=7002,state=online,offset=2754,lag=1
slave1:ip=192.168.122.134,port=7003,state=online,offset=2754,lag=1
master_failover_state:no-failover
master_replid:750d7b9e308af4a181fafaee782587b96dd75fdb
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:2754
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:2754
```

5.7002作为7003的master

```shell
127.0.0.1:7003> replicaof 192.168.122.133 7002
OK
```

6.查看7001的主从信息，只有1个从机7002

```shell
127.0.0.1:7001> info  replication
# Replication
role:master
connected_slaves:1
slave0:ip=192.168.122.133,port=7002,state=online,offset=3034,lag=1
master_failover_state:no-failover
master_replid:750d7b9e308af4a181fafaee782587b96dd75fdb
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:3034
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:3034
```

7.查看7002的主从关系，属于slave，但是它本身还有一个slave7003

```shell
127.0.0.1:7002> info  replication
# Replication
role:slave
master_host:192.168.122.132
master_port:7001
master_link_status:up
master_last_io_seconds_ago:6
master_sync_in_progress:0
slave_read_repl_offset:3104
slave_repl_offset:3104
slave_priority:100
slave_read_only:1
replica_announced:1
connected_slaves:1
slave0:ip=192.168.122.134,port=7003,state=online,offset=3104,lag=0
master_failover_state:no-failover
master_replid:750d7b9e308af4a181fafaee782587b96dd75fdb
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:3104
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:2741
repl_backlog_histlen:364
```

8.查看7003的主从关系，它的master是7002

```shell
127.0.0.1:7003> info  replication
# Replication
role:slave
master_host:192.168.122.133
master_port:7002
master_link_status:up
master_last_io_seconds_ago:10
master_sync_in_progress:0
slave_read_repl_offset:3286
slave_repl_offset:3286
slave_priority:100
slave_read_only:1
replica_announced:1
connected_slaves:0
master_failover_state:no-failover
master_replid:750d7b9e308af4a181fafaee782587b96dd75fdb
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:3286
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:2755
repl_backlog_histlen:532
```

9.master7001写入k6，7002、7003读取k6

```shell
127.0.0.1:7001> set k6 v6
OK
```



```shell
127.0.0.1:7002> get k6
"v6"
```



```shell
127.0.0.1:7003> get k6
"v6"
```

## 7002作为7001的slave，作为7003的master，那7002是否可以执行写操作？

```shel
127.0.0.1:7002> set k7 v7
(error) READONLY You can't write against a read only replica.
```

结论：属于slave角色，无法执行写操作

## 7003取消主从关系

```shell
127.0.0.1:7003> info  replication
# Replication
role:slave
master_host:192.168.122.133
master_port:7002
master_link_status:up
master_last_io_seconds_ago:10
master_sync_in_progress:0
slave_read_repl_offset:3286
slave_repl_offset:3286
slave_priority:100
slave_read_only:1
replica_announced:1
connected_slaves:0
master_failover_state:no-failover
master_replid:750d7b9e308af4a181fafaee782587b96dd75fdb
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:3286
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:2755
repl_backlog_histlen:532
127.0.0.1:7003> SLAVEOF no one
OK
```

再次查看主从关系，7003从slave变为了master，并且保留之前的数据。

```shell
127.0.0.1:7003> info  replication
# Replication
role:master
connected_slaves:0
master_failover_state:no-failover
master_replid:ee16c3245167c22c469ad81da287b1137cfef52c
master_replid2:750d7b9e308af4a181fafaee782587b96dd75fdb
master_repl_offset:3884
second_repl_offset:3885
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:2755
repl_backlog_histlen:1130
127.0.0.1:7003> keys *
1) "k3"
2) "k4"
3) "k5"
4) "k6"
5) "k2"
6) "k1"
```

# 主从复制原理

## 全量复制

全量复制是指在初次复制或其他无法进行部分复制的情况下，将主节点（Master）上的全部数据一次性发送给从节点（Slave）的过程。

当数据量较大时，会对主从节点和网络造成很大的开销。全量复制的时间开销包括主节点bgsave时间、RDB文件网络传输时间、从节点清空数据时间、从节点加载RDB的时间以及可能的AOF重写时间。

## 增量复制

增量复制发生在Slave节点初始化后开始正常工作时，主节点持续地把写命令发送给从节点，保证主从数据一致性。

如果主从库在命令传播时出现了网络闪断，从库就会和主库重新进行一次全量复制，那么开销非常大。从 Redis 2.8 开始，网络断了之后，主从库会优先采用增量复制的方式继续同步。

如果网络中断时间过长，造成主节点没有能够完整地保存中断期间执行的写命令，则无法进行部分复制，仍需要使用全量复制。

## slave启动，初次请求全量同步

![image-20240306075804377](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403060758423.png)

- slave启动成功连接到master后会发送一个psync命令（Redis2.8之前是sync命令），


- 如果是第一次同步，master返回版本信息，开始执行bgsave（异步执行，主从同步触发RDB），将RDB文件发送给slave，salve清空自身数据执行==全量同步==。


- master将RDB期间产生的所有命令缓存到repl_baklog中，master发送完RDB快照文件之后，便开始向slave发送repl_baklog缓冲区中的写命令，slave执行==增量同步==

如果master收到了多个slave并发连接请求，它只会进行一次RDB持久化，而不是每个连接都执行一次，然后再把这一份RDB持久化的数据发送给多个并发连接的slave。

如果RDB全量复制时间超过60秒（repl-timeout），那么slave服务器就会认为复制失败，可以适当调节这个参数`repl-timeout 60`

`client-output-buffer-limit slave 256MB 64MB 60`，如果在复制期间，内存缓冲区持续60秒超过64MB，或者一次性超过256MB，那么停止复制，复制失败

## slave再次请求，增量同步

slave重启成功连接到master后会再次发送一个sync命令，

如果不是第一次同步，master会将repl_baklog中大于slave的offset的数据发送给slave，slave执行==增量同步==

![image-20240306080206823](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403060802993.png)

## master如何得知salve是第一次来连接呢，即是不是第一次来同步数据？

有几个概念，可以作为判断依据：

- Replication Id

简称replid，是数据集的标记，id一致则说明是同一数据集。每一个master都有唯一的replid，slave则会继承master节点的replid

- offset

偏移量，随着记录在repl_baklog中的数据增多而逐渐增大。slave完成同步时也会记录当前同步的offset。如果slave的offset小于master的offset，说明slave数据落后于master，需要更新。

因此slave做数据同步，必须向master声明自己的replication id 和offset，master才可以判断到底需要同步哪些数据。

比如slave原本也是一个master，有自己的replid和offset，当第一次变成slave，与master建立连接时，发送的replid和offset是自己的replid和offset。

master判断发现slave发送来的replid与自己的不一致，说明这是一个全新的slave，就知道要做全量同步了。

master会将自己的replid和offset都发送给这个slave，slave保存这些信息。以后slave的replid就与master一致了。

因此，**master判断一个节点是否是第一次同步的依据，就是看replid是否一致**。

![image-20240306080824505](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403060808472.png)

## master怎么知道slave与自己的数据差异在哪里呢?

master会检查backlog里面的offset,master和slave都会保存一个复制的offset还有一个masterId,offset是保存在backlog中的。Master只需要把已经复制的offset后面的数据复制给Slave。

### repl_baklog原理

这个文件是一个固定大小的数组，只不过数组是环形，也就是说**角标到达数组末尾后，会再次从0开始读写**，这样数组头部的数据就会被覆盖。

repl_baklog中会记录Redis处理过的命令日志及offset，包括master当前的offset，和slave已经拷贝到的offset：

![image-20240306081052081](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403060811786.png)

slave与master的offset之间的差异，就是salve需要增量拷贝的数据了。

随着不断有数据写入，master的offset逐渐变大，slave也不断的拷贝，追赶master的offset：

![image-20240306081111913](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403060811785.png)

直到数组被填满：

![image-20240306081121553](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403060811313.png)

此时，如果有新的数据写入，就会覆盖数组中的旧数据。不过，旧的数据只要是绿色的，说明是已经被同步到slave的数据，即便被覆盖了也没什么影响。因为未同步的仅仅是红色部分。

但是，如果slave出现网络阻塞，导致master的offset远远超过了slave的offset： 

![image-20240306081140537](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403060811357.png)

如果master继续写入新数据，其offset就会覆盖旧的数据，直到将slave现在的offset也覆盖：

![image-20240306081154167](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403060811137.png)

棕色框中的红色部分，就是尚未同步，但是却已经被覆盖的数据。此时如果slave恢复，需要同步，却发现自己的offset都没有了，无法完成增量同步了。只能做全量同步。

注意：repl_baklog大小有上限，写满后会覆盖最早的数据。如果slave断开时间过久，导致尚未备份的数据被覆盖，则无法基于log做增量同步，只能再次全量同步。

数据被覆盖导致无法做增量同步这个问题是无法解决的，只能尽量避免进行全量同步和优化全量同步。

## 心跳检测

redis.conf：

```shell
repl-ping-replica-period 10
```

master发出ping心跳包的周期，默认是10秒。通过定期发送 PING 命令，master可以确认slave是否仍然在线，并且能够正常接收和处理数据。

## 为什么会有从库的从库的设计？

通过分析主从库间第一次数据同步的过程，你可以看到，一次全量复制中，对于主库来说，需要完成两个耗时的操作：生成 RDB 文件和传输 RDB 文件。

如果从库数量很多，而且都要和主库进行全量复制的话，就会导致主库忙于 fork 子进程生成 RDB 文件，进行数据全量复制。fork 这个操作会阻塞主线程处理正常请求，从而导致主库响应应用程序的请求速度变慢。此外，传输 RDB 文件也会占用主库的网络带宽，同样会给主库的资源使用带来压力。
于是就有了“主 - 从 - 从”模式。我们可以通过“主 - 从 - 从”模式将主库生成 RDB 和传输 RDB 的压力，以级联的方式分散到从库上。这些从库就会知道，在进行同步时，不用再和主库进行交互了，只要和级联的从库进行写操作同步就行了，这就可以减轻主库上的压力。

![image-20240306082215869](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403060822192.png)

## 为什么主从全量复制使用RDB而不使用AOF？

- RDB文件内容是经过压缩的二进制数据（不同数据类型数据做了针对性优化），文件很小。而AOF文件记录的是每一次写操作的命令，写操作越多文件会变得很大，其中还包括很多对同一个key的多次冗余操作。在主从全量数据同步时，传输RDB文件可以尽量降低对主库机器网络带宽的消耗，从库在加载RDB文件时，一是文件小，读取整个文件的速度会很快，二是因为RDB文件存储的都是二进制数据，从库直接按照RDB协议解析还原数据即可，速度会非常快，而AOF需要依次重放每个写命令，这个过程会经历冗长的处理逻辑，恢复速度相比RDB会慢得多，所以使用RDB进行主从全量复制的成本最低。

- 假设要使用AOF做全量复制，意味着必须打开AOF功能，打开AOF就要选择文件刷盘的策略，选择不当会严重影响Redis性能。而RDB只有在需要定时备份和主从全量复制数据时才会触发生成一次快照。而在很多丢失数据不敏感的业务场景，其实是不需要开启AOF的。

  

  文件刷盘策略appendfsync：always、everysec、no

## 当主服务器不进行持久化时自动重启的安全性

关闭持久化：RDB设置save "";AOF设置appendonly no。

- 我们设置节点A为主服务器，关闭持久化，节点B和C从节点A复制数据。

- 这时出现了一个崩溃，因为关闭了持久化，节点重启后只有一个空的数据集。

- 节点B和C从节点A进行复制，现在节点A是空的，所以节点B和C上的复制数据也会被删除。

- 当在高可用系统中使用Redis Sentinel，关闭了主服务器的持久化，并且允许自动重启，这种情况是很危险的。比如主服务器可能在很短的时间就完成了重启，以至于Sentinel都无法检测到这次失败，那么上面说的这种失败的情况就发生了。

  



# 主从复制缺点

### 1.复制延时，信号衰减

由于所有的写操作都是先在Master上操作，然后异步更新到Slave上，所以从Master更新到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。

如果应用对数据不一致的接受程度程度较低，可能的优化措施包括：

- 优化主从节点之间的网络环境（如在同机房部署）；

- 监控主从节点延迟（通过offset）判断，如果从节点延迟过大，通知应用不再通过该从节点读取数据；

### 2.master存在单机故障

master宕机不会在slave节点中自动重选一个master。

解决方案：使用哨兵的读写分离方案，实现故障转移。

# 主从复制优化

主从同步可以保证主从数据的一致性，非常重要。

可以从以下几个方面来优化Redis主从就集群：

- 在master中配置repl-diskless-sync yes启用无磁盘复制，避免全量同步时的磁盘IO。直接网络通信同步数据，受到网络带宽的限制

- Redis单节点上的内存占用不要太大，减少RDB导致的过多磁盘IO
- 适当提高repl_baklog的大小，发现slave宕机时尽快实现故障恢复，尽可能避免全量同步
- 限制一个master上的slave节点数量，如果实在是太多slave，则可以采用主-从-从链式结构，减少master压力

