# 微信文章阅读量统计实战

![QQ浏览器截图20240309214040](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403092144351.png)

## 用户阅读文章贡献一个阅读量

分析：使用string的incr实现增加阅读量。

ArticleService：

```java
import jakarta.annotation.Resource;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;
import static com.dongguo.redis.utils.CacheKeyUtil.CACHE_ARTICLE_KEY;

@Slf4j
@Service
public class ArticleService {
    @Resource
    private RedisTemplate redisTemplate;

    public void addReading(String articleId) {
        String key = CACHE_ARTICLE_KEY + articleId;
        Long number = redisTemplate.opsForValue().increment(key);
        log.info("文章编号:{}, 阅读量:{}", articleId, number);
    }


    public Integer getReading(String articleId) {
        String key = CACHE_ARTICLE_KEY + articleId;
        Object obj = redisTemplate.opsForValue().get(key);
        log.info("文章编号:{}, 阅读量:{}", articleId, obj == null ? 0 : obj);
        return (Integer) obj;
    }
}

```



```java
import com.dongguo.redis.service.ArticleService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.annotation.Resource;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/article")
@Tag(
        name = "ArticleController",
        description = "文章控制器接口")
public class ArticleController {

    @Resource
    private ArticleService articleService;

    @Operation(
            summary = "需求1.0:增加阅读量",
            description = "用户阅读文章贡献一个阅读量"
    )
    @PostMapping("/addReading/{articleId}")
    public void addReading(@PathVariable(value = "articleId") String articleId) {
        articleService.addReading(articleId);
    }

    @Operation(
            summary = "获取阅读量",
            description = "获取阅读量"
    )
    @PostMapping("/getReading/{articleId}")
    public Integer getReading(@PathVariable(value = "articleId") String articleId) {
        return articleService.getReading(articleId);
    }
}

```



## 同篇文章一个微信号只能贡献一个阅读量

这时候产品经理告诉你，之前需求有问题，一个微信号可以无限制的增加文章的阅读量，要求进行修改。

分析：一篇文章一个微信号只能增加一次阅读量，使用set保存该文章贡献阅读量的微信号id，如果未阅读过该篇文章，就增加一次阅读量

ArticleService：

```java
    public void addReadingOnlyOnce(String articleId, String weChatId) {
        String key = CACHE_ARTICLE_KEY + articleId;
        String weChatKey = CACHE_WECHAT_KEY + articleId + ":" + weChatId;
        Boolean member = redisTemplate.opsForSet().isMember(weChatKey, weChatId);
        if (Boolean.FALSE.equals(member)) {
            Long number = redisTemplate.opsForValue().increment(key);
            log.info("文章编号:{}, 阅读量:{}", articleId, number);
            redisTemplate.opsForSet().add(weChatKey, weChatId);
        }
    }
```

ArticleController：

```java
    @Operation(
            summary = "需求2.0:增加阅读量",
            description = "同篇文章一个微信号只能贡献一个阅读量"
    )
    @PostMapping("/addReadingOnlyOnce")
    public void addReadingOnlyOnce(@RequestParam(value = "articleId") String articleId, @RequestParam(value = "weChatId") String weChatId) {
        articleService.addReadingOnlyOnce(articleId, weChatId);
    }
```



## 同篇文章一个微信号每天只能贡献一次阅读量

不久后产品经理又改需求，一个微信号可以无限制的增加文章的阅读量，那文章的阅读量太少了，要求进行修改。

改成同篇文章一个微信号每天只能贡献一次阅读量，隔天可以再贡献一次阅读量。

分析：使用set保存该文章贡献阅读量的微信号id，并设置过期时间为隔天零点。当天未阅读过该篇文章，就增加一次阅读量

ArticleService：

```java
    public void addReadingOnlyOnceOfDay(String articleId, String weChatId) {
        String key = CACHE_ARTICLE_KEY + articleId;
        String weChatKey = CACHE_WECHAT_KEY + articleId + ":" +  weChatId;
        Boolean hasKey = redisTemplate.hasKey(weChatKey);
        Boolean member = redisTemplate.opsForSet().isMember(weChatKey, weChatId);
        if (Boolean.FALSE.equals(member)) {
            Long number = redisTemplate.opsForValue().increment(key);
            log.info("文章编号:{}, 阅读量:{}", articleId, number);
            redisTemplate.opsForSet().add(weChatKey, weChatId);
            //当该key第一次赋值时设置过期时间为明天0点,可以使用定时任务
            if (Boolean.FALSE.equals(hasKey)) {
                // 获取当前日期
                Date today = new Date();
                // 获取明天的日期
                Date tomorrow = DateUtil.offsetDay(today, 1);
                // 获取明天凌晨的日期时间（0点）
                Date tomorrowMidnight = DateUtil.beginOfDay(tomorrow);
                redisTemplate.expireAt(weChatKey, tomorrowMidnight);
            }
        }
    }
```

ArticleController：

```java
    @Operation(
            summary = "需求3.0:增加阅读量",
            description = "同篇文章一个微信号每天只能贡献一次阅读量"
    )
    @PostMapping("/addReadingOnlyOnceOfDay")
    public void addReadingOnlyOnceOfDay(@RequestParam(value = "articleId") String articleId, @RequestParam(value = "weChatId") String weChatId) {
        articleService.addReadingOnlyOnceOfDay(articleId, weChatId);
    }
```

# 亿级系统中常见的四种统计

## 聚合统计

统计多个集合元素的聚合结果，  交集差集并集等集合统计

使用set

## 排序统计

抖音短视频最新评论留言的场景，设计一个展现列表，需要按照时间排序和分页展示

可以使用list。

在面对需要展示最新列表、排行榜等场景时，如果数据更新频繁或者需要分页显示，建议使用Zset，时间戳作为score

## 二值统计

集合元素的取值就只有0和1两种，在钉钉上班签到打卡的场景中，我们只用记录有签到1 没签到0   

bitmap

## 基数统计

指统计一个集合中不重复的元素个数

HyperLogLog



# 常见业务术语

## UV

Unique Visitor 独立访客，一般理解为客户端ip  需要去重

## PV

page view 页面浏览量 不用去重

## DAU

daily active user 日活跃用户量

登录或者使用了某个产品的用户数 （登录用户 去重 ）

常用于反应网站、互联网应用或者网络游戏的运营情况

## MAU

Monthly Active user 月活跃用户量



很多计数类场景，比如每日注册 IP 数、每日访问 IP 数、页面实时访问数 PV、访问用户数 UV等。

因为主要的目标是高效、巨量地进行计数，所以对存储的数据的内容并不太关心。

也就是说它只能用于统计巨量数量，不太涉及具体的统计对象的内容和精准性。

 

# 淘宝网站首页亿级UV的redis统计实战

UV： 独立访客。需要去重，一个用户一天内的多次访问只能算作一次。

游客访问先判断是否访问过，没有则增加UV。

分析：可以使用reids的hash， 但是Hash在存储大量数据时可能会消耗大量的内存空间。例如<DateKey,<ip,1>>，如果存储的是用户的IP地址，并且每个IP地址占用一定的字节，那么亿级别的UV数据将会占用非常大的内存空间。

更有效的方法可能是使用Redis提供的HyperLogLog数据结构。HyperLogLog是一种用于基数统计的算法，它可以在使用极少的内存空间的同时，给出近似但精度相对较高的统计结果。

TmallUniqueVisitorsService：

```java
import jakarta.annotation.Resource;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;
import java.util.Random;
import static com.dongguo.redis.utils.CacheKeyUtil.CACHE_TMALL_UV_KEY;

@Service
@Slf4j
public class TmallUniqueVisitorsService {
    @Resource
    private RedisTemplate redisTemplate;


    public Long getUV() {
        Long size = redisTemplate.opsForHyperLogLog().size(CACHE_TMALL_UV_KEY);
        log.info("当前UV: {}", size);
        return size;
    }

    public void addUV() {
        String key = CACHE_TMALL_UV_KEY;
        Random random = new Random();
        //每次点击，模拟200个ip访问
        for (int i = 0; i < 200; i++) {
            String randomIp = random.nextInt(255) + "." + random.nextInt(255) + "." + random.nextInt(255) + "." + random.nextInt(255);
            //PFCOUNT
            redisTemplate.opsForHyperLogLog().add(key, randomIp);
            log.info("当前访问ip: {}", randomIp);
        }
    }
}
```

TmallUniqueVisitorsController：

```java
import com.dongguo.redis.service.TmallUniqueVisitorsService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.annotation.Resource;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/tmallUV")
@Tag(
        name = "TmallUniqueVisitorsController",
        description = "天猫UV控制器接口")
public class TmallUniqueVisitorsController {

    @Resource
    private TmallUniqueVisitorsService tmallUniqueVisitorsService;
    @Operation(
            summary = "addUV",
            description = "新增UV"
    )
    @PostMapping("/addUV")
    public void addUV() {
        tmallUniqueVisitorsService.addUV();
    }

    @Operation(
            summary = "getUV",
            description = "查询UV"
    )
    @GetMapping("/getUV")
    public Long getUV() {
        return tmallUniqueVisitorsService.getUV();
    }
}
```

使用hypeloglog统计的UV存在误差。400个IP访问后获得的UV为403，800个ip访问后获得的UV为809

# 美团地图位置附近的酒店推送实战

关于地理位置的肯定是geo了。使用到GEORADIUS命令：以给定的经纬度为中心，找出某一半径内的酒店

HotelService：

```java
import jakarta.annotation.Resource;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.geo.*;
import org.springframework.data.redis.connection.RedisGeoCommands;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import static com.dongguo.redis.utils.CacheKeyUtil.CACHE_HOTEL_KEY;

@Slf4j
@Service
public class HotelService {
    @Resource
    private RedisTemplate redisTemplate;

    public String addHotel() {
        String key = CACHE_HOTEL_KEY;
        //初始化三个酒店
        Map<String, Point> map = new HashMap<>();
        map.put("我的位置", new Point(116.403669, 39.915312));
        map.put("锦江酒店", new Point(116.403963, 39.915119));
        map.put("华住酒店", new Point(116.403414, 39.924091));
        map.put("开元酒店", new Point(116.746579, 40.482509));
        redisTemplate.opsForGeo().add(key, map);
        return map.toString();
    }

    public List getGeo(String member) {
        String key = CACHE_HOTEL_KEY;
        return redisTemplate.opsForGeo().position(key, member);
    }

    public GeoResults getGeoRadius(Point point) {
        String key = CACHE_HOTEL_KEY;
        //查找半径10公里
        Distance distance = new Distance(10, Metrics.KILOMETERS);
        Circle circle = new Circle(point, distance);
        //返回50条
        RedisGeoCommands.GeoRadiusCommandArgs args = RedisGeoCommands
                .GeoRadiusCommandArgs.newGeoRadiusArgs()    //创建地理位置查询的参数构造器。
                .includeDistance()      //返回的地理位置都会附带其到圆心的距离。
                .includeCoordinates()   //返回的地理位置都会附带其具体的经纬度坐标。
                .sortAscending();   //按照距离圆心的距离进行升序排序。
        return redisTemplate.opsForGeo().radius(key, circle, args);
    }

    public GeoResults getGeoRadiusByMember(String member) {
        String key = CACHE_HOTEL_KEY;
        //返回50条
        RedisGeoCommands.GeoRadiusCommandArgs args = RedisGeoCommands
                .GeoRadiusCommandArgs.newGeoRadiusArgs()
                .includeDistance()
                .includeCoordinates()
                .sortAscending();
        //查找半径10公里
        Distance distance = new Distance(10, Metrics.KILOMETERS);
        return redisTemplate.opsForGeo().radius(key, member, distance, args);
    }
}
```

HotelController：

```java
import com.dongguo.redis.service.HotelService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.annotation.Resource;
import org.springframework.data.geo.GeoResults;
import org.springframework.data.geo.Point;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/hotel")
@Tag(
        name = "HotelController",
        description = "美团酒店控制器接口")
public class HotelController {
    @Resource
    private HotelService hotelService;

    @Operation(
            summary = "addHotel",
            description = "新增酒店"
    )
    @PostMapping("/addHotel")
    public String addHotel() {
        return hotelService.addHotel();
    }

    @Operation(
            summary = "getGeo",
            description = "根据名称获取经纬度"
    )
    @GetMapping("/getGeo/{member}")
    public List getGeo(@PathVariable(value = "member") String member) {
        return hotelService.getGeo(member);
    }

    /**
     *   {
     *     "x": 116.40366822481155,
     *     "y": 39.91531234219449
     *   }
     * @param point
     * @return
     */
    @Operation(
            summary = "getGeoRadius",
            description = "通过经纬度查找附近地点"
    )
    @PostMapping("/getGeoRadius")
    public GeoResults getGeoRadius(@RequestBody Point point) {
        return hotelService.getGeoRadius(point);
    }

    @Operation(
            summary = "getGeoRadiusByMember",
            description = "通过地址查找附近地点"
    )
    @GetMapping("/getGeoRadiusByMember/{member}")
    public GeoResults getGeoRadiusByMember(@PathVariable(value = "member") String member) {
        return hotelService.getGeoRadiusByMember(member);
    }
}
```

# 钉钉签到统计实战

统计2024-03-04到2024-03-085个工作日正常签到的员工。

分析：对于是否签到的场景可以使用bitmap



