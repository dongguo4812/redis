# 3SpringDataRedis

SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis，官网地址：https://spring.io/projects/spring-data-redis

- 提供了对不同Redis客户端的整合（Lettuce和Jedis）
- 提供了RedisTemplate统一API来操作Redis
- 支持Redis的发布订阅模型
- 支持Redis哨兵和Redis集群
- 支持基于Lettuce的响应式编程
- 支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化
- 支持基于Redis的JDKCollection实现

SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中：

![image-20240308072202506](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403080722572.png)

## pom引入SpringDataRedis的依赖

Spring Boot 与 Redis 整合包，使用默认的 Lettuce 客户端，本身就带有Lettuce的依赖

![image-20240308072848789](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403080728424.png)

所以我们可以把之前引入的lettuce依赖注释掉。

```xml
<!--        <dependency>-->
<!--            <groupId>io.lettuce</groupId>-->
<!--            <artifactId>lettuce-core</artifactId>-->
<!--        </dependency>-->
        <!--springboot与redis整合包-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
        </dependency>
```

## 业务类

### 配置类SwaggerOpenApiConfig

```java
package com.dongguo.redis.config;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Contact;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.info.License;
import org.springframework.boot.SpringBootConfiguration;
import org.springframework.context.annotation.Bean;

import java.util.HashMap;

@SpringBootConfiguration
public class SwaggerOpenApiConfig {
    /***
     * 构建Swagger3.0文档说明
     * @return 返回 OpenAPI
     */
    @Bean
    public OpenAPI customOpenAPI() {

        // 联系人信息(contact)，构建API的联系人信息，用于描述API开发者的联系信息，包括名称、URL、邮箱等
        // name：文档的发布者名称 url：文档发布者的网站地址，一般为企业网站 email：文档发布者的电子邮箱
        Contact contact = new Contact()
                .name("东郭")                             // 作者名称
                .email("dongguo@qq.com")                   // 作者邮箱
                .url("https://www.dongguo.com")  // 介绍作者的URL地址
                .extensions(new HashMap<String, Object>()); // 使用Map配置信息（如key为"name","email","url"）

        // 授权许可信息(license)，用于描述API的授权许可信息，包括名称、URL等；假设当前的授权信息为Apache 2.0的开源标准
        License license = new License()
                .name("Apache 2.0")                         // 授权名称
                .url("https://www.apache.org/licenses/LICENSE-2.0.html")    // 授权信息
                .identifier("Apache-2.0")                   // 标识授权许可
                .extensions(new HashMap<String, Object>());// 使用Map配置信息（如key为"name","url","identifier"）

        //创建Api帮助文档的描述信息、联系人信息(contact)、授权许可信息(license)
        Info info = new Info()
                .title("Swagger3.0 (Open API) 框架学习示例文档")      // Api接口文档标题（必填）
                .description("学习Swagger框架而用来定义测试的文档")     // Api接口文档描述
                .version("1.0.0")                                  // Api接口版本
                .termsOfService("https://dongguo.com/")            // Api接口的服务条款地址
                .license(license)                                  // 设置联系人信息
                .contact(contact);                                 // 授权许可信息
        // 返回信息
        return new OpenAPI()
                .openapi("3.0.1")  // Open API 3.0.1(默认)
                .info(info);       // 配置Swagger3.0描述信息
    }
}
```



# 连接单机Redis

## application.yml配置

```yaml
server:
  port: 8080
spring:
  application:
    name: redis_client
# ========================redis相关配置=====================
  data:
    redis:
      host: 192.168.122.131
      port: 6379
      password: root
# ========================logging 日志相关的配置=====================
logging:
  level:
    #系统默认，全局root配置的日志形式，可以注释掉
    root: info
    #开发人员自己设置的包结构，对那个package进行什么级别的日志监控
    com.dongguo.redis: info
  file:
    #开发人员自定义日志路径和日志名称
     name: E:/log/redis_client/redis.log
    #%d{HH:mm:ss.SSS}――日志输出时间
    #%thread――输出日志的进程名字，这在Web应用以及异步任务处理中很有用
    #%-5level――日志级别，并且使用5个字符靠左对齐
    #%logger- ――日志输出者的名字
    #%msg――日志消息
    #%n――平台的换行符
    #logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger- %msg%n
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger- %msg%n"
    file: "%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger- %msg%n"
# ========================swagger=====================
springdoc:
  swagger-ui:
    enabled: true
    path: /swagger-ui.html
```

## 测试

使用SpringDataRedis实现订单新增的功能

### service

```java
package com.dongguo.redis.service;

import jakarta.annotation.Resource;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;

import java.util.UUID;
import java.util.concurrent.ThreadLocalRandom;

import static com.dongguo.redis.utils.CacheKeyUtil.ORDER_KEY;

@Service
@Slf4j
public class OrderService {
    @Resource
    private RedisTemplate redisTemplate;

    public void addOrder() {
        Long orderId = ThreadLocalRandom.current().nextLong(1000) + 1;
        String orderNO = UUID.randomUUID().toString();
        String key = ORDER_KEY + orderId;
        String value = "订单号:" + orderNO;
        redisTemplate.opsForValue().set(key, value);
        log.info("新增订单，订单id:{}，订单No:{}", key, orderNO);
    }

    public String getOrder(Long orderId) {
        String key = ORDER_KEY + orderId;
        Object obj = redisTemplate.opsForValue().get(key);
        if (obj == null) {
            log.info("订单不存在");
        } else {
            log.info((String) obj);
        }
        return (String) obj;
    }
}
```

### controller

```java
package com.dongguo.redis.controller;

import com.dongguo.redis.service.OrderService;
import io.swagger.v3.oas.annotations.Operation;
import jakarta.annotation.Resource;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/order")
public class OrderController {
    @Resource
    private OrderService orderService;
    @Operation(
            summary = "新增订单",
            description = "新增订单"
    )
    @PostMapping("/add")
    public void addOrder(){
        orderService.addOrder();
    }
    @Operation(
            summary = "查询订单",
            description = "查询订单"
    )
    @GetMapping("/get/{orderId}")
    public String getOrder(@PathVariable(value = "orderId") Long orderId){
       return orderService.getOrder(orderId);
    }
}
```

启动项目，访问swagger：http://127.0.0.1:8080/swagger-ui/index.html

![image-20240308112227889](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403081122493.png)

### 新增订单

![image-20240308112449179](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403081124349.png)

控制台输出：新增订单，订单id:order:696，订单No:fe1e8c94-864b-40a6-bd81-3f353ee0f514

### 查询订单

![image-20240308112536400](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403081125556.png)

控制台输出：订单号:fe1e8c94-864b-40a6-bd81-3f353ee0f514

## 序列化问题

使用xshell连接redis客户端，查看新增的key，发现不存在

```shell
[root@redis ~]# redis-cli -a root
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.
127.0.0.1:6379> get order:696
(nil)
```

使用`keys *`查看所有key，发现有个key:  "\xac\xed\x00\x05t\x00\torder:696"，我明明存的是order:696，变成了\xac\xed\x00\x05t\x00\torder:696。

```shell
127.0.0.1:6379> keys *
1) "k1"
2) "list"
3) "zset"
4) "s1"
5) "\xac\xed\x00\x05t\x00\torder:696"
6) "user"
```

使用可视化工具发现key和value都变成乱码了。

![image-20240308113650579](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403081136879.png)

原来key和value都是通过Spring提供的Serializer序列化到redis的。

RedisTemplate默认使用的是JdkSerializationRedisSerializer,

RedisTemplate#afterPropertiesSet()：

![image-20240308114138558](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403081141986.png)

StringRedisTemplate默认使用的是StringRedisSerializer。

![image-20240308114239894](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403081142294.png)

其中RedisSerializer.string()就是StringRedisSerializer。

![image-20240308114320843](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403081143422.png)

使用RedisTemplate默认的JdkSerializationRedisSerializer序列化后，线上通过KEY去查询对应的VALUE非常不方便。

解决序列化问题的方法有两种：

1.使用StringRedisTemplate

2.指定RedisTemplate使用StringRedisSerializer

### 使用StringRedisTemplate

OrderService：

```java
package com.dongguo.redis.service;

import jakarta.annotation.Resource;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.stereotype.Service;

import java.util.UUID;
import java.util.concurrent.ThreadLocalRandom;

import static com.dongguo.redis.utils.CacheKeyUtil.ORDER_KEY;

@Service
@Slf4j
public class OrderService {
    @Resource
    private RedisTemplate redisTemplate;
    @Resource
    private StringRedisTemplate stringRedisTemplate;
    public void addOrder() {
        Long orderId = ThreadLocalRandom.current().nextLong(1000) + 1;
        String orderNO = UUID.randomUUID().toString();
        String key = ORDER_KEY + orderId;
        String value = "订单号:" + orderNO;
        stringRedisTemplate.opsForValue().set(key, value);
        log.info("新增订单，订单id:{}，订单No:{}", key, orderNO);
    }

    public String getOrder(Long orderId) {
        String key = ORDER_KEY + orderId;
        Object obj = stringRedisTemplate.opsForValue().get(key);
        if (obj == null) {
            log.info("订单不存在");
        } else {
            log.info((String) obj);
        }
        return (String) obj;
    }
}
```

新增订单，订单id:order:866，订单No:ca3f2279-05aa-44f3-8be7-89f750c20e33

查看redis

![image-20240308121330186](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403081213357.png)

### 指定RedisTemplate使用StringRedisSerializer

创建RedisConfig序列化的工具配置类

```java
package com.dongguo.redis.config;

import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;

import java.io.Serializable;

/**
 * redis序列化工具类
 */

@Configuration
@Slf4j
public class RedisConfig {


    /**
     * @param lettuceConnectionFactory
     * @return redis序列化的工具配置类
     * 1) "order:696"  序列化过
     * 2) "\xac\xed\x00\x05t\x00\order:696"   没有序列化过
     */
    @Bean
    public RedisTemplate<String, Serializable> redisTemplate(LettuceConnectionFactory lettuceConnectionFactory) {
        RedisTemplate<String, Serializable> redisTemplate = new RedisTemplate<>();
        redisTemplate.setConnectionFactory(lettuceConnectionFactory);
        //设置key序列化方式string
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        //设置value的序列化方式json
        redisTemplate.setValueSerializer(new GenericJackson2JsonRedisSerializer());
        redisTemplate.setHashKeySerializer(new StringRedisSerializer());
        redisTemplate.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());
        redisTemplate.afterPropertiesSet();
        return redisTemplate;
    }
}
```

OrderService：

```java
package com.dongguo.redis.service;

import jakarta.annotation.Resource;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.stereotype.Service;

import java.util.UUID;
import java.util.concurrent.ThreadLocalRandom;

import static com.dongguo.redis.utils.CacheKeyUtil.ORDER_KEY;

@Service
@Slf4j
public class OrderService {
    @Resource
    private RedisTemplate redisTemplate;
    @Resource
    private StringRedisTemplate stringRedisTemplate;
    public void addOrder() {
        Long orderId = ThreadLocalRandom.current().nextLong(1000) + 1;
        String orderNO = UUID.randomUUID().toString();
        String key = ORDER_KEY + orderId;
        String value = "订单号:" + orderNO;
        redisTemplate.opsForValue().set(key, value);
        log.info("新增订单，订单id:{}，订单No:{}", key, orderNO);
    }

    public String getOrder(Long orderId) {
        String key = ORDER_KEY + orderId;
        Object obj = redisTemplate.opsForValue().get(key);
        if (obj == null) {
            log.info("订单不存在");
        } else {
            log.info((String) obj);
        }
        return (String) obj;
    }
}

```

新增订单，订单id:order:179，订单No:ae08c68b-a770-4ef1-b595-7a52d828d39b

查看redis

![image-20240308121550627](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403081215373.png)

# 连接Redis集群

## 查看集群节点情况

```shell
192.168.122.134:7003> cluster nodes
318bf90e3c9922aadf8e72734c86a75fd1ab571d 192.168.122.133:7002@17002 master - 0 1709873834126 2 connected 6827-10922
21e92cb603e3456bb1cb49dc3ab668978ef1f22f 192.168.122.137:7006@17006 slave 318bf90e3c9922aadf8e72734c86a75fd1ab571d 0 1709873834000 2 connected
d341462815d05806cf27bdfe2627af3a05fccfc8 192.168.122.135:7004@17004 slave e49ab26e91fd5b8a726bc1e4a79cf0f6de2fd663 0 1709873833000 3 connected
e49ab26e91fd5b8a726bc1e4a79cf0f6de2fd663 192.168.122.134:7003@17003 myself,master - 0 1709873832000 3 connected 12288-16383
9c35d6afa7ba4b161864a71b1c6bad9e4d1d62ff 192.168.122.136:7005@17005 slave 19ebecba98d2e33ba184d396e630a9e6434e4196 0 1709873833577 12 connected
19ebecba98d2e33ba184d396e630a9e6434e4196 192.168.122.132:7001@17001 master - 0 1709873833074 12 connected 0-6826 10923-12287

```

## 修改application.yml

```shell
# ========================redis相关配置=====================
#  data:
#    redis:
#      host: 192.168.122.131
#      port: 6379
#      password: root
  data:
    redis:
      password: root
      cluster:
        nodes: 192.168.122.132:7001,192.168.122.133:7002,192.168.122.134:7003,192.168.122.135:7004,192.168.122.136:7005,192.168.122.137:7006
        #获取失败，最大重定向次数
        max-redirects: 3
```

重新启动项目，新增订单，访问集群：

新增订单，订单id:order:937，订单No:753f1dc5-d9ad-484e-9ca9-14ef528f1829

连接7001客户端，读取order:937

```shell
[root@redis-7001 ~]# redis-cli -a root -p 7001 -c --raw
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.
127.0.0.1:7001> get order:937
-> Redirected to slot [8479] located at 192.168.122.133:7002
"订单号:753f1dc5-d9ad-484e-9ca9-14ef528f1829"
192.168.122.133:7002> 
```

## 问题：master节点宕机，故障迁移slave变成master，程序是否能够正常运行

### 1.master7001宕机

```shell
127.0.0.1:7001> shutdown
not connected> quit
```

### 2.等待slave7005变成master7005

7005已经变成master了。

```shell
[root@sentinel2 myredis]# redis-cli -a root -p 7005 -c
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.
127.0.0.1:7005> cluster nodes
9c35d6afa7ba4b161864a71b1c6bad9e4d1d62ff 192.168.122.136:7005@17005 myself,master - 0 1709877535000 13 connected 0-6826 10923-12287
e49ab26e91fd5b8a726bc1e4a79cf0f6de2fd663 192.168.122.134:7003@17003 master - 0 1709877535000 3 connected 12288-16383
318bf90e3c9922aadf8e72734c86a75fd1ab571d 192.168.122.133:7002@17002 master - 0 1709877536000 2 connected 6827-10922
d341462815d05806cf27bdfe2627af3a05fccfc8 192.168.122.135:7004@17004 slave e49ab26e91fd5b8a726bc1e4a79cf0f6de2fd663 0 1709877537259 3 connected
19ebecba98d2e33ba184d396e630a9e6434e4196 192.168.122.132:7001@17001 master,fail - 1709877376272 1709877374000 12 disconnected
21e92cb603e3456bb1cb49dc3ab668978ef1f22f 192.168.122.137:7006@17006 slave 318bf90e3c9922aadf8e72734c86a75fd1ab571d 0 1709877536247 2 connected
```

并且集群还是能够正常读写

```
127.0.0.1:7005> set k1 v1
-> Redirected to slot [12706] located at 192.168.122.134:7003
OK
192.168.122.134:7003> set k2 v2
-> Redirected to slot [449] located at 192.168.122.136:7005
OK
192.168.122.136:7005> set k3 v3
OK
192.168.122.136:7005> get k1
-> Redirected to slot [12706] located at 192.168.122.134:7003
"v1"
192.168.122.134:7003> get k2
-> Redirected to slot [449] located at 192.168.122.136:7005
"v2"
192.168.122.136:7005> get k3
"v3"
```

### 3.查看项目运行情况

此时控制台疯狂的刷Connection refused: no further information: /192.168.122.132:7001

```xml
2024-03-08 14:55:34.593 [lettuce-nioEventLoop-4-16] WARN  io.lettuce.core.protocol.ConnectionWatchdog- Cannot reconnect to [192.168.122.132/<unresolved>:7001]: Connection refused: no further information: /192.168.122.132:7001
2024-03-08 14:55:52.858 [lettuce-nioEventLoop-4-1] WARN  io.lettuce.core.cluster.topology.DefaultClusterTopologyRefresh- Unable to connect to [192.168.122.132/<unresolved>:7001]: Connection refused: no further information: /192.168.122.132:7001
```



新增订单，程序报错：Connection refused: no further information

```java
java.net.ConnectException: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.SocketChannelImpl.finishConnect(SocketChannelImpl.java:946)
	at io.netty.channel.socket.nio.NioSocketChannel.doFinishConnect(NioSocketChannel.java:337)
	at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.finishConnect(AbstractNioChannel.java:335)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:776)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.base/java.lang.Thread.run(Thread.java:833)
```

重新新增订单成功，新增订单，订单id:order:591，订单No:7da371da-d677-48a7-a46e-93d0dc5b4fbe

再次重试又程序报错

```java
java.net.ConnectException: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.SocketChannelImpl.finishConnect(SocketChannelImpl.java:946)
	at io.netty.channel.socket.nio.NioSocketChannel.doFinishConnect(NioSocketChannel.java:337)
	at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.finishConnect(AbstractNioChannel.java:335)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:776)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.base/java.lang.Thread.run(Thread.java:833)
```

redis集群故障后经过故障转移，集群恢复正常，但是java端调用还是出现异常。

对此请求发现，key落到mater7002、master7003的槽位上时请求可以正常执行，落到为master7005分配的槽位时请求报错。



redis集群从3主3从变为了3主2从，但是java端并没有接收到集群架构的变化。即SpringBoot客户端没有动态感知道RedisCluster的最新集群信息。

## 问题

在 Spring Boot 2.X 版本以后，默认使用 Lettuce 作为 Redis 的连接池，当 Redis 集群的节点发生变化（例如添加或删除了节点），Lettuce 默认不会自动刷新节点拓扑。这可能导致应用无法正确连接到新的节点或无法正确处理已删除的节点。



## 解决方案

### 1.使用其他连接池

可以考虑使用其他 Redis 连接池，如 Jedis。Jedis 在处理集群节点变化时可能有不同的行为或提供更多的配置选项。这里需要根据你的具体需求和应用的特性来选择最合适的解决方案。

### 2.重写连接工厂，定时刷新节点信息

可在RedisConfig添加以下代码

```java
    @Bean
    public DefaultClientResources lettuceClientResources() {
        return DefaultClientResources.create();
    }
    /**
     *定时扫描Redis集群的拓扑变化，自动更新本地的节点信息。
     * @return
     */
    @Bean
    public LettuceConnectionFactory lettuceConnectionFactory(RedisProperties redisProperties, ClientResources clientResources) {
        ClusterTopologyRefreshOptions topologyRefreshOptions = ClusterTopologyRefreshOptions.builder()
                .enablePeriodicRefresh(Duration.ofSeconds(30))//按照周期刷新拓扑
                .enableAllAdaptiveRefreshTriggers()//当满足特定条件时，自动触发拓扑刷新，比如某个连接失败等
                .build();
        ClusterClientOptions clusterClientOptions = ClusterClientOptions.builder()
                //redis命令超时时间，超时后才会使用新的拓扑信息重新建立连接
                .timeoutOptions(TimeoutOptions.enabled(Duration.ofSeconds(10)))
                .topologyRefreshOptions(topologyRefreshOptions)
                .build();
        LettuceClientConfiguration clientConfiguration = LettuceClientConfiguration.builder()
                .clientResources(clientResources)
                .clientOptions(clusterClientOptions)
                .build();
        RedisClusterConfiguration clusterConfig = new RedisClusterConfiguration(redisProperties.getCluster().getNodes());
        clusterConfig.setMaxRedirects(redisProperties.getCluster().getMaxRedirects());
        clusterConfig.setPassword(RedisPassword.of(redisProperties.getPassword()));

        return new LettuceConnectionFactory(clusterConfig, clientConfiguration);
    }
```

### 3.刷新节点集群拓扑动态感应

yml中添加以下代码lettuce部分

```yaml
  data:
    redis:
      password: root
      cluster:
        nodes: 192.168.122.132:7001,192.168.122.133:7002,192.168.122.134:7003,192.168.122.135:7004,192.168.122.136:7005,192.168.122.137:7006
        #获取失败，最大重定向次数
        max-redirects: 3
      lettuce:
        cluster:
          refresh:
            #支持集群拓扑动态感应刷新，自适应拓扑刷新是否使用所有可用的更新，默认false关闭
            adaptive: true
            #定时刷新时间
            period: 2000
```



推荐使用3.刷新节点集群拓扑动态感应









