传统的缓存策略一般是请求到达Tomcat后，先查询Redis，如果未命中则查询数据库，如图：

![image-20240325113440687](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403261628797.png)

存在下面的问题：

•请求要经过Tomcat处理，Tomcat的性能成为整个系统的瓶颈

•Redis缓存失效时（过期），会对数据库产生冲击

# 多级缓存方案



缓存在日常开发中启动至关重要的作用，由于是存储在内存中，数据的读取速度是非常快的，能大量减少对数据库的访问，减少数据库的压力。我们把缓存分为两类：

- 分布式缓存，例如Redis：

- - 优点：存储容量更大、可靠性更好、可以在集群间共享
  - 缺点：访问缓存有网络开销
  - 场景：缓存数据量较大、可靠性要求较高、需要在集群间共享

- 进程本地缓存，例如HashMap、GuavaCache：

- - 优点：读取本地内存，没有网络开销，速度更快
  - 缺点：存储容量有限、可靠性较低、无法共享
  - 场景：性能要求较高，缓存数据量较小





多级缓存就是充分利用请求处理的每个环节，分别添加缓存，减轻Tomcat压力，提升服务性能

- 浏览器访问静态资源时，优先读取浏览器本地缓存
- 访问非静态资源（ajax查询数据）时，访问服务端
- 请求到达Nginx后，优先读取Nginx本地缓存
- 如果Nginx本地缓存未命中，则去直接查询Redis（不经过Tomcat）
- 如果Redis查询未命中，则查询Tomcat
- 请求进入Tomcat后，优先查询JVM进程缓存
- 如果JVM进程缓存未命中，则查询数据库



在多级缓存架构中，Nginx内部需要编写本地缓存查询、Redis查询、Tomcat查询的业务逻辑，因此这样的nginx服务不再是一个**反向代理服务器**，而是一个编写**业务的Web服务器了**。

因此这样的业务Nginx服务也需要搭建集群来提高并发，再有专门的nginx服务来做反向代理，如图：

![image-20240325133627120](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403261625278.png)

另外，我们的Tomcat服务将来也会部署为集群模式：

![image-20240325133955148](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403261625491.png)

# 数据准备

## 导入SQL

```sql
SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for tb_item
-- ----------------------------
DROP TABLE IF EXISTS `tb_item`;
CREATE TABLE `tb_item`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '商品id',
  `title` varchar(264) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '商品标题',
  `name` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '' COMMENT '商品名称',
  `price` bigint(20) NOT NULL COMMENT '价格（分）',
  `image` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '商品图片',
  `category` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '类目名称',
  `brand` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '品牌名称',
  `spec` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '规格',
  `status` int(1) NULL DEFAULT 1 COMMENT '商品状态 1-正常，2-下架，3-删除',
  `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `status`(`status`) USING BTREE,
  INDEX `updated`(`update_time`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 50002 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '商品表' ROW_FORMAT = COMPACT;

-- ----------------------------
-- Records of tb_item
-- ----------------------------
INSERT INTO `tb_item` VALUES (10001, 'RIMOWA 21寸托运箱拉杆箱 SALSA AIR系列果绿色 820.70.36.4', 'SALSA AIR', 16900, 'https://m.360buyimg.com/mobilecms/s720x720_jfs/t6934/364/1195375010/84676/e9f2c55f/597ece38N0ddcbc77.jpg!q70.jpg.webp', '拉杆箱', 'RIMOWA', '{\"颜色\": \"红色\", \"尺码\": \"26寸\"}', 1, '2019-05-01 00:00:00', '2019-05-01 00:00:00');
INSERT INTO `tb_item` VALUES (10002, '安佳脱脂牛奶 新西兰进口轻欣脱脂250ml*24整箱装*2', '脱脂牛奶', 68600, 'https://m.360buyimg.com/mobilecms/s720x720_jfs/t25552/261/1180671662/383855/33da8faa/5b8cf792Neda8550c.jpg!q70.jpg.webp', '牛奶', '安佳', '{\"数量\": 24}', 1, '2019-05-01 00:00:00', '2019-05-01 00:00:00');
INSERT INTO `tb_item` VALUES (10003, '唐狮新品牛仔裤女学生韩版宽松裤子 A款/中牛仔蓝（无绒款） 26', '韩版牛仔裤', 84600, 'https://m.360buyimg.com/mobilecms/s720x720_jfs/t26989/116/124520860/644643/173643ea/5b860864N6bfd95db.jpg!q70.jpg.webp', '牛仔裤', '唐狮', '{\"颜色\": \"蓝色\", \"尺码\": \"26\"}', 1, '2019-05-01 00:00:00', '2019-05-01 00:00:00');
INSERT INTO `tb_item` VALUES (10004, '森马(senma)休闲鞋女2019春季新款韩版系带板鞋学生百搭平底女鞋 黄色 36', '休闲板鞋', 10400, 'https://m.360buyimg.com/mobilecms/s720x720_jfs/t1/29976/8/2947/65074/5c22dad6Ef54f0505/0b5fe8c5d9bf6c47.jpg!q70.jpg.webp', '休闲鞋', '森马', '{\"颜色\": \"白色\", \"尺码\": \"36\"}', 1, '2019-05-01 00:00:00', '2019-05-01 00:00:00');
INSERT INTO `tb_item` VALUES (10005, '花王（Merries）拉拉裤 M58片 中号尿不湿（6-11kg）（日本原装进口）', '拉拉裤', 38900, 'https://m.360buyimg.com/mobilecms/s720x720_jfs/t24370/119/1282321183/267273/b4be9a80/5b595759N7d92f931.jpg!q70.jpg.webp', '拉拉裤', '花王', '{\"型号\": \"XL\"}', 1, '2019-05-01 00:00:00', '2019-05-01 00:00:00');

-- ----------------------------
-- Table structure for tb_item_stock
-- ----------------------------
DROP TABLE IF EXISTS `tb_item_stock`;
CREATE TABLE `tb_item_stock`  (
  `item_id` bigint(20) NOT NULL COMMENT '商品id，关联tb_item表',
  `stock` int(10) NOT NULL DEFAULT 9999 COMMENT '商品库存',
  `sold` int(10) NOT NULL DEFAULT 0 COMMENT '商品销量',
  PRIMARY KEY (`item_id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = COMPACT;

-- ----------------------------
-- Records of tb_item_stock
-- ----------------------------
INSERT INTO `tb_item_stock` VALUES (10001, 99996, 3219);
INSERT INTO `tb_item_stock` VALUES (10002, 99999, 54981);
INSERT INTO `tb_item_stock` VALUES (10003, 99999, 189);
INSERT INTO `tb_item_stock` VALUES (10004, 99999, 974);
INSERT INTO `tb_item_stock` VALUES (10005, 99999, 18649);

SET FOREIGN_KEY_CHECKS = 1;
```

其中包含两张表：

- tb_item：商品表，包含商品的基本信息
- tb_item_stock：商品库存表，包含商品的库存信息

之所以将库存分离出来，是因为库存是更新比较频繁的信息，写操作较多。而其他信息修改的频率非常低。

## 创建项目

redis_item，实现商品的增删改查

### application.yml配置

```java
server:
  port: 8081
spring:
  application:
    name: item
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://127.0.0.1:3306/redis?useSSL=false&serverTimezone=UTC
    username: root
    password: root
  data:
    redis:
      host: 192.168.122.131
      port: 6379
      password: root
      lettuce:
        pool:
          max-active: 10
          max-idle: 10
          min-idle: 1
          time-between-eviction-runs: 10s
  jackson:
    default-property-inclusion: non_null # JSON处理时忽略非空字段

mybatis-plus:
  type-aliases-package: com.dongguo.redis.entity # 别名扫描包
logging:
  level:
    com.dongguo.redis: debug
# ========================swagger=====================
springdoc:
  swagger-ui:
    enabled: true
    path: /swagger-ui.html


```

### 启动类

```java
@SpringBootApplication
@MapperScan("com.dongguo.redis.mapper")
public class RedisItemApplication {

    public static void main(String[] args) {
        SpringApplication.run(RedisItemApplication.class, args);
    }

}
```

### 业务类

ItemServiceImpl

```java
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.dongguo.redis.entity.Item;
import com.dongguo.redis.entity.ItemStock;
import com.dongguo.redis.entity.PageDTO;
import com.dongguo.redis.mapper.ItemMapper;
import com.dongguo.redis.service.IItemService;
import com.dongguo.redis.service.IItemStockService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

@Service
public class ItemServiceImpl extends ServiceImpl<ItemMapper, Item> implements IItemService {
    @Autowired
    private IItemStockService stockService;

    @Override
    public PageDTO queryItemPage(Integer page, Integer size) {
        // 分页查询商品
        Page<Item> result = lambdaQuery()
                .ne(Item::getStatus, 3)
                .page(new Page<>(page, size));

        // 查询库存
        List<Item> list = result.getRecords().stream().peek(item -> {
            ItemStock stock = stockService.getById(item.getId());
            item.setStock(stock.getStock());
            item.setSold(stock.getSold());
        }).collect(Collectors.toList());

        // 封装返回
        return new PageDTO(result.getTotal(), list);
    }

    @Override
    @Transactional
    public void saveItem(Item item) {
        // 新增商品
        save(item);
        // 新增库存
        ItemStock stock = new ItemStock();
        stock.setId(item.getId());
        stock.setStock(item.getStock());
        stockService.save(stock);
    }

    @Override
    public void deleteById(Long id) {
        lambdaUpdate()
                .set(Item::getStatus, 3)
                .eq(Item::getId, id)
                .update();
    }
}
```

ItemController：

```java
import com.dongguo.redis.entity.Item;
import com.dongguo.redis.entity.ItemStock;
import com.dongguo.redis.entity.PageDTO;
import com.dongguo.redis.service.IItemService;
import com.dongguo.redis.service.IItemStockService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("item")
@Tag(
        name = "ItemController",
        description = "商品控制器接口")
public class ItemController {

    @Autowired
    private IItemService itemService;
    @Autowired
    private IItemStockService stockService;

    @GetMapping("list")
    @Operation(
            summary = "queryItemPage",
            description = "分页列表"
    )
    public PageDTO queryItemPage(
            @RequestParam(value = "page", defaultValue = "1") Integer page,
            @RequestParam(value = "size", defaultValue = "5") Integer size) {
        return itemService.queryItemPage(page, size);
    }

    @PostMapping
    @Operation(
            summary = "saveItem",
            description = "新增商品"
    )
    public void saveItem(@RequestBody Item item) {
        itemService.saveItem(item);
    }

    @PutMapping
    @Operation(
            summary = "updateItem",
            description = "更新商品"
    )
    public void updateItem(@RequestBody Item item) {
        itemService.updateById(item);
    }

    @PutMapping("stock")
    @Operation(
            summary = "updateStock",
            description = "更新库存"
    )
    public void updateStock(@RequestBody ItemStock itemStock) {
        stockService.updateById(itemStock);
    }

    @DeleteMapping("/{id}")
    @PutMapping("stock")
    @Operation(
            summary = "deleteById",
            description = "删除商品"
    )
    public void deleteById(@PathVariable("id") Long id) {
        itemService.deleteById(id);
    }
}

```

## 静态资源

将html文件夹下的静态资源拷贝到linux的nginx\html文件夹下

启动nginx，访问http://localhost/item.html

![image-20240325164213615](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403261626060.png)

## 反向代理

现在，页面是假数据展示的。我们需要向服务器发送ajax请求，查询商品数据。

nginx.conf文件配置nginx反向代理

```shell
http {
    include       mime.types;
    default_type  application/octet-stream;

    sendfile        on;
    #tcp_nopush     on;
    keepalive_timeout  65;

    upstream nginx-cluster{
        server 192.168.1.3:8081;
        server 192.168.1.3:8082;
    }
    server {
        listen       80;
        server_name  localhost;

		location /api {
            proxy_pass http://nginx-cluster;
        }

        location / {
            root   html;
            index  index.html index.htm;
        }

        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
    }
}

```



# Caffeine实现JVM进程缓存

**Caffeine**是一个基于Java8开发的，提供了近乎最佳命中率的高性能的本地缓存库。目前Spring内部的缓存使用的就是Caffeine。GitHub地址：https://github.com/ben-manes/caffeine

Caffeine的性能非常好，下图是官方给出的性能对比：

![image-20240325164852913](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403261626037.png)

Caffeine既然是缓存的一种，肯定需要有缓存的清除策略，不然的话内存总会有耗尽的时候。

Caffeine提供了三种缓存驱逐策略：

- 基于容量：设置缓存的数量上限

```java
// 创建缓存对象
Cache<String, String> cache = Caffeine.newBuilder()
    .maximumSize(1) // 设置缓存大小上限为 1
    .build();
```

- 基于时间：设置缓存的有效时间

```java
// 创建缓存对象
Cache<String, String> cache = Caffeine.newBuilder()
    // 设置缓存有效期为 10 秒，从最后一次写入开始计时 
    .expireAfterWrite(Duration.ofSeconds(10)) 
    .build();
```

- 基于引用：设置缓存为软引用或弱引用

  利用GC来回收缓存数据。性能较差，不建议使用。

## 需求

利用Caffeine实现下列需求：

- 给根据id查询商品的业务添加缓存，缓存未命中时查询数据库
- 给根据id查询商品库存的业务添加缓存，缓存未命中时查询数据库
- 缓存初始大小为100
- 缓存上限为10000

## 实现

首先，我们需要定义两个Caffeine的缓存对象，分别保存商品、库存的缓存数据。



```java

import com.dongguo.redis.entity.Item;
import com.dongguo.redis.entity.ItemStock;
import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class CaffeineConfig {

    @Bean
    public Cache<Long, Item> itemCache() {
        return Caffeine.newBuilder()
                .initialCapacity(100)
                .maximumSize(10_000)
                .build();
    }

    @Bean
    public Cache<Long, ItemStock> stockCache() {
        return Caffeine.newBuilder()
                .initialCapacity(100)
                .maximumSize(10_000)
                .build();
    }
}
```

ItemController添加缓存逻辑

```java
    @Autowired
    private Cache<Long, Item> itemCache;
    @Autowired
    private Cache<Long, ItemStock> stockCache;

    @GetMapping("/{id}")
    @Operation(
            summary = "findById",
            description = "查询商品"
    )
    public Item findById(@PathVariable("id") Long id) {
        return itemCache.get(id, key -> itemService.lambdaQuery()
                .ne(Item::getStatus, 3)
                .eq(Item::getId, key)
                .one()
        );
    }

    @GetMapping("/stock/{id}")
    @Operation(
            summary = "findStockById",
            description = "查询商品库存"
    )
    public ItemStock findStockById(@PathVariable("id") Long id) {
        return stockCache.get(id, key -> stockService.getById(key));
    }
```



# Nginx+Redis多级缓存方案

## 安装OpenResty

OpenResty® 是一个基于 Nginx的高性能 Web 平台，用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。具备下列特点：

- 具备Nginx的完整功能
- 基于Lua语言进行扩展，集成了大量精良的 Lua 库、第三方模块
- 允许使用Lua

官方网站： https://openresty.org/cn/

![image-20240325201829481](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403261626698.png)

首先你的Linux虚拟机必须联网

### 1）安装开发库

首先要安装OpenResty的依赖开发库，执行命令：

```shell
yum install -y pcre-devel openssl-devel gcc --skip-broken
```

### 2）安装OpenResty仓库

添加 openresty 仓库，这样就可以便于未来安装或更新我们的软件包（通过 yum check-update 命令）。运行下面的命令就可以添加我们的仓库：

```shell
yum-config-manager --add-repo https://openresty.org/package/centos/openresty.repo
```

如果提示说命令不存在，则运行：

```shell
yum install -y yum-utils 
```

然后再重复上面的命令

### 3）安装OpenResty

```shell
yum install -y openresty
```

### 4）安装opm工具

opm是OpenResty的一个管理工具，可以帮助我们安装一个第三方的Lua模块。

```shell
yum install -y openresty-opm
```

### 5）目录结构

默认情况下，OpenResty安装的目录是：/usr/local/openresty

![image-20240326073325578](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403261626998.png)

### 6）配置nginx的环境变量

以后我们就可以将openresty作为之前nginx来使用，所以要修改下openresty中nginx的配置

打开配置文件：

```shell
vi /etc/profile
```

在最下面加入两行：

```shell
export NGINX_HOME=/usr/local/openresty/nginx
export PATH=${NGINX_HOME}/sbin:$PATH
```

NGINX_HOME：是OpenResty安装目录下的nginx的目录

然后让配置生效：

```shell
source /etc/profile
```

## 启动openresty

OpenResty底层是基于Nginx的，查看OpenResty目录的nginx目录，结构与windows中安装的nginx基本一致：

![image-20240326090629164](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403261626261.png)

所以运行方式与nginx基本一致：

```shell
# 启动nginx
nginx
# 重新加载配置
nginx -s reload
# 停止
nginx -s stop
```



nginx的默认配置文件注释太多，之后会有很多在nginx.conf中的配置，这里将nginx.conf中的注释部分删除，保留有效部分。

修改/usr/local/openresty/nginx/conf/nginx.conf文件，内容如下：

```shell
#user  nobody;
worker_processes  1;
error_log  logs/error.log;

events {
    worker_connections  1024;
}

http {
    include       mime.types;
    default_type  application/octet-stream;
    sendfile        on;
    keepalive_timeout  65;

    server {
        listen       8081;
        server_name  localhost;
        location / {
            root   html;
            index  index.html index.htm;
        }
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
    }
}
```

前面已经配置openresty中nginx的环境变量，任意目录输入命令以启动nginx：

```shell
[root@redis local]# nginx
[root@redis local]# ps -ef|grep nginx
root      21982      1  0 09:16 ?        00:00:00 nginx: master process nginx
nobody    21983  21982  0 09:16 ?        00:00:00 nginx: worker process
root      21985   5923  0 09:17 pts/1    00:00:00 grep --color=auto nginx

```

然后访问页面：[http://192.168.122.131:8081](http://192.168.122.131:8081)，注意ip地址替换为你自己的虚拟机IP，以及防火墙放开端口

```shell
firewall-cmd --permanent --add-port=8081/tcp
firewall-cmd --reload
```



![image-20240326092821702](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403261626803.png)

修改之前启动的80端口的nginx配置nginx-cluster映射的地址

```shell

#user  nobody;
worker_processes  1;

events {
    worker_connections  1024;
}

http {
    include       mime.types;
    default_type  application/octet-stream;

    sendfile        on;
    keepalive_timeout  65;

    upstream nginx-cluster{
        server 192.168.122.131:8081;
    }
    server {
        listen       80;
        server_name  localhost;

        location / {
            root   html;
            index  index.html index.htm;
        }
        location /api {
            proxy_pass http://nginx-cluster;
        }
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
    }
}

```



![image-20240326110332159](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403261626730.png)

这样原本请求项目接口先被80端口的nginx拦截，反向代理到nginx-cluster集群，这个nginx-cluster就是我们openresty搭建的nginx集群



![image-20240326094138033](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403261626746.png)

![image-20240326163125831](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403261631658.png)

## OpenResty监听请求

OpenResty的很多功能都依赖于其目录下的Lua库，需要在nginx.conf中指定依赖库的目录，并导入依赖：

### 1）添加对OpenResty的Lua模块的加载

修改/usr/local/openresty/nginx/conf/nginx.conf文件，在其中的http下面，添加下面代码：

```shell
#lua 模块
lua_package_path "/usr/local/openresty/lualib/?.lua;;";
#c模块     
lua_package_cpath "/usr/local/openresty/lualib/?.so;;";  
```

### 2）监听/api/item路径

修改/usr/local/openresty/nginx/conf/nginx.conf文件，在nginx.conf的server下面，添加对/api/item这个路径的监听：

```shell
location  /api/item {
    # 默认的响应类型
    default_type application/json;
    # 响应结果由lua/item.lua文件来决定
    content_by_lua_file lua/item.lua;
}
```

这个监听，就类似于SpringMVC中的@GetMapping("/api/item")做路径映射。

而content_by_lua_file lua/item.lua则相当于调用item.lua这个文件，执行其中的业务，把结果返回给用户。相当于java中调用service。

```shell
#user  nobody;
worker_processes  1;
error_log  logs/error.log;

events {
    worker_connections  1024;
}

http {
    include       mime.types;
    default_type  application/octet-stream;
    sendfile        on;
    keepalive_timeout  65;
    #lua 模块
    lua_package_path "/usr/local/openresty/lualib/?.lua;;";
    #c模块     
    lua_package_cpath "/usr/local/openresty/lualib/?.so;;";  	
    server {
        listen       8081;
        server_name  localhost;
        location / {
            root   html;
            index  index.html index.htm;
        }
        location  /api/item {
            # 默认的响应类型
            default_type application/json;
            # 响应结果由lua/item.lua文件来决定
            content_by_lua_file lua/item.lua;
        }       
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
    }
}
```

### 3）编写item.lua

在/usr/loca/openresty/nginx目录创建文件夹：lua

![image-20240326095856646](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403261631671.png)

在/usr/loca/openresty/nginx/lua文件夹下，新建文件：item.lua

![image-20240326095901720](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403261631796.png)

编写item.lua，这里先返回假数据

item.lua中，利用ngx.say()函数返回数据到Response中，为做区别可以修改title确认是否成功

```lua
ngx.say('{"id":10001,"name":"SALSA AIR","title":"特价 21寸托运箱拉杆箱 SALSA AIR系列果绿色 820","price":17900,"image":"https://m.360buyimg.com/mobilecms/s720x720_jfs/t6934/364/1195375010/84676/e9f2c55f/597ece38N0ddcbc77.jpg!q70.jpg.webp","category":"拉杆箱","brand":"RIMOWA","spec":"","status":1,"createTime":"2019-04-30T16:00:00.000+00:00","updateTime":"2019-04-30T16:00:00.000+00:00","stock":2999,"sold":31290}')
```

重新加载配置

```shell
nginx -s reload
```

刷新商品页面：http://192.168.122.131/item.html?id=1001，即可看到效果：

![](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403261631702.png)

## 请求参数处理

要返回真实数据，必须根据前端传递来的商品id，查询商品信息才可以。

那么如何获取前端传递的商品参数呢？

OpenResty中提供了一些API用来获取不同类型的前端请求参数：

![image-20240326100836877](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403261631914.png)

### 获取参数并返回

在前端发起的ajax请求如图：

![image-20240326100947394](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403261631281.png)

可以看到商品id是以路径占位符方式传递的，因此可以利用正则表达式匹配的方式来获取ID

1）获取商品id

修改/usr/loca/openresty/nginx/nginx.conf文件中监听/api/item的代码，利用正则表达式获取ID：

```shell
location ~ /api/item/(\d+) {
    # 默认的响应类型
    default_type application/json;
    # 响应结果由lua/item.lua文件来决定
    content_by_lua_file lua/item.lua;
}
```

2）拼接ID并返回

修改/usr/loca/openresty/nginx/lua/item.lua文件，获取id并拼接到结果中返回：

```lua
-- 获取商品id
local id = ngx.var[1]
-- 拼接并返回
ngx.say('{"id":' .. id .. ',"name":"SALSA AIR","title":"特价 21寸托运箱拉杆箱 SALSA AIR系列果绿色 820","price":17900,"image":"https://m.360buyimg.com/mobilecms/s720x720_jfs/t6934/364/1195375010/84676/e9f2c55f/597ece38N0ddcbc77.jpg!q70.jpg.webp","category":"拉杆箱","brand":"RIMOWA","spec":"","status":1,"createTime":"2019-04-30T16:00:00.000+00:00","updateTime":"2019-04-30T16:00:00.000+00:00","stock":2999,"sold":31290}')
```

3）重新加载并测试

运行命令以重新加载OpenResty配置：

```
nginx -s reload
```

刷新页面可以看到结果中已经带上了ID：

![image-20240326101641037](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403261631943.png)

## 查询Tomcat

拿到商品ID后，本应去缓存中查询商品信息，不过目前我们还未建立nginx、redis缓存。因此，这里我们先根据商品id去tomcat查询商品信息。我们实现如图部分：

![image-20240326163321158](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403261633434.png)

需要注意的是，我们的OpenResty是在虚拟机，Tomcat是在Windows电脑上。两者IP一定不要搞错了。

### 发送http请求的API

nginx提供了内部API用以发送http请求：

```lua
local resp = ngx.location.capture("/path",{
    method = ngx.HTTP_GET,   -- 请求方式
    args = {a=1,b=2},  -- get方式传参数
    --body = 'c=3&d=4'  -- post方式传参数  二选一
})
```

- `local resp`：定义了一个局部变量`resp`来存储`ngx.location.capture`的返回结果。
- `ngx.location.capture("/path", {...})`：调用`ngx.location.capture` API，并向`/path`这个location发起一个HTTP请求。
- `method = ngx.HTTP_GET`：设置请求方式为GET。
- `args = {a=1,b=2}`：设置一个表格，其中包含了GET请求的参数。这些参数会自动被转换成查询字符串并附加到请求的URL后面。
- `body = 'c=3&d=4'`：这是注释掉的代码，如果你需要发起一个POST请求，你可以取消注释这行代码，并设置`method`为`ngx.HTTP_POST`。这个字符串会作为POST请求的请求体发送。



返回的响应内容包括：

- resp.status：响应状态码
- resp.header：响应头，是一个table
- resp.body：响应体，就是响应数据

注意：这里的path是路径，并不包含IP和端口。这个请求会被nginx内部的server监听并处理。

但是我们希望这个请求发送到Tomcat服务器，所以还需要编写一个server来对这个路径做反向代理



```lua
location /path {
     # 这里是windows电脑的ip和Java服务端口，需要确保windows防火墙处于关闭状态
     proxy_pass http://192.168.1.3:8081; 
 }
```

原理如图：

![image-20240326163633430](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403261636591.png)

1.修改nginx.conf 添加反向代理，到windows的Java服务

所有/item的请求都会访问http://192.168.1.3:8081

```shell
#user  nobody;
worker_processes  1;
error_log  logs/error.log;

events {
    worker_connections  1024;
}

http {
    include       mime.types;
    default_type  application/octet-stream;
    sendfile        on;
    keepalive_timeout  65;
    #lua 模块
    lua_package_path "/usr/local/openresty/lualib/?.lua;;";
    #c模块     
    lua_package_cpath "/usr/local/openresty/lualib/?.so;;";  	
    server {
        listen       8081;
        server_name  localhost;
        location /item {
            # 这里是windows电脑的ip和Java服务端口，需要确保windows防火墙处于关闭状态
            proxy_pass http://192.168.1.3:8081; 
        }
        location / {
            root   html;
            index  index.html index.htm;
        }
        location ~ /api/item/(\d+) {
             # 默认的响应类型
             default_type application/json;
             # 响应结果由lua/item.lua文件来决定
             content_by_lua_file lua/item.lua;
        }  
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
    }
}
```

以后，只要我们调用ngx.location.capture("/item")，就一定能发送请求到windows的tomcat服务。

### 封装http查询的函数

我们可以吧http查询的请求封装为一个函数，放到OpenResty函数库中，方便后期使用。

之前设置OpenResty启动时会加载以下两个目录中的工具文件：

![image-20240326113005188](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403261636305.png)

在/usr/local/openresty/lualib目录下，新建一个common.lua文件：

```shell
vi /usr/local/openresty/lualib/common.lua
```

在common.lua中封装http查询的函数

内容如下:

```lua
-- 封装函数，发送http请求，并解析响应
local function read_http(path, params)
    local resp = ngx.location.capture(path,{
        method = ngx.HTTP_GET,
        args = params,
    })
    if not resp then
        -- 记录错误信息，返回404
        ngx.log(ngx.ERR, "http请求查询失败, path: ", path , ", args: ", args)
        ngx.exit(404)
    end
    return resp.body
end
-- 将方法导出
local _M = {  
    read_http = read_http
}  
return _M
```

将read_http函数封装到_M这个table类型的变量中，并且返回，使用的时候，可以利用require('common')来导入该函数库，这里的common是函数库的文件名。

### 实现商品查询

修改/usr/local/openresty/lua/item.lua文件，利用刚刚封装的函数库实现对tomcat的查询：

```lua
-- 引入自定义common工具模块，返回值是common中返回的 _M
local common = require("common")
-- 从 common中获取read_http这个函数
local read_http = common.read_http
-- 获取路径参数
local id = ngx.var[1]
-- 根据id查询商品
local itemJSON = read_http("/item/".. id, nil)
-- 根据id查询商品库存
local itemStockJSON = read_http("/item/stock/".. id, nil)
```

这里查询到的结果是json字符串，并且包含商品、库存两个json字符串，页面最终需要的是把两个json拼接为一个json

![image-20240326113509300](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403261636161.png)

这就需要我们先把JSON变为lua的table，完成数据整合后，再转为JSON。

#### CJSON工具类

OpenResty提供了一个cjson的模块用来处理JSON的序列化和反序列化。

官方地址： https://github.com/openresty/lua-cjson/

1）引入cjson模块：

```
local cjson = require "cjson"
```

2）序列化：

```
local obj = {    name = 'jack',    age = 21 } -- 把 table 序列化为 json local json = cjson.encode(obj)
```

3）反序列化：

```
local json = '{"name": "jack", "age": 21}' -- 反序列化 json为 table local obj = cjson.decode(json); print(obj.name)
```

添加json处理功能,最终item.lua：

```lua
-- 导入common函数库
local common = require('common')
local read_http = common.read_http
-- 导入cjson库
local cjson = require('cjson')

-- 获取路径参数
local id = ngx.var[1]
-- 根据id查询商品
local itemJSON = read_http("/item/".. id, nil)
-- 根据id查询商品库存
local itemStockJSON = read_http("/item/stock/".. id, nil)

-- JSON转化为lua的table
local item = cjson.decode(itemJSON)
local stock = cjson.decode(itemStockJSON )

-- 组合数据
item.stock = stock.stock
item.sold = stock.sold

-- 把item序列化为json 返回结果
ngx.say(cjson.encode(item))
```

访问http://192.168.122.131/item.html?id=10003

![image-20240326123033484](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403261636725.png)

## Tomcat集群基于id实现负载均衡

![image-20240326163744610](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403261637950.png)

如果tomcat集群，OpenResty就需要对tomcat集群做负载均衡。

而默认的负载均衡规则是轮询模式，当我们查询/item/10001时：

- 第一次会访问8081端口的tomcat服务，在该服务内部就形成了JVM进程缓存
- 第二次会访问8082端口的tomcat服务，该服务内部没有JVM缓存（因为JVM缓存无法共享），会查询数据库
- ...

因为轮询的原因，第一次查询8081形成的JVM缓存并未生效，直到下一次再次访问到8081时才可以生效，缓存命中率太低了。

怎么办？

如果能让同一个商品，每次查询时都访问同一个tomcat服务，那么JVM缓存就一定能生效了。

也就是说，我们需要根据商品id做负载均衡，而不是轮询。



nginx提供了基于请求路径做负载均衡的算法：

nginx根据请求路径做hash运算，把得到的数值对tomcat服务的数量取余，余数是几，就访问第几个服务，实现负载均衡。

例如：

- 我们的请求路径是 /item/10001
- tomcat总数为2台（8081、8082）
- 对请求路径/item/1001做hash运算求余的结果为1
- 则访问第一个tomcat服务，也就是8081

只要id不变，每次hash运算结果也不会变，那就可以保证同一个商品，一直访问同一个tomcat服务，确保JVM缓存生效。



修改/usr/local/openresty/nginx/conf/nginx.conf文件，实现基于ID做负载均衡。

首先，定义tomcat集群，并设置基于路径做负载均衡：

```shell
upstream tomcat-cluster {
    hash $request_uri;
    server 192.168.150.1:8081;
    server 192.168.150.1:8082;
}
```

然后，修改对tomcat服务的反向代理，目标指向tomcat集群：

```
location /item {
    proxy_pass http://tomcat-cluster;
}
```



nginx.conf:

```shell
#user  nobody;
worker_processes  1;
error_log  logs/error.log;

events {
    worker_connections  1024;
}

http {
    include       mime.types;
    default_type  application/octet-stream;
    sendfile        on;
    keepalive_timeout  65;
    #lua 模块
    lua_package_path "/usr/local/openresty/lualib/?.lua;;";
    #c模块     
    lua_package_cpath "/usr/local/openresty/lualib/?.so;;";  	
    upstream tomcat-cluster {
        hash $request_uri;
        server 192.168.1.3:8081;
        server 192.168.1.3:8082;
     }

    server {
        listen       8081;
        server_name  localhost;
        location /item {
            # 这里是windows电脑的ip和Java服务端口，需要确保windows防火墙处于关闭状态
           proxy_pass http://tomcat-cluster;
        }
        location / {
            root   html;
            index  index.html index.htm;
        }
        location ~ /api/item/(\d+) {
             # 默认的响应类型
             default_type application/json;
             # 响应结果由lua/item.lua文件来决定
             content_by_lua_file lua/item.lua;
        }  
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
    }
}
```

重新加载OpenResty

```
nginx -s reload
```

启动两台tomcat服务：

![image-20240326133943383](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403261637937.png)

启动8081/8082

![image-20240326134014008](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403261637463.png)

清空日志后，再次访问页面，可以看到不同id的商品，访问到了不同的tomcat服务：

id：10001

![image-20240326134128525](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403261638183.png)

id：10002

![image-20240326134156312](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403261638898.png)

## Redis缓存预热

![image-20240326163844256](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403261638701.png)

Redis缓存会面临冷启动问题：

**冷启动**：服务刚刚启动时，Redis中并没有缓存，如果所有商品数据都在第一次查询时添加缓存，可能会给数据库带来较大压力。

**缓存预热**：在实际开发中，我们可以利用大数据统计用户访问的热点数据，在项目启动时将这些热点数据提前查询并保存到Redis中。

我们数据量较少，并且没有数据统计相关功能，目前可以在启动时将所有数据都放入缓存中。



缓存预热需要在项目启动时完成，并且必须是拿到RedisTemplate之后。

这里我们利用InitializingBean接口来实现，因为InitializingBean可以在对象被Spring创建并且成员变量全部注入后执行。

```java
import com.dongguo.redis.entity.Item;
import com.dongguo.redis.entity.ItemStock;
import com.dongguo.redis.service.IItemService;
import com.dongguo.redis.service.IItemStockService;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.stereotype.Component;
import java.util.List;

@Component
public class RedisHandler implements InitializingBean {

    @Autowired
    private StringRedisTemplate redisTemplate;

    @Autowired
    private IItemService itemService;
    @Autowired
    private IItemStockService stockService;

    private static final ObjectMapper MAPPER = new ObjectMapper();

    @Override
    public void afterPropertiesSet() throws Exception {
        // 初始化缓存
        // 1.查询商品信息
        List<Item> itemList = itemService.list();
        // 2.放入缓存
        for (Item item : itemList) {
            // 2.1.item序列化为JSON
            String json = MAPPER.writeValueAsString(item);
            // 2.2.存入redis
            redisTemplate.opsForValue().set("item:id:" + item.getId(), json);
        }

        // 3.查询商品库存信息
        List<ItemStock> stockList = stockService.list();
        // 4.放入缓存
        for (ItemStock stock : stockList) {
            // 2.1.item序列化为JSON
            String json = MAPPER.writeValueAsString(stock);
            // 2.2.存入redis
            redisTemplate.opsForValue().set("item:stock:id:" + stock.getId(), json);
        }
    }
}
```

项目启动时，初始化bean实现缓存数据

![image-20240326140720839](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403261638960.png)

## 查询Redis缓存

![image-20240326163939646](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403261639684.png)

当请求进入OpenResty之后：

- 优先查询Redis缓存
- 如果Redis缓存未命中，再查询Tomcat



OpenResty提供了操作Redis的模块，我们只要引入该模块就能直接使用。但是为了方便，我们将Redis操作封装到之前的common.lua工具库中。

修改/usr/local/openresty/lualib/common.lua文件：

1）引入Redis模块，并初始化Redis对象

```lua
-- 导入redis
local redis = require('resty.redis')
-- 初始化redis
local red = redis:new()
--设置redis超时时间  建立连接的超时时间、发送请求的超时时间，响应结果的超时时间
red:set_timeouts(1000, 1000, 1000)
```

2）封装函数，用来释放Redis连接，其实是放入连接池

```lua
-- 关闭redis连接的工具方法，其实是放入连接池
local function close_redis(red)
    local pool_max_idle_time = 10000 -- 连接的空闲时间，单位是毫秒
    local pool_size = 100 --连接池大小
    local ok, err = red:set_keepalive(pool_max_idle_time, pool_size)
    if not ok then
        ngx.log(ngx.ERR, "放入redis连接池失败: ", err)
    end
end
```

3）封装函数，根据key查询Redis数据

```lua
-- 查询redis的方法 ip和port是redis地址，key是查询的key
local function read_redis(ip, port, key)
    -- 获取一个连接
    local ok, err = red:connect(ip, port)
    if not ok then
        ngx.log(ngx.ERR, "连接redis失败 : ", err)
        return nil
    end
    -- 如果Redis服务器设置了密码，进行认证  
    if password then  
        local auth_ok, auth_err = red:auth(password)  
        if not auth_ok then  
            ngx.log(ngx.ERR, "Redis认证失败: ", auth_err)  
            close_redis(red)  
            return nil  
        end  
    end  
    -- 查询redis
    local resp, err = red:get(key)
    -- 查询失败处理
    if not resp then
        ngx.log(ngx.ERR, "查询Redis失败: ", err, ", key = " , key)
    end
    --得到的数据为空处理
    if resp == ngx.null then
        resp = nil
        ngx.log(ngx.ERR, "查询Redis数据为空, key = ", key)
    end
    close_redis(red)
    return resp
end
```

4）导出

```lua
-- 将方法导出
local _M = {  
    read_http = read_http,
    read_redis = read_redis
}  
return _M
```

完整的common.lua：

```lua
-- 导入redis
local redis = require('resty.redis')
-- 初始化redis
local red = redis:new()
red:set_timeouts(1000, 1000, 1000)

-- 关闭redis连接的工具方法，其实是放入连接池
local function close_redis(red)
    local pool_max_idle_time = 10000 -- 连接的空闲时间，单位是毫秒
    local pool_size = 100 --连接池大小
    local ok, err = red:set_keepalive(pool_max_idle_time, pool_size)
    if not ok then
        ngx.log(ngx.ERR, "放入redis连接池失败: ", err)
    end
end

-- 查询redis的方法 ip和port是redis地址，key是查询的key
local function read_redis(ip, port, password, key)
    -- 获取一个连接
    local ok, err = red:connect(ip, port)
    if not ok then
        ngx.log(ngx.ERR, "连接redis失败 : ", err)
        return nil
    end
    -- 如果Redis服务器设置了密码，进行认证  
    if password then  
        local auth_ok, auth_err = red:auth(password)  
        if not auth_ok then  
            ngx.log(ngx.ERR, "Redis认证失败: ", auth_err)  
            close_redis(red)  
            return nil  
        end  
    end  
    -- 查询redis
    local resp, err = red:get(key)
    -- 查询失败处理
    if not resp then
        ngx.log(ngx.ERR, "查询Redis失败: ", err, ", key = " , key)
    end
    --得到的数据为空处理
    if resp == ngx.null then
        resp = nil
        ngx.log(ngx.ERR, "查询Redis数据为空, key = ", key)
    end
    close_redis(red)
    return resp
end

-- 封装函数，发送http请求，并解析响应
local function read_http(path, params)
    local resp = ngx.location.capture(path,{
        method = ngx.HTTP_GET,
        args = params,
    })
    if not resp then
        -- 记录错误信息，返回404
        ngx.log(ngx.ERR, "http查询失败, path: ", path , ", args: ", args)
        ngx.exit(404)
    end
    return resp.body
end
-- 将方法导出
local _M = {  
    read_http = read_http,
    read_redis = read_redis
}  
return _M
```



接下来，修改item.lua文件，实现对Redis的查询了。

查询逻辑是：

- 根据id查询Redis
- 如果查询失败则继续查询Tomcat
- 将查询结果返回



1）修改/usr/local/openresty/lua/item.lua文件，添加一个查询函数：

```lua
-- 导入common函数库
local common = require('common')
local read_http = common.read_http
local read_redis = common.read_redis
-- 封装查询函数
function read_data(key, path, params)
    -- 查询本地缓存
    local val = read_redis("127.0.0.1", 6379, "root", key)
    -- 判断查询结果
    if not val then
        ngx.log(ngx.ERR, "redis查询失败，尝试查询http， key: ", key)
        -- redis查询失败，去查询http
        val = read_http(path, params)
    end
    -- 返回数据
    return val
end
```

2）修改商品查询、库存查询的业务：

```lua
-- 获取路径参数
local id = ngx.var[1]

-- 查询商品信息
local itemJSON = read_data("item:id:" .. id,  "/item/" .. id, nil)
-- 查询库存信息
local stockJSON = read_data("item:stock:id:" .. id, "/item/stock/" .. id, nil)
```

3）完整的item.lua代码：

```lua
-- 导入common函数库
local common = require('common')
local read_http = common.read_http
local read_redis = common.read_redis
-- 导入cjson库
local cjson = require('cjson')

-- 封装查询函数
function read_data(key, path, params)
    -- 查询本地缓存
    local val = read_redis("127.0.0.1", 6379, "root", key)
    -- 判断查询结果
    if not val then
        ngx.log(ngx.ERR, "redis查询失败，尝试查询http， key: ", key)
        -- redis查询失败，去查询http
        val = read_http(path, params)
    end
    -- 返回数据
    return val
end

-- 获取路径参数
local id = ngx.var[1]

-- 查询商品信息
local itemJSON = read_data("item:id:" .. id,  "/item/" .. id, nil)
-- 查询库存信息
local stockJSON = read_data("item:stock:id:" .. id, "/item/stock/" .. id, nil)

-- JSON转化为lua的table
local item = cjson.decode(itemJSON)
local stock = cjson.decode(stockJSON)
-- 组合数据
item.stock = stock.stock
item.sold = stock.sold

-- 把item序列化为json 返回结果
ngx.say(cjson.encode(item))
```

将项目停掉，访问还是成功的，说明redis缓存起了作用

![image-20240326143858794](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403261639272.png)

![image-20240326143810895](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403261639865.png)

## Nginx本地缓存

现在，整个多级缓存中只差最后一环，也就是nginx的本地缓存了。如图：

![image-20240326143927444](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403261639382.png)

OpenResty为Nginx提供了**shard dict**的功能，可以在nginx的多个worker之间共享数据，实现缓存功能。

1）开启共享字典，在nginx.conf的http下添加配置：

```shell
 # 共享字典，也就是本地缓存，名称叫做：item_cache，大小150m
 lua_shared_dict item_cache 150m; 
```

2）导入共享字典：

修改/usr/local/openresty/lua/item.lua文件

```shell
-- 获取本地缓存对象
local item_cache = ngx.shared.item_cache
-- 存储, 指定key、value、过期时间，单位s，默认为0代表永不过期
item_cache:set('key', 'value', 1000)
-- 读取
local val = item_cache:get('key')
```

### 实现本地缓存查询

1）修改/usr/local/openresty/lua/item.lua文件，修改read_data查询函数，添加本地缓存逻辑：

优先查询本地缓存，未命中时再查询redis、tomcat

```lua
-- 导入共享词典，本地缓存
local item_cache = ngx.shared.item_cache

-- 封装查询函数
function read_data(key, expire, path, params)
    -- 查询本地缓存
    local val = item_cache:get(key)
    if not val then
        ngx.log(ngx.ERR, "本地缓存查询失败，尝试查询Redis， key: ", key)
        -- 查询redis
        val = read_redis("127.0.0.1", 6379, "root", key)
        -- 判断查询结果
        if not val then
            ngx.log(ngx.ERR, "redis查询失败，尝试查询http， key: ", key)
            -- redis查询失败，去查询http
            val = read_http(path, params)
        end
    end
    -- 查询成功，把数据写入本地缓存
    item_cache:set(key, val, expire)
    -- 返回数据
    return val
end
```

2）修改item.lua中查询商品和库存的业务，实现最新的read_data函数：

查询redis或tomcat成功后，将数据写入本地缓存，并设置有效期

```lua
-- 获取路径参数
local id = ngx.var[1]

-- 查询商品信息
local itemJSON = read_data("item:id:" .. id, 1800,  "/item/" .. id, nil)
-- 查询库存信息
local stockJSON = read_data("item:stock:id:" .. id, 60, "/item/stock/" .. id, nil)
```

其实就是多了缓存时间参数，过期后nginx缓存会自动删除，下次访问即可更新缓存。

这里给商品基本信息设置超时时间为30分钟，库存为1分钟。

因为库存更新频率较高，如果缓存时间过长，可能与数据库差异较大。

3）完整的item.lua文件：

```lua
-- 导入common函数库
local common = require('common')
local read_http = common.read_http
local read_redis = common.read_redis
-- 导入cjson库
local cjson = require('cjson')
-- 导入共享词典，本地缓存
local item_cache = ngx.shared.item_cache

-- 封装查询函数
function read_data(key, expire, path, params)
    -- 查询本地缓存
    local val = item_cache:get(key)
    if not val then
        ngx.log(ngx.ERR, "本地缓存查询失败，尝试查询Redis， key: ", key)
        -- 查询redis
        val = read_redis("127.0.0.1", 6379, "root", key)
        -- 判断查询结果
        if not val then
            ngx.log(ngx.ERR, "redis查询失败，尝试查询http， key: ", key)
            -- redis查询失败，去查询http
            val = read_http(path, params)
        end
    end
    -- 查询成功，把数据写入本地缓存
    item_cache:set(key, val, expire)
    -- 返回数据
    return val
end

-- 获取路径参数
local id = ngx.var[1]

-- 查询商品信息
local itemJSON = read_data("item:id:" .. id, 1800,  "/item/" .. id, nil)
-- 查询库存信息
local stockJSON = read_data("item:stock:id:" .. id, 60, "/item/stock/" .. id, nil)

-- JSON转化为lua的table
local item = cjson.decode(itemJSON)
local stock = cjson.decode(stockJSON)
-- 组合数据
item.stock = stock.stock
item.sold = stock.sold

-- 把item序列化为json 返回结果
ngx.say(cjson.encode(item))
```

访问http://192.168.122.131/item.html?id=10003

![image-20240326150307890](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403261640314.png)

查看log日志/usr/local/openresty/nginx/logs/error.log

```shell
2024/03/26 15:02:37 [notice] 22203#22203: signal process started
2024/03/26 15:02:41 [error] 22204#22204: *47 [lua] item.lua:15: read_data(): 本地缓存查询失败，尝试查询Redis， key: item:id:10003, client: 192.168.122.131, server: localhost, request: "GET /api/item/10003 HTTP/1.0", host: "nginx-cluster", referrer: "http://192.168.122.131/item.html?id=10003"
2024/03/26 15:02:41 [error] 22204#22204: *47 [lua] item.lua:15: read_data(): 本地缓存查询失败，尝试查询Redis， key: item:stock:id:10003, client: 192.168.122.131, server: localhost, request: "GET /api/item/10003 HTTP/1.0", host: "nginx-cluster", referrer: "http://192.168.122.131/item.html?id=10003"
```

再次访问http://192.168.122.131/item.html?id=10003

error.log中不再有日志输出，因为nginx中已经有10003商品的缓存，直接返回数据。

# 缓存同步

基于canal实现缓存同步

![image-20240326151514510](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403261640815.png)

Canal就是把自己伪装成MySQL的一个slave节点，从而监听master的binary log变化。再把得到的变化信息通知给Canal的客户端，进而完成对其它数据库的同步。

![image-20240326152047899](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403261640020.png)

我们可以利用Canal提供的Java客户端，监听Canal通知消息。当收到变化的消息时，完成对缓存的更新。



## 引入依赖

canal-spring-boot-starter只支持到java8版本，使用behappy-canal-spring-boot-starter可支持至java17版本

```xml
        <dependency>
            <groupId>com.alibaba.otter</groupId>
            <artifactId>canal.client</artifactId>
        </dependency>    
		<dependency>
            <groupId>io.github.behappy-project</groupId>
            <artifactId>behappy-canal-spring-boot-starter</artifactId>
        </dependency>
```

## 修改application.yml

```yaml
canal:
  # canal服务地址
  server: 192.168.122.131:11111
    # canal的集群名字，要与安装canal时设置的名称一致
  destination: example
```

## 同步配置UserEntryHandler监听tb_item表

```java
import com.dongguo.redis.entity.Item;
import jakarta.annotation.Resource;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Component;
import org.xiaowu.behappy.canal.client.annotation.CanalTable;
import org.xiaowu.behappy.canal.client.handler.EntryHandler;


/**
 * 获取到Item对象后同步到缓存
 *
 */
@Component
@Slf4j
@CanalTable(value = "tb_item")
public class UserEntryHandler implements EntryHandler<Item> {
    private static final String CACHE_ITEM_KEY = "item:id:";
    @Resource
    private RedisTemplate redisTemplate;

    @Override
    public void insert(Item item) {
        log.info("增加 {}", item);
        redisTemplate.opsForValue().set(CACHE_ITEM_KEY + item.getId(), item);
    }

    @Override
    public void update(Item before, Item after) {
        log.info("修改 before {}", before);
        log.info("修改 after {}", after);
        redisTemplate.opsForValue().set(CACHE_ITEM_KEY + after.getId(), after);
    }

    @Override
    public void delete(Item item) {
        log.info("删除 {}", item);
        redisTemplate.delete(CACHE_ITEM_KEY + item.getId());
    }
}
```

## 安装canal

参考9.10缓存双写一致性问题中canal安装步骤

## 启动canal

/opt/canal/bin目录下

```shell
[root@redis opt]# cd /opt/canal/bin/
[root@redis bin]# ll
总用量 16
-rwxr-xr-x. 1 root root  226 11月 16 2022 restart.sh
-rwxr-xr-x. 1 root root 1244 11月 16 2022 startup.bat
-rwxr-xr-x. 1 root root 3805 10月  8 14:38 startup.sh
-rwxr-xr-x. 1 root root 1356 11月 16 2022 stop.sh
[root@redis bin]# ./startup.sh
```

## 启动项目

启动8081端口实例即可

## 测试

等待canal同步数据库数据后，修改商品信息

比如修改商品名称

```shell
2024-03-26T16:17:37.934+08:00 DEBUG 35604 --- [item] [nio-8081-exec-3] c.d.redis.mapper.ItemMapper.updateById   : ==>  Preparing: UPDATE tb_item SET name=?, title=?, price=?, image=?, category=?, brand=?, spec=?, status=?, create_time=?, update_time=? WHERE id=?
2024-03-26T16:17:37.937+08:00 DEBUG 35604 --- [item] [nio-8081-exec-3] c.d.redis.mapper.ItemMapper.updateById   : ==> Parameters: 拉拉裤(String), 花王（Merries）拉拉裤 M58片 中号尿不湿（6-11kg）（日本原装进口）(String), 38900(Long), https://m.360buyimg.com/mobilecms/s720x720_jfs/t24370/119/1282321183/267273/b4be9a80/5b595759N7d92f931.jpg!q70.jpg.webp(String), 拉拉裤(String), 花王(String), {"型号": "XL"}(String), 1(Integer), 2019-05-01 08:00:00.0(Timestamp), 2019-05-01 08:00:00.0(Timestamp), 10005(Long)
2024-03-26T16:17:37.941+08:00 DEBUG 35604 --- [item] [nio-8081-exec-3] c.d.redis.mapper.ItemMapper.updateById   : <==    Updates: 1
2024-03-26T16:17:37.945+08:00  INFO 35604 --- [item] [xecute-thread-7] c.dongguo.redis.canal.UserEntryHandler   : 修改 before Item(id=null, name=拉拉裤1, title=null, price=null, image=null, category=null, brand=null, spec=null, status=null, createTime=null, updateTime=null, stock=null, sold=null)
2024-03-26T16:17:37.945+08:00  INFO 35604 --- [item] [xecute-thread-7] c.dongguo.redis.canal.UserEntryHandler   : 修改 after Item(id=10005, name=拉拉裤, title=花王（Merries）拉拉裤 M58片 中号尿不湿（6-11kg）（日本原装进口）, price=38900, image=https://m.360buyimg.com/mobilecms/s720x720_jfs/t24370/119/1282321183/267273/b4be9a80/5b595759N7d92f931.jpg!q70.jpg.webp, category=拉拉裤, brand=花王, spec={"型号": "XL"}, status=1, createTime=Wed May 01 00:00:00 CST 2019, updateTime=Wed May 01 00:00:00 CST 2019, stock=null, sold=null)
```

查看数据库缓存，缓存也同步了

![image-20240326162428191](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403261640432.png)
