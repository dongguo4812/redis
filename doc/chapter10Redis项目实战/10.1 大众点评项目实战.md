项目架构

![image-20240319171124630](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403191712307.png)

## 1.创建项目redis_dianping

后端项目redis_dianping

前端就不整了，使用swagger测试接口即可

## 2.引入依赖

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-redis</artifactId>
        <exclusions>
            <exclusion>
                <artifactId>spring-data-redis</artifactId>
                <groupId>org.springframework.data</groupId>
            </exclusion>
            <exclusion>
                <artifactId>lettuce-core</artifactId>
                <groupId>io.lettuce</groupId>
            </exclusion>
        </exclusions>
    </dependency>
    <dependency>
        <groupId>org.springframework.data</groupId>
        <artifactId>spring-data-redis</artifactId>
    </dependency>
    <dependency>
        <groupId>io.lettuce</groupId>
        <artifactId>lettuce-core</artifactId>
    </dependency>
    <dependency>
        <groupId>org.apache.commons</groupId>
        <artifactId>commons-pool2</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
        <scope>runtime</scope>
    </dependency>
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>com.baomidou</groupId>
        <artifactId>mybatis-plus-boot-starter</artifactId>
    </dependency>
    <!--hutool-->
    <dependency>
        <groupId>cn.hutool</groupId>
        <artifactId>hutool-all</artifactId>
    </dependency>
    <dependency>
        <groupId>org.apache.commons</groupId>
        <artifactId>commons-lang3</artifactId>
    </dependency>
    <dependency>
        <groupId>com.alibaba</groupId>
        <artifactId>fastjson</artifactId>
    </dependency>
    <dependency>
        <groupId>org.aspectj</groupId>
        <artifactId>aspectjweaver</artifactId>
    </dependency>
    <dependency>
        <groupId>org.redisson</groupId>
        <artifactId>redisson</artifactId>
    </dependency>
</dependencies>
```



## 3.application.yml配置

```yaml
server:
  port: 8081
spring:
  application:
    name: redis_dianping
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://127.0.0.1:3306/redis?useSSL=false&serverTimezone=UTC
    username: root
    password: root
  data:
    redis:
      host: 192.168.122.131
      port: 6379
      password: root
    lettuce:
      pool:
        max-active: 10
        max-idle: 10
        min-idle: 1
        time-between-eviction-runs: 10s
  jackson:
    default-property-inclusion: non_null # JSON处理时忽略非空字段
mybatis-plus:
  type-aliases-package: com.dongguo.redis.entity # 别名扫描包
logging:
  level:
    com.dongguo.redis: debug

```

## 4.配置类

MybatisConfig   MyBatis Plus分页插件

```java
import com.baomidou.mybatisplus.annotation.DbType;
import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;
import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class MybatisConfig {
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() {
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));
        return interceptor;
    }
}

```

RegexUtils正则校验工具类

```java
import cn.hutool.core.util.StrUtil;

/**
 * true 为无效  false为有效
 */
public class RegexUtils {
    /**
     * 手机号正则
     */
    public static final String PHONE_REGEX = "^1([38][0-9]|4[579]|5[0-3,5-9]|6[6]|7[0135678]|9[89])\\d{8}$";
    /**
     * 邮箱正则
     */
    public static final String EMAIL_REGEX = "^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\\.[a-zA-Z0-9_-]+)+$";
    /**
     * 密码正则。4~32位的字母、数字、下划线
     */
    public static final String PASSWORD_REGEX = "^\\w{4,32}$";
    /**
     * 验证码正则, 6位数字或字母
     */
    public static final String VERIFY_CODE_REGEX = "^[a-zA-Z\\d]{6}$";
    /**
     * 是否是无效手机格式
     * @param phone 要校验的手机号
     * @return true:符合，false：不符合
     */
    public static boolean isPhoneInvalid(String phone){
        return mismatch(phone, PHONE_REGEX);
    }
    /**
     * 是否是无效邮箱格式
     * @param email 要校验的邮箱
     * @return true:符合，false：不符合
     */
    public static boolean isEmailInvalid(String email){
        return mismatch(email, EMAIL_REGEX);
    }

    /**
     * 是否是无效验证码格式
     * @param code 要校验的验证码
     * @return true:符合，false：不符合
     */
    public static boolean isCodeInvalid(String code){
        return mismatch(code, VERIFY_CODE_REGEX);
    }

    // 校验是否不符合正则格式
    private static boolean mismatch(String str, String regex){
        if (StrUtil.isBlank(str)) {
            return true;
        }
        return !str.matches(regex);
    }
}

```



# 短信登录实战短信登录实战

## 基于Session实现登录流程

先不考虑使用redis实现，基于Session实现登录流程

**发送验证码：**

用户在提交手机号后，会校验手机号是否合法，如果不合法，则要求用户重新输入手机号

如果手机号合法，后台此时生成对应的验证码，同时将验证码进行保存到session，然后再通过短信的方式将验证码发送给用户

**短信验证码登录、注册：**

用户将验证码和手机号进行输入，后台从session中拿到当前验证码，然后和用户输入的验证码进行校验，如果不一致，则无法通过校验，如果一致，则后台根据手机号查询用户，如果用户不存在，则为用户创建账号信息，保存到数据库，存在则登录，无论是否存在，都会将用户信息保存到session中，方便后续获得当前登录信息

**校验登录状态:**

用户在请求时候，会从cookie中携带者JsessionId到后台，后台通过JsessionId从session中拿到用户信息，如果没有session信息，则进行拦截，如果有session信息，则将用户信息保存到threadLocal中，并且放行



![image-20240319171441782](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403191714868.png)

实现发送短信验证码功能

![image-20240319171506381](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403191715065.png)

点击登录，输入手机号，点击发送验证码

### 发送短信验证码功能

UserServiceImpl：

```java
        @Override
        public Result sendCode(String phone, HttpSession session) {
            //1校验手机号是否符合规定
            if (StringUtils.isBlank(phone)) {
                return Result.fail("手机号不能为空");
            }
            if (phone.length() != 11) {
                return Result.fail("手机号" + phone + "不符合要求");
            }
            boolean isMatch = RegexUtils.isPhoneInvalid(phone);
            if (isMatch) {
                return Result.fail("手机号" + phone + "不符合要求");
            }
            //2生成验证码
            String code = RandomUtil.randomNumbers(6);
            //3保存到session中
            session.setAttribute("code", code);
            log.debug("验证码发送成功:{}", code);
            return Result.ok("验证码发送成功:" + code);
        }
```

UserController：

```java
    @Operation(
            summary = "sendCode",
            description = "发送手机验证码"
    )
    @PostMapping("/sendCode")
    public Result sendCode(@RequestParam(value = "phone") String phone, HttpSession session) {
        return userService.sendCode(phone, session);
    }
```



### 短信验证码登录功能

UserServiceImpl

```java
    @Override
    public Result login(LoginFormBO loginForm, HttpSession session) {
        if (ObjectUtil.isEmpty(loginForm)) {
            return Result.fail("数据为空");
        }
        if (StringUtils.isBlank(loginForm.getPhone()) || StringUtils.isBlank(loginForm.getCode())) {
            return Result.fail("手机号或者验证码不能为空");
        }
        boolean isMatch = RegexUtils.isPhoneInvalid(loginForm.getPhone());
        if (isMatch) {
            return Result.fail("手机号" + loginForm.getPhone() + "不符合要求");
        }
        String code = session.getAttribute("code").toString();
        if (!loginForm.getCode().equals(code)) {
            return Result.fail("验证码错误");
        }

        LambdaUpdateWrapper<User> wrapper = new LambdaUpdateWrapper<>();
        wrapper.eq(User::getPhone, loginForm.getPhone());
        User user = userMapper.selectOne(wrapper);
        if (ObjectUtil.isEmpty(user)) {
            //注册新用户
            User newUser = new User()
                    .setPhone(loginForm.getPhone())
                    .setNickName(SystemConstants.USER_NICK_NAME_PREFIX + RandomUtil.randomString(SystemConstants.MAX_PAGE_SIZE));
            userMapper.insert(newUser);
        }
        //登录
        String token = UUID.randomUUID().toString(true);
        UserDTO userDTO = new UserDTO();
        BeanUtil.copyProperties(user, userDTO);
        session.setAttribute("user",userDTO);
        return Result.ok(token);
    }
```

UserController

```java
    /**
     * 登录功能  目前只实现手机+验证码登录即可
     *
     * @param loginForm 登录参数，包含手机号、验证码；或者手机号、密码
     */
    @PostMapping("/login")
    public Result login(@RequestBody LoginFormBO loginForm, HttpSession session) {
        return userService.login(loginForm,session);
    }
```

### 实现登录拦截功能

当用户发起请求时，会访问我们向tomcat注册的端口，任何程序想要运行，都需要有一个线程对当前端口号进行监听，tomcat也不例外，当监听线程知道用户想要和tomcat连接连接时，那会由监听线程创建socket连接，socket都是成对出现的，用户通过socket像互相传递数据，当tomcat端的socket接受到数据后，此时监听线程会从tomcat的线程池中取出一个线程执行用户请求，在我们的服务部署到tomcat后，线程会找到用户想要访问的工程，然后用这个线程转发到工程中的controller，service，dao中，并且访问对应的DB，在用户执行完请求后，再统一返回，再找到tomcat端的socket，再将数据写回到用户端的socket，完成请求和响应

![image-20240320094027340](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403202210733.png)

通过以上讲解，我们可以得知 每个用户其实对应都是去找tomcat线程池中的一个线程来完成工作的， 使用完成后再进行回收，既然每个请求都是独立的，所以在每个用户去访问我们的工程时，我们可以使用threadlocal来做到线程隔离，每个线程操作自己的一份数据

![image-20240320094215135](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403202208337.png)

拦截器LoginInterceptor

```java
import com.dongguo.redis.entity.DTO.UserDTO;
import com.dongguo.redis.support.threadlocal.UserThreadLocalCache;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;
import org.springframework.web.servlet.HandlerInterceptor;


/**
 * 登录拦截器
 */
public class LoginInterceptor implements HandlerInterceptor {

    /**
     * 在控制器方法（即处理请求的@RequestMapping注解的方法）之前调用
     * @param request
     * @param response
     * @param handler
     * @return
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
        //获取session
        HttpSession session = request.getSession();
        //获取session中用户信息
        Object user = session.getAttribute("user");
        if (user == null){
            //不存在，即未进行登录，进行拦截
            return false;
        }
        //存在，保存用户信息到threadLocal
        UserThreadLocalCache.setUser((UserDTO)user);
        //放行
        return true;
    }

    /**
     * 在整个请求处理完成之后调用
     * @param request
     * @param response
     * @param handler
     * @param ex
     * @throws Exception
     */
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        // 移除ThreadLocal用户信息
        UserThreadLocalCache.removeUser();
    }
}
```

MvcConfig：

在 Spring MVC 的配置中注册这个拦截器，让拦截器生效

```java
import com.dongguo.redis.support.interceptor.LoginInterceptor;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;


@Configuration
public class MvcConfig implements WebMvcConfigurer {


    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        //登录拦截器
        registry.addInterceptor(new LoginInterceptor())
                //排除不需要拦截的路径，视情况添加
                .excludePathPatterns(
                        "/v3/**",  //swagger也需要排除
                        "/swagger-ui/**",
                        "/swagger-ui.html",

                        "/shop/**", //店铺信息
                        "/voucher/**",  //优惠券信息
                        "/shop-type/**",    //店铺类型信息
                        "/blog/hot",    //查询热门博客
                        "/user/sendCode",  //发送短信验证码
                        "/user/login"  //登录
                ).order(1);
    }
}

```



### 获取用户信息

测试拦截器功能，必须登录后才能获取用户信息

![image-20240320101747433](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403202209790.png)

这个接口用户信息中的一些敏感信息是不需要返回的，所以直接返回UserDto对象就足够了。

并且拦截器会将session中的用户信息放入到ThreadLocal中，所以直接从ThreadLocal中获取user信息即可。

UserController：

```java
    /**
     * 请求接口时，拦截器会将session中的用户信息放入到ThreadLocal中
     * 所以直接从ThreadLocal中获取user信息即可。
     * @return
     */
    @GetMapping("/me")
    public Result me() {
        UserDTO user = UserThreadLocalCache.getUser();
        return Result.ok(user);
    }
```

### session共享问题

集群中，每个tomcat中都有一份属于自己的session,假设用户第一次访问第一台tomcat，并且把自己的信息存放到第一台服务器的session中，但是第二次这个用户访问到了第二台tomcat，那么在第二台服务器上，肯定没有第一台服务器存放的session，所以此时 整个登录拦截功能就会出现问题，我们能如何解决这个问题呢？早期的方案是session拷贝，就是说虽然每个tomcat上都有不同的session，但是每当任意一台服务器的session修改时，都会同步给其他的Tomcat服务器的session，这样的话，就可以实现session的共享了

但是这种方案具有两个大问题

1、每台服务器中都有完整的一份session数据，服务器压力过大。

2、session拷贝数据时，可能会出现延迟

![image-20240320110353355](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403202209293.png)

#### 解决方案

基于redis来完成，把session换成redis，redis数据本身就是共享的，就可以避免session共享的问题了

![image-20240320110630674](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403202209419.png)

## 基于Redis实现共享session登录

使用Redis保存session，可以直接使用String数据类型，以手机号为key，验证码为value。

使用Redis保存用户信息时，可以使用Hash数据类型也可以使用String数据类型。既然保存对象信息，那就选择hash。

在后台生成一个随机串token作为key，用户信息为value，请求接口时携带这个token就能完成我们的整体逻辑了

### 流程：

输入手机号生成验证码，将验证码保存到redis，登录时校验输入的验证码与redis中的验证码是否一致，如果一致，则根据手机号查询用户信息，不存在则新建，最后将用户数据保存到redis，并且生成token作为redis的key。

当我们校验用户是否登录时，会去携带着token进行访问，从redis中取出token对应的value，判断是否存在这个数据，如果没有则拦截，如果存在则将其保存到threadLocal中，并且放行。

![image-20240320112135358](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403202209888.png)





![image-20240320112356513](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403202209011.png)

### 修改代码

UserServiceImpl

```java
import cn.hutool.core.bean.BeanUtil;
import cn.hutool.core.bean.copier.CopyOptions;
import cn.hutool.core.lang.UUID;
import cn.hutool.core.util.ObjectUtil;
import cn.hutool.core.util.RandomUtil;
import com.baomidou.mybatisplus.core.conditions.update.LambdaUpdateWrapper;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.dongguo.redis.entity.BO.LoginFormBO;
import com.dongguo.redis.entity.DTO.UserDTO;
import com.dongguo.redis.entity.POJO.User;
import com.dongguo.redis.entity.Result;
import com.dongguo.redis.mapper.UserMapper;
import com.dongguo.redis.service.IUserService;
import com.dongguo.redis.utils.RedisConstants;
import com.dongguo.redis.utils.RegexUtils;
import com.dongguo.redis.utils.SystemConstants;
import jakarta.annotation.Resource;
import jakarta.servlet.http.HttpSession;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;
import java.time.Duration;
import java.util.HashMap;
import java.util.Map;

import static com.dongguo.redis.utils.RedisConstants.LOGIN_CODE_KEY;
import static com.dongguo.redis.utils.RedisConstants.LOGIN_CODE_TTL;

/**
 * <p>
 * 服务实现类
 * </p>
 */
@Service
@Slf4j
public class UserServiceImpl extends ServiceImpl<UserMapper, User> implements IUserService {
    @Autowired
    private UserMapper userMapper;
    @Resource
    private RedisTemplate redisTemplate;

    @Override
    public Result sendCode(String phone, HttpSession session) {
        //1校验手机号是否符合规定
        if (StringUtils.isBlank(phone)) {
            return Result.fail("手机号不能为空");
        }
        if (phone.length() != 11) {
            return Result.fail("手机号" + phone + "不符合要求");
        }
        boolean isMatch = RegexUtils.isPhoneInvalid(phone);
        if (isMatch) {
            return Result.fail("手机号" + phone + "不符合要求");
        }
        //2生成验证码
        String code = RandomUtil.randomNumbers(6);
        //3保存到session中
//            session.setAttribute("code", code);
        //保存到redis中
        redisTemplate.opsForValue().set(LOGIN_CODE_KEY + phone,
                code,
                Duration.ofMinutes(LOGIN_CODE_TTL));
        //4发送验证码
        log.debug("验证码发送成功:{}", code);
        return Result.ok("验证码发送成功:" + code);
    }

    @Override
    public Result login(LoginFormBO loginForm, HttpSession session) {
        if (ObjectUtil.isEmpty(loginForm)) {
            return Result.fail("数据为空");
        }
        if (StringUtils.isBlank(loginForm.getPhone()) || StringUtils.isBlank(loginForm.getCode())) {
            return Result.fail("手机号或者验证码不能为空");
        }
        boolean isMatch = RegexUtils.isPhoneInvalid(loginForm.getPhone());
        if (isMatch) {
            return Result.fail("手机号" + loginForm.getPhone() + "不符合要求");
        }
        Object obj = redisTemplate.opsForValue().get(LOGIN_CODE_KEY + loginForm.getPhone());
        if (obj == null){
            return Result.fail("验证码错误");
        }
//        String code = session.getAttribute("code").toString();

        LambdaUpdateWrapper<User> wrapper = new LambdaUpdateWrapper<>();
        wrapper.eq(User::getPhone, loginForm.getPhone());
        User user = userMapper.selectOne(wrapper);
        if (ObjectUtil.isEmpty(user)) {
            //注册新用户
            User newUser = new User()
                    .setPhone(loginForm.getPhone())
                    .setNickName(SystemConstants.USER_NICK_NAME_PREFIX + RandomUtil.randomString(SystemConstants.MAX_PAGE_SIZE));
            userMapper.insert(newUser);
        }
        //登录
        String token = UUID.randomUUID().toString(true);
        UserDTO userDTO = new UserDTO();
        BeanUtil.copyProperties(user, userDTO);
        Map<String, Object> userMap = new HashMap<>();
        BeanUtil.copyProperties(userDTO, userMap, new CopyOptions().setConverter((fieldName,filedValue) ->filedValue.toString()));
        redisTemplate.opsForHash().putAll(RedisConstants.LOGIN_USER_KEY + token, userMap);
        redisTemplate.expire(RedisConstants.LOGIN_USER_KEY + token, Duration.ofMinutes(RedisConstants.LOGIN_USER_TTL));
//        session.setAttribute("user", userDTO);
        return Result.ok(token);
    }
}
```

LoginInterceptor拦截器

```java
import cn.hutool.core.bean.BeanUtil;
import cn.hutool.core.util.ObjectUtil;
import com.dongguo.redis.entity.DTO.UserDTO;
import com.dongguo.redis.support.threadlocal.UserThreadLocalCache;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.web.servlet.HandlerInterceptor;
import java.util.Map;

import static com.dongguo.redis.utils.RedisConstants.LOGIN_USER_KEY;


/**
 * 登录拦截器
 */
public class LoginInterceptor implements HandlerInterceptor {
    private RedisTemplate redisTemplate;

    public LoginInterceptor(RedisTemplate redisTemplate) {
        this.redisTemplate = redisTemplate;
    }
    /**
     * 在控制器方法（即处理请求的@RequestMapping注解的方法）之前调用
     * @param request
     * @param response
     * @param handler
     * @return
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
   /*     //获取session
        HttpSession session = request.getSession();
        //获取session中用户信息
        Object user = session.getAttribute("user");
        if (user == null){
            //不存在，即未进行登录，进行拦截
            return false;
        }
        //存在，保存用户信息到threadLocal
        UserThreadLocalCache.setUser((UserDTO)user);
        */

        String token = request.getHeader("authorization");
        if (token == null){
            //不存在，即未进行登录，进行拦截
            response.setStatus(401);
            return false;
        }
        Map<Object, Object> userMap = redisTemplate.opsForHash().entries(LOGIN_USER_KEY + token);
        if (ObjectUtil.isEmpty(userMap)){
            response.setStatus(401);
            return false;
        }
        UserDTO userDTO = BeanUtil.mapToBean(userMap, UserDTO.class,false);

        //存在，保存用户信息到threadLocal
        UserThreadLocalCache.setUser(userDTO);
        //放行
        return true;
    }

    /**
     * 在整个请求处理完成之后调用
     * @param request
     * @param response
     * @param handler
     * @param ex
     * @throws Exception
     */
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        // 移除ThreadLocal用户信息
        UserThreadLocalCache.removeUser();
    }
}
```

MvcConfig传入stringRedisTemplate

```java
import com.dongguo.redis.support.interceptor.LoginInterceptor;
import jakarta.annotation.Resource;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;


@Configuration
public class MvcConfig implements WebMvcConfigurer {
    @Resource
    private RedisTemplate redisTemplate;
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        //登录拦截器
        registry.addInterceptor(new LoginInterceptor(redisTemplate))
                //排除不需要拦截的路径，视情况添加
                .excludePathPatterns(
                        "/v3/**",  //swagger也需要排除
                        "/swagger-ui/**",
                        "/swagger-ui.html",
                        "/shop/**", //店铺信息
                        "/voucher/**",  //优惠券信息
                        "/shop-type/**",    //店铺类型信息
                        "/blog/hot",    //查询热门博客
                        "/user/sendCode",  //发送短信验证码
                        "/user/login"  //登录
                ).order(1);
    }
}
```

SwaggerOpenApiConfig新增AUTHORIZATION

```java
import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Contact;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.info.License;
import io.swagger.v3.oas.models.security.SecurityRequirement;
import io.swagger.v3.oas.models.security.SecurityScheme;
import org.springframework.boot.SpringBootConfiguration;
import org.springframework.context.annotation.Bean;
import org.springframework.http.HttpHeaders;

import java.util.HashMap;

@SpringBootConfiguration
public class SwaggerOpenApiConfig {
    /***
     * 构建Swagger3.0文档说明
     * @return 返回 OpenAPI
     */
    @Bean
    public OpenAPI customOpenAPI() {

        // 联系人信息(contact)，构建API的联系人信息，用于描述API开发者的联系信息，包括名称、URL、邮箱等
        // name：文档的发布者名称 url：文档发布者的网站地址，一般为企业网站 email：文档发布者的电子邮箱
        Contact contact = new Contact()
                .name("东郭")                             // 作者名称
                .email("dongguo@qq.com")                   // 作者邮箱
                .url("https://www.dongguo.com")  // 介绍作者的URL地址
                .extensions(new HashMap<String, Object>()); // 使用Map配置信息（如key为"name","email","url"）

        // 授权许可信息(license)，用于描述API的授权许可信息，包括名称、URL等；假设当前的授权信息为Apache 2.0的开源标准
        License license = new License()
                .name("Apache 2.0")                         // 授权名称
                .url("https://www.apache.org/licenses/LICENSE-2.0.html")    // 授权信息
                .identifier("Apache-2.0")                   // 标识授权许可
                .extensions(new HashMap<String, Object>());// 使用Map配置信息（如key为"name","url","identifier"）

        //创建Api帮助文档的描述信息、联系人信息(contact)、授权许可信息(license)
        Info info = new Info()
                .title("Swagger3.0 (Open API) 框架学习示例文档")      // Api接口文档标题（必填）
                .description("学习Swagger框架而用来定义测试的文档")     // Api接口文档描述
                .version("1.0.0")                                  // Api接口版本
                .termsOfService("https://dongguo.com/")            // Api接口的服务条款地址
                .license(license)                                  // 设置联系人信息
                .contact(contact);                                 // 授权许可信息
        // 返回信息
        return new OpenAPI()
                .openapi("3.0.1")  // Open API 3.0.1(默认)
                .schemaRequirement(HttpHeaders.AUTHORIZATION, this.securityScheme())
                //全局安全校验项，也可以在对应的controller上加注解SecurityRequirement
                .addSecurityItem(new SecurityRequirement().addList(HttpHeaders.AUTHORIZATION))
                .info(info);       // 配置Swagger3.0描述信息
    }

    /**
     * 参考https://springdoc.org/#how-do-i-add-authorization-header-in-requests
     * @return
     */
    private SecurityScheme securityScheme() {
        SecurityScheme securityScheme = new SecurityScheme();
        //类型
        securityScheme.setType(SecurityScheme.Type.APIKEY);
        //请求头的name
        securityScheme.setName(HttpHeaders.AUTHORIZATION);
        //token所在未知
        securityScheme.setIn(SecurityScheme.In.HEADER);
        return securityScheme;
    }
}
```

![image-20240320144136466](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403202209401.png)

### 解决登录token过期问题

在用户登录时，将用户信息缓存到redis中，并设置过期时间30分。但是如果超过了30分钟，那token就无效了，我们需要只要是用户还在访问系统，那就刷新token有效期。

![image-20240320151038915](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403202209839.png)

```java
    /**
     * 在控制器方法（即处理请求的@RequestMapping注解的方法）之前调用
     * @param request
     * @param response
     * @param handler
     * @return
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
        String token = request.getHeader("authorization");
        if (token == null){
            //不存在，即未进行登录，进行拦截
            response.setStatus(401);
            return false;
        }
        String tokenKey = LOGIN_USER_KEY + token;
        Map<Object, Object> userMap = redisTemplate.opsForHash().entries(tokenKey);
        if (ObjectUtil.isEmpty(userMap)){
            response.setStatus(401);
            return false;
        }
        UserDTO userDTO = BeanUtil.mapToBean(userMap, UserDTO.class,false);

        //存在，保存用户信息到threadLocal
        UserThreadLocalCache.setUser(userDTO);
        //刷新token有效期
        stringRedisTemplate.expire(tokenKey, LOGIN_USER_TTL, TimeUnit.MINUTES);
        //放行
        return true;
    }
```

### 解决状态登录刷新问题

虽然我们在拦截器中设置了刷新token有效期的操作，但是这个登录拦截器他只拦截需要登录才能访问的路径，假设当前用户访问了一些不需要拦截的路径，那么这个拦截器就不会生效，所以此时token刷新的动作实际上就不会执行，这个方案是存在问题的



既然之前的拦截器无法对不需要拦截的路径生效，那么我们可以再添加一个拦截器，在第一个拦截器中拦截所有的路径，把第二个拦截器做的事情放入到第一个拦截器中，同时刷新令牌，因为第一个拦截器有了threadLocal的数据，所以此时第二个拦截器只需要判断拦截器中的user对象是否存在即可。

![image-20240320151337707](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403202209735.png)

RefreshTokenInterceptor 拦截器负责刷新token

```java
import cn.hutool.core.bean.BeanUtil;
import cn.hutool.core.util.StrUtil;
import com.dongguo.redis.entity.DTO.UserDTO;
import com.dongguo.redis.support.threadlocal.UserThreadLocalCache;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.web.servlet.HandlerInterceptor;
import java.util.Map;
import java.util.concurrent.TimeUnit;

import static com.dongguo.redis.utils.RedisConstants.LOGIN_USER_KEY;
import static com.dongguo.redis.utils.RedisConstants.LOGIN_USER_TTL;

public class RefreshTokenInterceptor implements HandlerInterceptor {

    private RedisTemplate redisTemplate;

    public RefreshTokenInterceptor(RedisTemplate redisTemplate) {
        this.redisTemplate = redisTemplate;
    }
    /**
     * 在控制器方法（即处理请求的@RequestMapping注解的方法）之前调用
     * @param request
     * @param response
     * @param handler
     * @return
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
       /*     //获取session
        HttpSession session = request.getSession();
        //获取session中用户信息
        Object user = session.getAttribute("user");
        if (user == null){
            //不存在，即未进行登录，进行拦截
            return false;
        }
        //存在，保存用户信息到threadLocal
        UserThreadLocalCache.setUser((UserDTO)user);
        */
        // 1.获取请求头中的token
        String token = request.getHeader("authorization");
        if (StrUtil.isBlank(token)) {
            return true;
        }
        // 2.基于TOKEN获取redis中的用户
        String tokenKey  = LOGIN_USER_KEY + token;
        Map<Object, Object> userMap = redisTemplate.opsForHash().entries(tokenKey);
        // 3.判断用户是否存在
        if (userMap.isEmpty()) {
            return true;
        }
        // 5.将查询到的hash数据转为UserDTO
        UserDTO userDTO = BeanUtil.mapToBean(userMap, UserDTO.class,false);
        // 6.存在，保存用户信息到 ThreadLocal
        UserThreadLocalCache.setUser(userDTO);
        // 7.刷新token有效期
        stringRedisTemplate.expire(tokenKey, LOGIN_USER_TTL, TimeUnit.MINUTES);
        // 8.放行
        return true;
    }
    /**
     * 在整个请求处理完成之后调用
     * @param request
     * @param response
     * @param handler
     * @param ex
     * @throws Exception
     */
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        // 移除用户
        UserThreadLocalCache.removeUser();
    }
}
```

LoginInterceptor：

```java
import com.dongguo.redis.support.threadlocal.UserThreadLocalCache;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.web.servlet.HandlerInterceptor;


/**
 * 登录拦截器
 */
public class LoginInterceptor implements HandlerInterceptor {

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
        if (UserThreadLocalCache.getUser() == null){
            response.setStatus(401);
            return false;
        }
        return true;
    }
}
```

MvcConfig

在 Spring MVC 的配置中注册这两个拦截器，让拦截器生效

RefreshTokenInterceptor先拦截，拦截所有请求，LoginInterceptor后拦截，拦截需要登录才能访问的请求

```java
import com.dongguo.redis.support.interceptor.LoginInterceptor;
import com.dongguo.redis.support.interceptor.RefreshTokenInterceptor;
import jakarta.annotation.Resource;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;


@Configuration
public class MvcConfig implements WebMvcConfigurer {
    @Resource
    private RedisTemplate redisTemplate;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        // token刷新的拦截器
        registry.addInterceptor(new RefreshTokenInterceptor(redisTemplate))
                .addPathPatterns("/**")
                .order(0);

        //登录拦截器
        registry.addInterceptor(new LoginInterceptor())
                //排除不需要拦截的路径，视情况添加
                .excludePathPatterns(
                        "/v3/**",  //swagger也需要排除
                        "/swagger-ui/**",
                        "/swagger-ui.html",
                        "/shop/**", //店铺信息
                        "/voucher/**",  //优惠券信息
                        "/shop-type/**",    //店铺类型信息
                        "/blog/hot",    //查询热门博客
                        "/user/sendCode",  //发送短信验证码
                        "/user/login"  //登录
                ).order(1);
    }
}
```

# 商户查询缓存实战

在我们查询商户信息时，查询数据库之前先查询缓存，如果缓存数据存在，则直接从缓存中返回，如果缓存数据不存在，再查询数据库，然后将数据存入redis。

![image-20240320184454869](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403202209351.png)

根据id查询店铺时，如果缓存未命中，则查询数据库，将数据库结果写入缓存，并设置超时时间

ShopController:

```java
import com.dongguo.redis.entity.Result;
import com.dongguo.redis.service.IShopService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.annotation.Resource;
import org.springframework.web.bind.annotation.*;


/**
 * <p>
 * 商户控制器
 * </p>
 */
@RestController
@RequestMapping("/shop")
@Tag(
        name = "ShopController",
        description = "商户控制器接口")
public class ShopController {

    @Resource
    public IShopService shopService;

    /**
     * 根据id查询商铺信息
     *
     * @param id 商铺id
     * @return 商铺详情数据
     */
    @GetMapping("/{id}")
    @Operation(
            summary = "queryShopById",
            description = "根据id查询商铺信息"
    )
    public Result queryShopById(@PathVariable("id") Long id) {
        return shopService.queryShopById(id);
    }
}
```

ShopServiceImpl:

```java
import cn.hutool.core.bean.BeanUtil;
import cn.hutool.core.util.ObjectUtil;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.dongguo.redis.entity.POJO.Shop;
import com.dongguo.redis.entity.Result;
import com.dongguo.redis.mapper.ShopMapper;
import com.dongguo.redis.service.IShopService;
import jakarta.annotation.Resource;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;
import java.util.*;
import java.util.concurrent.TimeUnit;

import static com.dongguo.redis.utils.RedisConstants.*;

/**
 * <p>
 * 服务实现类
 * </p>
 *
 */
@Service
public class ShopServiceImpl extends ServiceImpl<ShopMapper, Shop> implements IShopService {
    @Resource
    private RedisTemplate redisTemplate;
    @Autowired
    private ShopMapper shopMapper;

    @Override
    public Result queryShopById(Long id) {
        if (id == null) {
            return Result.fail("店铺id不能为空");
        }
        String shopCacheKey = CACHE_SHOP_KEY + id;
        //先查缓存
        Object object = redisTemplate.opsForValue().get(shopCacheKey);
        //判空
        if (ObjectUtil.isNotEmpty(object)) {
            //缓存查到 返回
            return Result.ok(object);
        }
        //缓存中没查到  查数据库
        Shop shop = shopMapper.selectById(id);
        if (ObjectUtil.isEmpty(shop)) {
            return Result.fail("店铺信息不存在");
        }
        //存到缓存中
        redisTemplate.opsForValue().set(shopCacheKey, shop, CACHE_SHOP_TTL, TimeUnit.MINUTES);
        return Result.ok(shop);
    }
}
```

## 实现商铺和缓存与数据库双写一致

根据id修改店铺时，先修改数据库，再删除缓存

ShopServiceImpl：

```java
    @Override
    @Transactional
    public Result updateShop(Shop shop) {
        Shop shopById = getById(shop.getId());
        if (ObjectUtil.isEmpty(shopById)) {
            return Result.fail("商铺不存在");
        }
        // 写入数据库
        updateById(shop);

        //删除缓存
        redisTemplate.delete(CACHE_SHOP_KEY + shop.getId());
        return Result.ok();
    }
```

ShopController：

```java
    /**
     * 更新商铺信息
     *
     * @param shop 商铺数据
     * @return 无
     */
    @PutMapping
    @Operation(
            summary = "updateShop",
            description = "更新商铺信息"
    )
    public Result updateShop(@RequestBody Shop shop) {
        return shopService.updateShop(shop);
    }
```

## 缓存穿透问题的解决思路

恶意频繁访问缓存数据库没有的数据，

![image-20240320210136811](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403202209709.png)

### 1缓存空对象  

**缓存空对象思路分析：**当我们访问不存在的数据时，先请求redis，但是此时redis中没有数据，就会访问到数据库，但是数据库中也没有数据，这个数据穿透了缓存，直击数据库，我们都知道数据库能够承载的并发不如redis这么高，如果大量的请求同时过来访问这种不存在的数据，这些请求就都会访问到数据库，简单的解决方案就是哪怕这个数据在数据库中也不存在，我们也把这个数据存入到redis中去，这样，下次用户过来访问这个不存在的数据，那么在redis中也能找到这个数据就不会进入到缓存了

![image-20240320210314147](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403202209684.png)

如果这个数据不存在，把这个数据写入到Redis中，并且将value设置为空，当再次发起查询时，我们如果发现命中之后，判断这个value是否是null，如果是null，则是之前写入的数据，证明是缓存穿透数据，如果不是，则直接返回数据。

![image-20240320210428865](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403202209483.png)

ShopServiceImpl：

```java
    @Override
    public Result queryShopById(Long id) {
        if (id == null) {
            return Result.fail("店铺id不能为空");
        }
        String shopCacheKey = CACHE_SHOP_KEY + id;
        //先查缓存
        Object object = redisTemplate.opsForValue().get(shopCacheKey);
        //判空
        if (ObjectUtil.isNotEmpty(object)) {
            //缓存查到 返回
            return Result.ok(object);
        }
        //缓存的空值   缓存的空字符串""
        if (ObjectUtil.equal(object,"")) {
            return Result.fail("店铺信息不存在");
        }
        //缓存中没查到  查数据库
        Shop shop = shopMapper.selectById(id);
        if (ObjectUtil.isEmpty(shop)) {
            //解决缓存穿透问题  缓存空对象
            redisTemplate.opsForValue().set(shopCacheKey, "", CACHE_NULL_TTL, TimeUnit.MINUTES);
            return Result.fail("店铺信息不存在");
        }
        //存到缓存中
        redisTemplate.opsForValue().set(shopCacheKey, shop, CACHE_SHOP_TTL, TimeUnit.MINUTES);
        return Result.ok(shop);
    }
```

### 2布隆过滤器 TODO





## 缓存击穿问题及解决思路

缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。



假设线程1在查询缓存之后，本来应该去查询数据库，然后把这个数据重新加载到缓存的，此时只要线程1走完这个逻辑，其他线程就都能从缓存中加载这些数据了，但是假设在线程1没有走完的时候，后续的线程2，线程3，线程4同时过来访问当前这个方法， 那么这些线程都不能从缓存中查询到数据，那么他们就会同一时刻来访问查询缓存，都没查到，接着同一时间去访问数据库，同时的去执行数据库代码，对数据库访问压力过大

![image-20240320214647199](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403202209116.png)

### 1.互斥锁

只能一个人一个人的来访问数据库，从而避免对于数据库访问压力过大，但这也会影响查询的性能，因为此时会让查询的性能从并行变成了串行。

假设现在线程1过来访问，他查询缓存没有命中，但是此时他获得到了锁的资源，那么线程1就会一个人去执行逻辑，假设现在线程2过来，线程2在执行过程中，并没有获得到锁，那么线程2就可以进行到休眠，直到线程1把锁释放后，线程2获得到锁，然后再来执行逻辑，此时就能够从缓存中拿到数据了。

![image-20240320214835660](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403202209459.png)

相较于原来从缓存中查询不到数据后直接查询数据库而言，现在的方案是 进行查询之后，如果从缓存没有查询到数据，则进行互斥锁的获取，获取互斥锁后，判断是否获得到了锁，如果没有获得到，则休眠，过一会再进行尝试，直到获取到锁为止，才能进行查询

如果获取到了锁的线程，再去进行查询，查询后将数据写入redis，再释放锁，返回数据，利用互斥锁就能保证只有一个线程去执行操作数据库的逻辑，防止缓存击穿

![image-20240321074253414](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403210743366.png)

核心思路就是利用redis的setnx方法来表示获取锁，该方法含义是redis中如果没有这个key，则插入成功，返回1，在RedisTemplate中返回true，  如果有这个key则插入失败，则返回0，在RedisTemplate返回false，我们可以通过true，或者是false，来表示是否有线程成功插入key，成功插入的key的线程我们认为他就是获得到锁的线程。

ShopServiceImpl:

```java
    @Override
    public Result queryShopById(Long id) {
        if (id == null) {
            return Result.fail("店铺id不能为空");
        }
        String shopCacheKey = CACHE_SHOP_KEY + id;
        //先查缓存
        Object object = redisTemplate.opsForValue().get(shopCacheKey);
        //判空
        if (ObjectUtil.isNotEmpty(object)) {
            //缓存查到 返回
            return Result.ok(object);
        }
        //缓存的空值   缓存的空字符串""
        if (ObjectUtil.equal(object, "")) {
            return Result.fail("店铺信息不存在");
        }
        //尝试加锁
        String lockKey = LOCK_SHOP_KEY + id;
        Boolean ifAbsent = redisTemplate.opsForValue().setIfAbsent(lockKey, id, LOCK_SHOP_TTL, TimeUnit.MINUTES);
        if (!ifAbsent) {
            //未获得锁，轮询
            try {
                TimeUnit.MILLISECONDS.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return queryShopById(id);
        }
        //缓存中没查到  查数据库
        Shop shop = shopMapper.selectById(id);
        if (ObjectUtil.isEmpty(shop)) {
            //解决缓存穿透问题  缓存空对象
            redisTemplate.opsForValue().set(shopCacheKey, "", CACHE_NULL_TTL, TimeUnit.MINUTES);
            return Result.fail("店铺信息不存在");
        }
        //存到缓存中
        redisTemplate.opsForValue().set(shopCacheKey, shop, CACHE_SHOP_TTL, TimeUnit.MINUTES);
        //删除锁
        redisTemplate.delete(lockKey);
        return Result.ok(shop);
    }
```

### 2.逻辑过期方案

方案分析：我们之所以会出现这个缓存击穿问题，主要原因是在于我们对key设置了过期时间，假设我们不设置过期时间，其实就不会有缓存击穿的问题，但是不设置过期时间，这样数据不就一直占用我们内存了吗，我们可以采用逻辑过期方案。

我们把过期时间设置在 redis的value中（expire为到过期时间时的时间戳），注意：这个过期时间并不会直接作用于redis，而是我们后续通过逻辑去处理。

假设线程1去查询缓存，然后从value中判断出来当前的数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞，获得了锁的线程他会开启一个 线程去进行 以前的重构数据的逻辑，直到新开的线程完成这个逻辑后，才释放锁， 而线程1直接进行返回，假设现在线程3过来访问，由于线程线程2持有着锁，所以线程3无法获得锁，线程3也直接返回数据，只有等到新开的线程2把重建数据构建完后，其他线程才能走返回正确的数据。

这种方案巧妙在于，异步的构建缓存，缺点在于在构建完缓存之前，返回的都是脏数据。

![image-20240320220812079](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403202210396.png)

**需求：修改根据id查询商铺的业务，基于逻辑过期方式来解决缓存击穿问题**

思路分析：当用户开始查询redis时，判断是否命中，如果没有命中则直接返回空数据，不查询数据库，而一旦命中后，将value取出，判断value中的过期时间是否满足，如果没有过期，则直接返回redis中的数据，如果过期，则在开启独立线程后直接返回之前的数据，独立线程去重构数据，重构完成后释放互斥锁。

![image-20240321074424249](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403210747154.png)

新建一个实体类RedisData

```java
import lombok.Data;
import java.util.Date;

@Data
public class RedisData {
    private Date expireTime;
    private Object data;
}
```

ShopServiceImpl

```java
    private static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10);

    @Override
    public Result queryShopById(Long id) {
        if (id == null) {
            return Result.fail("店铺id不能为空");
        }
        String shopCacheKey = CACHE_SHOP_KEY + id;
        //先查缓存
        Object object = redisTemplate.opsForValue().get(shopCacheKey);
        //缓存的空值   缓存的空字符串""
        if (ObjectUtil.equal(object, "")) {
            return Result.fail("店铺信息不存在");
        }
        //热点key续期，缓存中没有直接返回
        if (object == null){
            Shop shop = getAndCacheShop(id);
            return Result.ok(shop);
        }
        RedisData redisData = (RedisData) object;
        Shop shop = (Shop) redisData.getData();
        Date expireTime = redisData.getExpireTime();
        //判断是否过期
        if (expireTime.after(new Date())) {
            //没过期
            return Result.ok(shop);
        }
        //尝试加锁
        String lockKey = LOCK_SHOP_KEY + id;
        Boolean ifAbsent = redisTemplate.opsForValue().setIfAbsent(lockKey, id, LOCK_SHOP_TTL, TimeUnit.MINUTES);
        if (ifAbsent) {
            //开启独立线程 重建缓存
            CACHE_REBUILD_EXECUTOR.submit(() -> {
                try {
                    getAndCacheShop(id);
                } catch (Exception e) {
                    e.printStackTrace();
                } finally {
                    redisTemplate.delete(lockKey);
                }
            });
        }
        return Result.ok(shop);
    }

    private Shop getAndCacheShop(Long id) {
        //查询店铺数据
        Shop shop = shopMapper.selectById(id);
        if (ObjectUtil.isNotEmpty(shop)) {
            RedisData dataShop = new RedisData();
            dataShop.setData(shop);
            dataShop.setExpireTime(DateUtil.offsetMinute(new Date(), 10));
            redisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, dataShop);

        } else {
            //解决缓存穿透问题  缓存空对象
            redisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, "", CACHE_NULL_TTL, TimeUnit.MINUTES);
        }
        return shop;
    }
```

## 封装Redis工具类

基于RedisTemplate封装一个缓存工具类，满足下列需求：

- 方法1：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置TTL过期时间
- 方法2：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置逻辑过期时间，用于处理缓

存击穿问题

- 方法3：根据指定的key查询缓存，并反序列化为指定类型，利用缓存空值的方式解决缓存穿透问题
- 方法4：根据指定的key查询缓存，并反序列化为指定类型，需要利用逻辑过期解决缓存击穿问题

将逻辑进行封装

```java
import cn.hutool.core.date.DateUtil;
import cn.hutool.core.util.BooleanUtil;
import cn.hutool.core.util.ObjectUtil;
import com.dongguo.redis.entity.RedisData;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.stereotype.Component;
import java.time.Duration;
import java.util.Date;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.function.Function;

import static com.dongguo.redis.utils.RedisConstants.*;


@Slf4j
@Component
public class CacheClient {

    private final RedisTemplate redisTemplate;

    private static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10);

    public CacheClient(StringRedisTemplate stringRedisTemplate) {
        this.redisTemplate = stringRedisTemplate;
    }

    public void set(String key, Object value, Long time, TimeUnit unit) {
        redisTemplate.opsForValue().set(key, value, time, unit);
    }
    public void set(String key, Object value, Duration duration) {
        redisTemplate.opsForValue().set(key, value, duration);
    }

    /**
     *设置逻辑过期时间
     * @param key
     * @param value
     * @param time
     * @param unit
     */
    public void setWithLogicalExpire(String key, Object value, Long time, TimeUnit unit) {
        // 设置逻辑过期
        RedisData redisData = new RedisData();
        redisData.setData(value);
        redisData.setExpireTime(DateUtil.offsetSecond(new Date(), (int) unit.toSeconds(time)));
        // 写入Redis
        redisTemplate.opsForValue().set(key, redisData);
    }

    /**
     * 缓存空值
     * @param keyPrefix
     * @param id
     * @param dbFallback
     * @param time
     * @param unit
     * @return
     * @param <R>
     * @param <ID>
     */
    public <R, ID> R cacheShopWithNullValue(
            String keyPrefix, ID id, Function<ID, R> dbFallback, Long time, TimeUnit unit) {
        String key = keyPrefix + id;
        // 1.从redis查询商铺缓存
        Object object = redisTemplate.opsForValue().get(key);
        // 2.判断是否存在
        if (ObjectUtil.isNotEmpty(object)) {
            //缓存查到 返回
            return (R) object;
        }
        //3.缓存的空值   缓存的空字符串""
        if (ObjectUtil.equal(object, "")) {
            return null;
        }

        // 4.不存在，根据id查询数据库
        R r = dbFallback.apply(id);
        // 5.不存在，返回错误
        if (r == null) {
            // 将空值写入redis
            redisTemplate.opsForValue().set(key, "", CACHE_NULL_TTL, TimeUnit.MINUTES);
            // 返回错误信息
            return null;
        }
        // 6.存在，写入redis
        this.set(key, r, time, unit);
        return r;
    }

    /**
     * 逻辑过期
     * @param keyPrefix
     * @param id
     * @param dbFallback
     * @param time
     * @param unit
     * @return
     * @param <R>
     * @param <ID>
     */
    public <R, ID> R queryWithLogicalExpire(
            String keyPrefix, ID id, Function<ID, R> dbFallback, Long time, TimeUnit unit) {
        String key = keyPrefix + id;
        // 1.从redis查询商铺缓存
        Object object = redisTemplate.opsForValue().get(key);
        // 2.判断是否存在
        //缓存的空值   缓存的空字符串""
        if (ObjectUtil.equal(object, "")) {
            return null;
        }
        if (ObjectUtil.isEmpty(object)) {
            //3.不存在
            //查询店铺数据
            R r = dbFallback.apply(id);
            if (ObjectUtil.isNotEmpty(r)) {
                this.setWithLogicalExpire(key, r, time, unit);
            } else {
                //解决缓存穿透问题  缓存空对象
                redisTemplate.opsForValue().set(key, "", CACHE_NULL_TTL, TimeUnit.MINUTES);
            }
            return (R) object;
        }
        // 4.命中，需要先把json反序列化为对象
        RedisData redisData = (RedisData) object;
        R r = (R) redisData.getData();
        Date expireTime = redisData.getExpireTime();
        // 5.判断是否过期
        if (expireTime.after(new Date())) {
            // 5.1.未过期，直接返回店铺信息
            return r;
        }
        // 5.2.已过期，需要缓存重建
        // 6.缓存重建
        // 6.1.获取互斥锁
        String lockKey = LOCK_SHOP_KEY + id;
        boolean isLock = tryLock(lockKey);
        // 6.2.判断是否获取锁成功
        if (isLock) {
            // 6.3.成功，开启独立线程，实现缓存重建
            CACHE_REBUILD_EXECUTOR.submit(() -> {
                try {
                    // 查询数据库
                    R newR = dbFallback.apply(id);
                    // 重建缓存
                    this.setWithLogicalExpire(key, newR, time, unit);
                } catch (Exception e) {
                    throw new RuntimeException(e);
                } finally {
                    // 释放锁
                    unlock(lockKey);
                }
            });
        }
        // 6.4.返回过期的商铺信息
        return r;
    }

    /**
     * 互斥锁
     * @param keyPrefix
     * @param id
     * @param dbFallback
     * @param time
     * @param unit
     * @return
     * @param <R>
     * @param <ID>
     */
    public <R, ID> R queryWithMutex(
            String keyPrefix, ID id, Function<ID, R> dbFallback, Long time, TimeUnit unit) {
        String key = keyPrefix + id;
        // 1.从redis查询商铺缓存
        Object object = redisTemplate.opsForValue().get(key);
        //判空
        if (ObjectUtil.isNotEmpty(object)) {
            //缓存查到 返回
            return (R) object;
        }
        //缓存的空值   缓存的空字符串""
        if (ObjectUtil.equal(object, "")) {
            return null;
        }

        // 4.实现缓存重建
        // 4.1.获取互斥锁
        String lockKey = LOCK_SHOP_KEY + id;
        R r;
        try {
            boolean isLock = tryLock(lockKey);
            // 4.2.判断是否获取成功
            if (!isLock) {
                // 4.3.获取锁失败，休眠并重试
               TimeUnit.MILLISECONDS.sleep(100);
                return queryWithMutex(keyPrefix, id, dbFallback, time, unit);
            }
            // 4.4.获取锁成功，根据id查询数据库
            r = dbFallback.apply(id);
            // 5.不存在，返回错误
            if (r == null) {
                // 将空值写入redis
                redisTemplate.opsForValue().set(key, "", CACHE_NULL_TTL, TimeUnit.MINUTES);
                // 返回错误信息
                return null;
            }
            // 6.存在，写入redis
            this.set(key, r, time, unit);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        } finally {
            // 7.释放锁
            unlock(lockKey);
        }
        // 8.返回
        return r;
    }

    /**
     * 加锁
     * @param key
     * @return
     */
    private boolean tryLock(String key) {
        Boolean flag = redisTemplate.opsForValue().setIfAbsent(key, "1", 10, TimeUnit.SECONDS);
        return BooleanUtil.isTrue(flag);
    }

    /**
     * 解锁
     * @param key
     */
    private void unlock(String key) {
        redisTemplate.delete(key);
    }
}
```

# 优惠券秒杀

## 添加优惠卷

每个店铺都可以发布优惠券，分为平价券和特价券。平价券可以任意购买，而特价券需要秒杀抢购：

![image-20240321200423197](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403212049664.png)

tb_voucher表：优惠券的基本信息，优惠金额、使用规则等

tb_seckill_voucher表：优惠券的库存、开始抢购时间，结束抢购时间。特价优惠券才需要填写这些信息

平价卷由于优惠力度并不是很大，所以是可以任意领取

而特价券由于优惠力度大，所以就得限制数量，特价卷除了具有优惠卷的基本信息以外，还具有库存，抢购时间，结束时间等等字段

### 添加平价券

VoucherController

```java
    /**
     * 新增普通券
     * @param voucher 优惠券信息
     * @return 优惠券id
     */
    @Operation(
            summary = "addVoucher",
            description = "新增普通券"
    )
    @PostMapping
    public Result addVoucher(@RequestBody Voucher voucher) {
        voucherService.save(voucher);
        return Result.ok(voucher.getId());
    }
```

### 添加特价券

VoucherServiceImpl

```java
    @Override
    @Transactional
    public void addSeckillVoucher(Voucher voucher) {
        // 保存优惠券
        save(voucher);
        // 保存秒杀信息
        SeckillVoucher seckillVoucher = new SeckillVoucher();
        seckillVoucher.setVoucherId(voucher.getId());
        seckillVoucher.setStock(voucher.getStock());
        seckillVoucher.setBeginTime(voucher.getBeginTime());
        seckillVoucher.setEndTime(voucher.getEndTime());
        seckillVoucherService.save(seckillVoucher);

        //将优惠券库存缓存到redis中
        stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());
    }
```

VoucherController

```java
    /**
     * 新增秒杀券
     * @param voucher 优惠券信息，包含秒杀信息
     * @return 优惠券id
     */
    @Operation(
            summary = "seckill",
            description = "新增秒杀券"
    )
    @PostMapping("/seckill")
    public Result addSeckillVoucher(@RequestBody Voucher voucher) {
        voucherService.addSeckillVoucher(voucher);
        return Result.ok(voucher.getId());
    }
```

## 实现秒杀特价券

![image-20240322073304068](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403220751569.png)

下单核心逻辑分析：

当用户开始进行下单，我们应当去查询优惠卷信息，查询到优惠卷信息，判断是否满足秒杀条件

比如时间是否充足，如果时间充足，则进一步判断库存是否足够，如果两者都满足，则扣减库存，创建订单，然后返回订单id，如果有一个条件不满足则直接结束。

![image-20240322073332533](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403220750660.png)

VoucherServiceImpl：

```java
@Override
@Transactional
public Result seckillVoucher(Long voucherId) {
    //查询优惠券
    SeckillVoucher seckillVoucher = seckillVoucherService.getById(voucherId);
    if (seckillVoucher == null) {
        return Result.fail("优惠券不存在");
    }
    //2判断优惠时间
    Date beginTime = seckillVoucher.getBeginTime();
    Date endTime = seckillVoucher.getEndTime();
    Date now = new Date();
    if (now.before(beginTime)) {
        return Result.fail("该优惠券秒杀时间尚未开始");
    }
    if (now.after(endTime)) {
        return Result.fail("该优惠券秒杀时间已过期");
    }
    //3判断库存 进行扣减库存
    Integer stock = seckillVoucher.getStock();
    if (stock < 1) {
        return Result.fail("该优惠券已被抢光");
    }
    Long userId = UserThreadLocalCache.getUser().getId();

    boolean result = seckillVoucherService.lambdaUpdate().setSql("stock = stock -1")
            .eq(SeckillVoucher::getVoucherId, voucherId)
            .update();
    if (!result) {
        return Result.fail("该优惠券库存扣减失败");
    }
    //4.创建订单
    VoucherOrder voucherOrder = new VoucherOrder();
    // 4.1.订单id
    long orderId = SnowflakeIdUtil.getNextId();
    voucherOrder.setId(orderId);
    // 4.2.用户id
    voucherOrder.setUserId(userId);
    // 4.3.代金券id
    voucherOrder.setVoucherId(voucherId);
    //订单状态默认生成为未支付 可以不写
    voucherOrder.setStatus(1);
    save(voucherOrder);
    return Result.ok(orderId);
}
```

VoucherController：

```java
    @GetMapping("/seckill/{voucherId}")
    public Result seckillVoucher(@PathVariable("voucherId") Long voucherId) {
        return voucherOrderService.seckillVoucher(voucherId);
    }
```

### 库存超卖问题分析

假设线程1过来查询库存，判断出来库存大于1，正准备去扣减库存，但是还没有来得及去扣减，此时线程2过来，线程2也去查询库存，发现这个数量一定也大于1，那么这两个线程都会去扣减库存，最终多个线程相当于一起去扣减库存，此时就会出现库存的超卖问题。

![image-20240322152941551](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403222104679.png)

### 乐观锁解决超卖问题

在操作时，对版本号进行+1 操作，然后要求version 如果是1 的情况下，才能操作，那么第一个线程在操作后，数据库中的version变成了2，但是他自己满足version=1 ，所以没有问题，此时线程2执行，线程2 最后也需要加上条件version =1 ，但是现在由于线程1已经操作过了，所以线程2，操作时就不满足version=1 的条件了，所以线程2无法执行成功

![image-20240322153239585](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403222104453.png)

根据以上思路，我们可以在扣减库存时，比较当前库存和我们之前获得的是否一致

```java
        boolean result = seckillVoucherService.lambdaUpdate().setSql("stock = stock -1")
                .eq(SeckillVoucher::getVoucherId, voucherId)
                .eq(SeckillVoucher::getStock, stock)
                .update();
```

但是在使用乐观锁过程中假设100个线程同时都拿到了100的库存，然后大家一起去进行扣减，100个人中只有1个人能扣减成功，其他的人在处理时，他们在扣减时，库存已经被修改过了，所以此时其他线程都会失败。所以我们的乐观锁需要变一下，改成stock大于0 即可

```java
        boolean result = seckillVoucherService.lambdaUpdate().setSql("stock = stock -1")
                .eq(SeckillVoucher::getVoucherId, voucherId)
//                .eq(SeckillVoucher::getStock, stock)
                .gt(SeckillVoucher::getStock, 0)
                .update();
```

### 优惠券秒杀-一人一单

对于特价券，一个用户只能下一个单

具体操作逻辑如下：比如时间是否充足，如果时间充足，则进一步判断库存是否足够，然后再根据优惠卷id和用户id查询是否已经下过这个订单，如果下过这个订单，则不再下单，否则进行下单

![image-20240322154649303](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403222103659.png)

VoucherServiceImpl：

```java
    @Override
    @Transactional
    public Result seckillVoucher(Long voucherId) {
        //查询优惠券
        SeckillVoucher seckillVoucher = seckillVoucherService.getById(voucherId);
        if (seckillVoucher == null) {
            return Result.fail("优惠券不存在");
        }
        //2判断优惠时间
        Date beginTime = seckillVoucher.getBeginTime();
        Date endTime = seckillVoucher.getEndTime();
        Date now = new Date();
        if (now.before(beginTime)) {
            return Result.fail("该优惠券秒杀时间尚未开始");
        }
        if (now.after(endTime)) {
            return Result.fail("该优惠券秒杀时间已过期");
        }
        //3判断库存 进行扣减库存
        Integer stock = seckillVoucher.getStock();
        if (stock < 1) {
            return Result.fail("该优惠券已被抢光");
        }
        //查询该用户是否抢购过这个优惠券
        Long userId = UserThreadLocalCache.getUser().getId();

        Long count = lambdaQuery().select().eq(VoucherOrder::getVoucherId, voucherId)
                .eq(VoucherOrder::getUserId, userId)
                .count();
        if (count > 0) {
            return Result.fail("该优惠券一人只能抢购一个");
        }
        boolean result = seckillVoucherService.lambdaUpdate().setSql("stock = stock -1")
                .eq(SeckillVoucher::getVoucherId, voucherId)
                .gt(SeckillVoucher::getStock, 0)
                .update();
        if (!result) {
            return Result.fail("该优惠券库存扣减失败");
        }
        //4.创建订单
        VoucherOrder voucherOrder = new VoucherOrder();
        // 4.1.订单id
        long orderId = SnowflakeIdUtil.getNextId();
        voucherOrder.setId(orderId);
        // 4.2.用户id
        voucherOrder.setUserId(userId);
        // 4.3.代金券id
        voucherOrder.setVoucherId(voucherId);
        //订单状态默认生成为未支付 可以不写
        voucherOrder.setStatus(1);
        save(voucherOrder);
        return Result.ok(orderId);
    }
```

### 订单创建时的并发问题

如果两个线程同时检查到库存大于0，并成功扣减库存，它们都会尝试创建订单。如果订单创建没有适当的并发控制，可能会导致重复创建订单。

封装了一个createVoucherOrder方法，同时为了确保他线程安全，在方法上添加了一把synchronized 锁

VoucherServiceImpl：

```java
    @Resource
    private IVoucherOrderService voucherOrderService;   

	@Override
    public Result seckillVoucher(Long voucherId) {
        //查询优惠券
        SeckillVoucher seckillVoucher = seckillVoucherService.getById(voucherId);
        if (seckillVoucher == null) {
            return Result.fail("优惠券不存在");
        }
        //2判断优惠时间
        Date beginTime = seckillVoucher.getBeginTime();
        Date endTime = seckillVoucher.getEndTime();
        Date now = new Date();
        if (now.before(beginTime)) {
            return Result.fail("该优惠券秒杀时间尚未开始");
        }
        if (now.after(endTime)) {
            return Result.fail("该优惠券秒杀时间已过期");
        }
        return voucherOrderService.createVoucherOrder(seckillVoucher);
    }
```

VoucherOrderServiceImpl:

```java
    /**
     * synchronized单机锁
     *
     * @param seckillVoucher
     * @return
     */
    @Transactional
    @Override
    public synchronized Result createVoucherOrder(SeckillVoucher seckillVoucher) {
        Long voucherId = seckillVoucher.getVoucherId();
        //3判断库存 进行扣减库存
        Integer stock = seckillVoucher.getStock();
        if (stock < 1) {
            return Result.fail("该优惠券已被抢光");
        }
        //查询该用户是否抢购过这个优惠券
        Long userId = UserThreadLocalCache.getUser().getId();

        Long count = lambdaQuery().select().eq(VoucherOrder::getVoucherId, voucherId)
                .eq(VoucherOrder::getUserId, userId)
                .count();
        if (count > 0) {
            return Result.fail("该优惠券一人只能抢购一个");
        }
        boolean result = seckillVoucherService.lambdaUpdate().setSql("stock = stock -1")
                .eq(SeckillVoucher::getVoucherId, voucherId)
                .gt(SeckillVoucher::getStock, 0)
                .update();
        if (!result) {
            return Result.fail("该优惠券库存扣减失败");
        }
        //4.创建订单
        VoucherOrder voucherOrder = new VoucherOrder();
        // 4.1.订单id
        long orderId = SnowflakeIdUtil.getNextId();
        voucherOrder.setId(orderId);
        // 4.2.用户id
        voucherOrder.setUserId(userId);
        // 4.3.代金券id
        voucherOrder.setVoucherId(voucherId);
        //订单状态默认生成为未支付 可以不写
        voucherOrder.setStatus(1);
        save(voucherOrder);
        return Result.ok(orderId);
    }
```



### 集群环境下的并发问题

通过加锁可以解决在单机情况下的一人一单安全问题，但是在集群模式下就不行了。

1.、我们将服务启动两份，端口分别为8081和8082：

![image-20240322191343421](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403222103029.png)

手动将port=8082覆盖

![image-20240322191305306](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403222103074.png)

2、然后修改nginx的conf目录下的nginx.conf文件，配置反向代理和负载均衡：

```xml
    server {
        listen       80;
        server_name  localhost;

        location / {
            root   html;
            index  index.html index.htm;
        }

        location /api {  
            default_type  application/json;
            #internal;  
            keepalive_timeout   30s;  
            keepalive_requests  1000;  
            #支持keep-alive  
            proxy_http_version 1.1;  
            rewrite /api(/.*) $1 break;  
            proxy_pass_request_headers on;
            proxy_next_upstream error timeout;  
            proxy_pass http://dianping;
        }

        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }

    }
   	upstream dianping {
           server 127.0.0.1:8081 max_fails=5 fail_timeout=10s weight=1;
           server 127.0.0.1:8082 max_fails=5 fail_timeout=10s weight=1;
   	}

```

3.启动nginx: `start nginx.exe`

因为header中需要携带token，可以使用postman执行两次请求http://127.0.0.1/api/voucher-order/seckill/15

![image-20240322201305347](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403222103627.png)

4.在判断优惠券订单数的代码打上线程级别断点

![image-20240322203225710](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403222103433.png)

5.第一个请求到8081

![image-20240322203357744](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403222103597.png)

6.第二个请求到8082

![image-20240322203419430](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403222103882.png)

此时两个请求都判断没有下过订单。放开断点，执行结束。

7.查看数据库，相同优惠券，1011用户下了两次订单。

![image-20240322203612072](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403222103885.png)

**有关锁失效原因分析**

由于现在我们部署了多个tomcat，每个tomcat都有一个属于自己的jvm，那么假设在服务器A的tomcat内部，有两个线程，这两个线程由于使用的是同一份代码，那么他们的锁对象是同一个，是可以实现互斥的，但是如果现在是服务器B的tomcat内部，又有两个线程，但是他们的锁对象写的虽然和服务器A一样，但是锁对象却不是同一个，所以线程3和线程4可以实现互斥，但是却无法和线程1和线程2实现互斥，这就是 集群环境下，syn锁失效的原因，在这种情况下，我们就需要使用分布式锁来解决这个问题。

![image-20240322165705338](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403222103806.png)

### Redis分布式锁

分布式锁的核心思想就是让大家都使用同一把锁，只要大家使用的是同一把锁，那么我们就能锁住线程，不让线程进行，让程序串行执行，这就是分布式锁的核心思路

![image-20240322165738803](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403222103621.png)

**Redis分布式锁的实现核心思路**

我们利用redis 的setNx 方法，当有多个线程进入时，我们就利用该方法，第一个线程进入时，redis 中就有这个key 了，返回了1，如果结果是1，则表示他抢到了锁，那么他去执行业务，然后再删除锁，退出锁逻辑，没有抢到锁的，等待一定时间后重试即可

![image-20240322213208410](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403222132935.png)

RedisDistributedLock：redis实现Lock接口规范，实现分布式锁。

```java
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.script.DefaultRedisScript;
import java.util.Collections;
import java.util.Timer;
import java.util.TimerTask;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;

/**
 * Redis分布式锁
 * lua脚本实现分布式锁的可重入性，实现Lock接口
 */
@Slf4j
public class RedisDistributedLock implements Lock {

    private RedisTemplate redisTemplate;
    private String key;
    private String value;
    private Long expire;

    /**
     * 默认过期时间30秒
     *
     * @param redisTemplate
     * @param key
     * @param uuid
     */
    public RedisDistributedLock(RedisTemplate redisTemplate, String key, String uuid) {
        this.redisTemplate = redisTemplate;
        this.key = key;
        //同一个实例uuid相同，不同线程对应不同的ThreadId
        this.value = uuid + ":" + Thread.currentThread().getId();
        this.expire = 30L;
    }

    /**
     * 加锁方法
     * 阻塞方法。如果当前线程未持有锁，它会一直等待，直到获取到锁为止。
     * 这里简化lock方法直接调用tryLock方法
     */
    @Override
    public void lock() {
        tryLock();
    }

    /**
     * 非阻塞方法。如果当前线程能够立即获取到锁，则返回true；如果锁被其他线程持有，则立即返回false
     *
     * @return
     */
    @Override
    public boolean tryLock() {
        return tryLock(expire, TimeUnit.SECONDS);

    }

    /**
     * 真正调用的加锁方法
     *
     * @param time the maximum time to wait for the lock
     * @param unit the time unit of the {@code time} argument
     * @return
     */
    @Override
    public boolean tryLock(long time, TimeUnit unit) {
        //将过期时间转换为秒
        this.expire = unit.toSeconds(time);
        String script =
                "if redis.call('exists', KEYS[1]) == 0 or redis.call('hexists', KEYS[1], ARGV[1]) == 1 then  " +
                        "    redis.call('hincrby', KEYS[1], ARGV[1], 1)  " +
                        "    redis.call('expire', KEYS[1], ARGV[2])  " +
                        "    return 1  " +
                        "else  " +
                        "    return 0  " +
                        "end";
        while (!(Boolean) redisTemplate.execute(new DefaultRedisScript<>(script, Boolean.class), Collections.singletonList(key), value, expire)) {
            try {
                TimeUnit.SECONDS.sleep(10);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
        log.info("lock()   key:{}, value:{}", key, value);

        //新建一个后台扫描程序，监测key的过期时间，每过expire/3,实现续期expire
        reExpire();
        return true;
    }

    private void reExpire() {
        String script =
                "if redis.call('HEXISTS', KEYS[1], ARGV[1]) == 1 then  " +
                        "    return redis.call('expire', KEYS[1], ARGV[2])  " +
                        "else  " +
                        "    return 0  " +
                        "end";
        new Timer().schedule(new TimerTask() {
            @Override
            public void run() {
                if ((Boolean) redisTemplate.execute(new DefaultRedisScript<>(script, Boolean.class), Collections.singletonList(key), value, expire)) {
                    log.info("自动续期  key:{}, value:{}", key, value);
                    reExpire();
                }
                //key不存在，退出定时任务
                cancel();
            }
            //延迟时间 毫秒
        }, (this.expire * 1000) / 3);
    }

    /**
     * 解锁方法
     */
    @Override
    public void unlock() {
        String script =
                "if redis.call('HEXISTS', KEYS[1], ARGV[1]) == 0 then  " +
                        "    return nil  " +
                        "elseif redis.call('HINCRBY', KEYS[1], ARGV[1], -1) == 0 then  " +
                        "    return redis.call('del', KEYS[1])  " +
                        "else  " +
                        "    return 0  " +
                        "end";
        log.info("unlock()   key:{}, value:{}", key, value);
        Object flag = redisTemplate.execute(new DefaultRedisScript<>(script, Long.class), Collections.singletonList(key), value);
        /**
         * 即返回nil
         */
        if (null == flag) {
            throw new RuntimeException("this lock doesn't exists!");
        }
    }

    @Override
    public void lockInterruptibly() throws InterruptedException {

    }

    @Override
    public Condition newCondition() {
        return null;
    }
}
```

DistributedLockFactory：创建redis分布式锁的工厂类

```java
import cn.hutool.core.util.IdUtil;
import cn.hutool.core.util.StrUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Component;
import java.util.concurrent.locks.Lock;

/**
 * 创建redis分布式锁的工厂类
 */
@Component
public class DistributedLockFactory {
    @Autowired
    private RedisTemplate redisTemplate;
    private String uuid;
    public DistributedLockFactory() {
        //每个实例对应一个全局唯一uuid
        this.uuid = IdUtil.fastUUID();
    }

    public Lock getDistributedLock(String lockType, String key) {
        if (StrUtil.isBlank(lockType)) {
            return null;
        }
        if ("redis".equalsIgnoreCase(lockType)) {
            return new RedisDistributedLock(redisTemplate, key, uuid);
        }
        return null;
    }
}
```

修改业务代码

VoucherServiceImpl:

```java
    @Resource
    private DistributedLockFactory distributedLockFactory;
    @Resource
    private IVoucherOrderService voucherOrderService;

    @Override
    public Result seckillVoucher(Long voucherId) {
        //查询优惠券
        SeckillVoucher seckillVoucher = seckillVoucherService.getById(voucherId);
        if (seckillVoucher == null) {
            return Result.fail("优惠券不存在");
        }
        //2判断优惠时间
        Date beginTime = seckillVoucher.getBeginTime();
        Date endTime = seckillVoucher.getEndTime();
        Date now = new Date();
        if (now.before(beginTime)) {
            return Result.fail("该优惠券秒杀时间尚未开始");
        }
        if (now.after(endTime)) {
            return Result.fail("该优惠券秒杀时间已过期");
        }
        Long userId = UserThreadLocalCache.getUser().getId();
        Lock lock = distributedLockFactory.getDistributedLock("redis", LOCK_VOUCHER_ORDER_KEY + userId + ":" + voucherId);
        lock.lock();
        Result result;
        try {
           result = voucherOrderService.createVoucherOrder(seckillVoucher, userId);
        } finally {
            lock.unlock();
        }
        return result;
    }

```

VoucherOrderServiceImpl:

```java
 /**
     * @param seckillVoucher
     * @return
     */
    @Transactional
    @Override
    public Result createVoucherOrder(SeckillVoucher seckillVoucher, Long userId) {
        Long voucherId = seckillVoucher.getVoucherId();
        //3判断库存 进行扣减库存
        Integer stock = seckillVoucher.getStock();
        if (stock < 1) {
            return Result.fail("该优惠券已被抢光");
        }
        //查询该用户是否抢购过这个优惠券


        Long count = lambdaQuery().select().eq(VoucherOrder::getVoucherId, voucherId)
                .eq(VoucherOrder::getUserId, userId)
                .count();
        if (count > 0) {
            return Result.fail("该优惠券一人只能抢购一个");
        }
        boolean result = seckillVoucherService.lambdaUpdate().setSql("stock = stock -1")
                .eq(SeckillVoucher::getVoucherId, voucherId)
                .gt(SeckillVoucher::getStock, 0)
                .update();
        if (!result) {
            return Result.fail("该优惠券库存扣减失败");
        }
        //4.创建订单
        VoucherOrder voucherOrder = new VoucherOrder();
        // 4.1.订单id
        long orderId = SnowflakeIdUtil.getNextId();
        voucherOrder.setId(orderId);
        // 4.2.用户id
        voucherOrder.setUserId(userId);
        // 4.3.代金券id
        voucherOrder.setVoucherId(voucherId);
        //订单状态默认生成为未支付 可以不写
        voucherOrder.setStatus(1);
        save(voucherOrder);
        return Result.ok(orderId);
    }
```



### 分布式锁-redission

虽然使用redis实现了分布式锁的可重入性和超时续期的功能，但是单机redis存在单点故障问题，如果Redis提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，从机上位，就可能出现锁丢失问题。

![image-20240323070708538](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403242038353.png)







为了解决这个问题，redission提出来了RedLock算法为了解决数据不一致的问题，直接舍弃了异步复制，只是用master节点，舍弃slave节点，保证可用性。

加锁：依次尝试从N个master实例获取锁，客户端设置一个超时时间，防止客户端与一台宕机的reids主节点获取锁导致长期处于阻塞状态，如果一个实例不可用，客户端会尝试与其他Redis实例请求获取锁。

客户端只有在满足一下两个条件时才认为加锁成功：1.至少在N/2 + 1个redis实例上获取到锁；2.客户端获取锁的总耗时没有超过锁的有效时间。

解锁：在所有实例上进行解锁，即使某些redis实例没有加锁成功。

![image-20240323071055567](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403242038937.png)

Redisson中的RedLock实现是基于MultiLock的概念，将多个锁合并为一个大锁，对一个大锁进行统一的申请加锁以及释放锁。





1.pom引入Redisson依赖

```xml
		<dependency>
			<groupId>org.redisson</groupId>
			<artifactId>redisson</artifactId>
		</dependency>
```

2.使用三台实例实现RedLock算法的Redisson分布式锁，这三台实例都是完全独立的。

| IP              | PORT | 角色   |
| --------------- | ---- | ------ |
| 192.168.122.132 | 7001 | master |
| 192.168.122.133 | 7002 | master |
| 192.168.122.134 | 7003 | master |

3.RedisConfig配置类

```java
import org.redisson.Redisson;
import org.redisson.api.RedissonClient;
import org.redisson.config.Config;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class RedissonConfig {


    /**
     * RedLock 3个各自独立的master
     * @return
     */
    @Bean("redissonClient1")
    RedissonClient redissonClient1(){
        Config config = new Config();
        config.useSingleServer().setAddress("redis://192.168.122.132:7001").setPassword("root");
        return Redisson.create(config);
    }
    @Bean("redissonClient2")
    RedissonClient redissonClient2(){
        Config config = new Config();
        config.useSingleServer().setAddress("redis://192.168.122.133:7002").setPassword("root");
        return Redisson.create(config);
    }

    @Bean("redissonClient3")
    RedissonClient redissonClient3(){
        Config config = new Config();
        config.useSingleServer().setAddress("redis://192.168.122.134:7003").setPassword("root");
        return Redisson.create(config);
    }
}
```

业务代码只需要修改创建锁的方式就可以。

VoucherOrderServiceImpl：

```java
    /**
     * redisson分布式锁
     */
    @Resource
    private RedissonClient redissonClient1;
    @Resource
    private RedissonClient redissonClient2;
    @Resource
    private RedissonClient redissonClient3;

    @Override
    public Result seckillVoucher(Long voucherId) {
        //查询优惠券
        SeckillVoucher seckillVoucher = seckillVoucherService.getById(voucherId);
        if (seckillVoucher == null) {
            return Result.fail("优惠券不存在");
        }
        //2判断优惠时间
        Date beginTime = seckillVoucher.getBeginTime();
        Date endTime = seckillVoucher.getEndTime();
        Date now = new Date();
        if (now.before(beginTime)) {
            return Result.fail("该优惠券秒杀时间尚未开始");
        }
        if (now.after(endTime)) {
            return Result.fail("该优惠券秒杀时间已过期");
        }
        Long userId = UserThreadLocalCache.getUser().getId();
        String key = LOCK_VOUCHER_ORDER_KEY + userId + ":" + voucherId;
        RLock lock1 = redissonClient1.getLock(key);
        RLock lock2 = redissonClient2.getLock(key);
        RLock lock3 = redissonClient3.getLock(key);
        RedissonRedLock redLock = new RedissonRedLock(lock1, lock2, lock3);
        redLock.lock();
        Result result;
        try {
            result = voucherOrderService.createVoucherOrder(seckillVoucher, userId);
        } finally {
            redLock.unlock();
        }
        return result;
    }
```

VoucherOrderServiceImpl

```java
    @Transactional
    @Override
    public Result createVoucherOrder(SeckillVoucher seckillVoucher, Long userId) {
        Long voucherId = seckillVoucher.getVoucherId();
        //3判断库存 进行扣减库存
        Integer stock = seckillVoucher.getStock();
        if (stock < 1) {
            return Result.fail("该优惠券已被抢光");
        }
        //查询该用户是否抢购过这个优惠券

        Long count = lambdaQuery().select().eq(VoucherOrder::getVoucherId, voucherId)
                .eq(VoucherOrder::getUserId, userId)
                .count();
        if (count > 0) {
            return Result.fail("该优惠券一人只能抢购一个");
        }
        boolean result = seckillVoucherService.lambdaUpdate().setSql("stock = stock -1")
                .eq(SeckillVoucher::getVoucherId, voucherId)
                .gt(SeckillVoucher::getStock, 0)
                .update();
        if (!result) {
            return Result.fail("该优惠券库存扣减失败");
        }
        //4.创建订单
        VoucherOrder voucherOrder = new VoucherOrder();
        // 4.1.订单id
        long orderId = SnowflakeIdUtil.getNextId();
        voucherOrder.setId(orderId);
        // 4.2.用户id
        voucherOrder.setUserId(userId);
        // 4.3.代金券id
        voucherOrder.setVoucherId(voucherId);
        //订单状态默认生成为未支付 可以不写
        voucherOrder.setStatus(1);
        save(voucherOrder);
        return Result.ok(orderId);
    }
```

## 秒杀优化

优化方案：我们将耗时比较短的逻辑判断放入到redis中，比如是否库存足够，比如是否一人一单，这样的操作，只要这种逻辑可以完成，就意味着我们是一定可以下单完成的，我们只需要进行快速的逻辑判断，根本就不用等下单逻辑走完，我们直接给用户返回成功。然后把这些信息丢到异步queue中去慢慢的同步，



**基于Redis的Stream结构作为消息队列，实现异步秒杀下单**

需求：

- 创建一个Stream类型的消息队列，名为stream.orders
- 修改之前的秒杀下单Lua脚本，在认定有抢购资格后，直接向stream.orders中添加消息，内容包含voucherId、userId、orderId
- 项目启动时，开启一个线程任务，尝试获取stream.orders中的消息，完成下单

1.stream: stream.orders  组: g1

```shell
127.0.0.1:6379> XGROUP CREATE stream.orders g1 0 MKSTREAM
OK
```

2.seckill.lua完成判断及发送消息队列

```lua
---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by dongguo.
--- DateTime: 2022/12/4 19:16
---
-- 1.参数列表
-- 1.1.优惠券id
local voucherId = ARGV[1]
-- 1.2.用户id
local userId = ARGV[2]
-- 1.3.订单id
local orderId = ARGV[3]

-- 2.数据key
-- 2.1.库存key
local stockKey = 'seckill:stock:' .. voucherId
-- 2.2.订单key
local orderKey = 'seckill:order:' .. voucherId

-- 3.脚本业务
-- 3.1.判断库存是否充足 get stockKey
if(tonumber(redis.call('get', stockKey)) <= 0) then
    -- 3.2.库存不足，返回1
    return 1
end
-- 3.2.判断用户是否下单 SISMEMBER orderKey userId
if(redis.call('sismember', orderKey, userId) == 1) then
    -- 3.3.存在，说明是重复下单，返回2
    return 2
end
-- 3.4.扣库存 incrby stockKey -1
redis.call('incrby', stockKey, -1)
-- 3.5.下单（保存用户）sadd orderKey userId
redis.call('sadd', orderKey, userId)
-- 3.6.发送消息到队列中， XADD stream.orders * k1 v1 k2 v2 ...
redis.call('xadd', 'stream.orders', '*', 'userId', userId, 'voucherId', voucherId, 'id', orderId)
return 0
```

3.只需要操作redis，发送消息

VoucherServiceImpl

```java
    private static final String CLASS_PATH = "redis/seckill.lua";
    private static final DefaultRedisScript<Long> SECKILL_SCRIPT;

    static {
        SECKILL_SCRIPT = new DefaultRedisScript<>();
        SECKILL_SCRIPT.setLocation(new ClassPathResource(CLASS_PATH));
        SECKILL_SCRIPT.setResultType(Long.class);
    }
    @Override
    public Result seckillVoucher(Long voucherId) {
        Long userId = UserThreadLocalCache.getUser().getId();
        //返回订单id
        long orderId = SnowflakeIdUtil.getNextId();
        //1执行lua脚本
        Long result = stringRedisTemplate.execute(SECKILL_SCRIPT,
                Collections.emptyList(),
                //lua脚本传的是字符串
                voucherId.toString(), userId.toString(), String.valueOf(orderId));
        //判断结果是否为0  第一次购买
        int r = result.intValue();
        if (r != 0) {
            return Result.fail(r == 1 ? "库存不足" : "不能重复下单");
        }
        return Result.ok(userId);
    }
```

4.消息队列消息完成数据库库存扣减及下单

VoucherServiceImpl

```java
    /**
     * stream消息队列
     */
    
    //异步处理线程池
    private static final ExecutorService SECKILL_ORDER_EXECUTOR = Executors.newSingleThreadExecutor();

    //在类初始化之后执行，因为当这个类初始化好了之后，随时都是有可能要执行的
    @PostConstruct
    private void init() {
        SECKILL_ORDER_EXECUTOR.submit(new VoucherOrderHandler());
    }

    private class VoucherOrderHandler implements Runnable {
        String queueName = "stream.orders";

        @Override
        public void run() {
            while (true) {
                try {
                    // 1.获取消息队列中的订单信息
                    List<MapRecord<String, Object, Object>> list = stringRedisTemplate.opsForStream().read(Consumer.from("g1", "c1"),
                            StreamReadOptions.empty().count(1).block(Duration.ofSeconds(2)),
                            StreamOffset.create(queueName, ReadOffset.lastConsumed())
                    );
                    if (CollUtil.isEmpty(list)) {
                        continue;
                    }
                    //解析消息 获取订单
                    MapRecord<String, Object, Object> record = list.get(0);
                    Map<Object, Object> value = record.getValue();
                    VoucherOrder voucherOrder = BeanUtil.fillBeanWithMap(value, new VoucherOrder(), true);
                    // 2.创建订单
                    voucherOrderService.createVoucherOrder(voucherOrder);
                    //返回ack
                    stringRedisTemplate.opsForStream().acknowledge(queueName, "g1", record.getId());
                } catch (Exception e) {
                    log.error("处理订单异常", e);
                    //处理异常消息
                    handlePendingList();
                }
            }
        }

        private void handlePendingList() {
            while (true) {
                try {
                    // 1.获取pending-list中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 0
                    List<MapRecord<String, Object, Object>> list = stringRedisTemplate.opsForStream().read(
                            Consumer.from("g1", "c1"),
                            StreamReadOptions.empty().count(1),
                            StreamOffset.create(queueName, ReadOffset.from("0"))
                    );
                    // 2.判断订单信息是否为空
                    if (list == null || list.isEmpty()) {
                        // 如果为null，说明没有异常消息，结束循环
                        break;
                    }
                    // 解析数据
                    MapRecord<String, Object, Object> record = list.get(0);
                    Map<Object, Object> value = record.getValue();
                    VoucherOrder voucherOrder = BeanUtil.fillBeanWithMap(value, new VoucherOrder(), true);
                    // 3.创建订单
                    voucherOrderService.createVoucherOrder(voucherOrder);
                    // 4.确认消息 XACK
                    stringRedisTemplate.opsForStream().acknowledge("s1", "g1", record.getId());
                } catch (Exception e) {
                    log.error("处理pendding订单异常", e);
                    try {
                        Thread.sleep(20);
                    } catch (Exception ex) {
                        ex.printStackTrace();
                    }
                }
            }
        }
    }
```

# 达人探店

## 达人探店-发布探店笔记

探店笔记类似点评网站的评价，往往是图文结合。

对应的表有两个：

tb_blog：探店笔记表，包含笔记中的标题、文字、图片等

tb_blog_comments：其他用户对探店笔记的评价

![image-20240324085200667](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403242038858.png)

### 上传照片

1.使用OSS引入依赖

```xml
        <dependency>
            <groupId>com.aliyun.oss</groupId>
            <artifactId>aliyun-sdk-oss</artifactId>
        </dependency>
```

2.yml配置,修改对应参数

```yaml
oss:
  endpoint: ${endpoint}
  accessKeyId: ${accessKeyId}
  accessKeySecret: ${accessKeySecret}
  bucketName: ${bucketName}
```

3.OssProperties实体类

```java
import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

@Data
@Component
@ConfigurationProperties(prefix = "oss")
public class OssProperties  {

    private String endpoint;

    private String accessKeyId;

    private String accessKeySecret;

    private String bucketName;
}
```

OssFileClient：oss方法

```java
import cn.hutool.core.date.DateTime;
import cn.hutool.core.io.IoUtil;
import cn.hutool.core.lang.UUID;
import cn.hutool.core.util.StrUtil;
import com.aliyun.oss.OSS;
import com.aliyun.oss.OSSClientBuilder;
import com.aliyun.oss.model.OSSObject;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.web.multipart.MultipartFile;
import java.io.*;
import java.net.URLEncoder;
import java.util.Collection;


/**
 * @author admin
 * oss上传文件
 */
public class OssFileClient {
    private final OssProperties config;
    private final OSS client;

    private final String publicUrl = "https://yygh-dongguo.oss-cn-beijing.aliyuncs.com/";

    public OssFileClient(OssProperties config) {
        this.config = config;
        this.client = new OSSClientBuilder().build(config.getEndpoint(), config.getAccessKeyId(), config.getAccessKeySecret());

    }

    /**
     * 上传文件
     *
     * @param file 文件
     * @return result
     */
    public String uploadFile(MultipartFile file) throws IOException {
        // 上传文件流。
        InputStream inputStream = file.getInputStream();
        String fileName = file.getOriginalFilename();
        //按照当前日期，创建文件夹，上传到创建文件夹里面
        //  2021/02/02/01.jpg
        String uuid = UUID.randomUUID().toString().replaceAll("-", "");
        String timeUrl = new DateTime().toString("yyyy/MM/dd");
        fileName = timeUrl + "/" + uuid + fileName;
        //调用方法实现上传
        try {
            client.putObject(config.getBucketName(), fileName, inputStream);
            // https://yygh-atguigu.oss-cn-beijing.aliyuncs.com/01.jpg
            //返回
            return "https://" + config.getBucketName() + "." + config.getEndpoint() + "/" + fileName;
        } finally {
            client.shutdown();
        }
    }

    /**
     * 删除文件
     *
     * @param fileName 参数对象  filename: 2024/03/24/1711241401394.jpg
     * @return result
     */
    public void deleteByFileName(String fileName) {
        if (fileName.startsWith(publicUrl)) {
            fileName = fileName.replace(publicUrl, StrUtil.EMPTY);
        }
        try {
            client.deleteObject(config.getBucketName(), fileName);
        } finally {
            client.shutdown();
        }
    }

    /**
     * 重命名文件
     *
     * @param fileName 文件名称
     * @return result
     */

    public String renameFile(String fileName) {
        if (fileName.startsWith(publicUrl)) {
            fileName = fileName.replace(publicUrl, StrUtil.EMPTY);
        }
        String oldFileName = fileName;
        //2024/03/24/1711241401394.jpg
        int lastSlashIndex = fileName.lastIndexOf('.');
        if (lastSlashIndex != -1) {
            //1711241401394.jpg
            fileName = fileName.substring(lastSlashIndex);
        }
        String uuid = UUID.randomUUID().toString().replaceAll("-", "");
        String timeUrl = new DateTime().toString("yyyy/MM/dd");
        String newFileName = timeUrl + "/" + uuid + fileName;
        client.copyObject(config.getBucketName(), oldFileName, config.getBucketName(), newFileName);
        deleteByFileName(oldFileName);
        return "https://" + config.getBucketName() + "." + config.getEndpoint() + "/" + newFileName;
    }

    /**
     * 获取文件
     *
     * @param fileName 参数对象
     * @return 文件流，可能为空
     */

    public void downFile(String fileName, HttpServletResponse response) throws Exception {
        OSSObject object;
        try {
            if (fileName.startsWith(publicUrl)) {
                fileName = fileName.replace(publicUrl, StrUtil.EMPTY);
            }
            object = client.getObject(config.getBucketName(), fileName);
            int lastSlashIndex = fileName.lastIndexOf('/');
            if (lastSlashIndex != -1) {
                //1711241401394.jpg
                fileName = fileName.substring(lastSlashIndex + 1);
            }
            byte[] bytes = IoUtil.readBytes(object.getObjectContent());

            // 清空response
            response.reset();
            // 设置response的Header
            response.setCharacterEncoding("UTF-8");
            //Content-Disposition的作用：告知浏览器以何种方式显示响应返回的文件，用浏览器打开还是以附件的形式下载到本地保存
            //attachment表示以附件方式下载 inline表示在线打开 "Content-Disposition: inline; filename=文件名.mp3"
            // filename表示文件的默认名称，因为网络传输只支持URL编码的相关支付，因此需要将文件名URL编码后进行传输,前端收到后需要反编码才能获取到真正的名称
            response.addHeader("Content-Disposition", "attachment;filename=" + URLEncoder.encode(fileName, "UTF-8"));
            // 告知浏览器文件的大小
            OutputStream outputStream = new BufferedOutputStream(response.getOutputStream());
            response.setContentType("application/octet-stream");
            outputStream.write(bytes);
            outputStream.flush();
        } catch (IOException ex) {
            ex.printStackTrace();
        } finally {
            client.shutdown();
        }
    }

    /**
     * 获取文件二进制
     *
     * @param fileName 参数对象
     * @return 文件流，可能为空
     */

    public byte[] getFileBytes(String fileName) {
        OSSObject object;
        try {
            //去除Url前缀
            if (fileName.startsWith(publicUrl)) {
                fileName = fileName.replace(publicUrl, StrUtil.EMPTY);
            }
            object = client.getObject(config.getBucketName(), fileName);
            byte[] bytes = IoUtil.readBytes(object.getObjectContent());
            return bytes;
        } finally {
            client.shutdown();
        }
    }

    /**
     * 批量删除
     * @param urls
     */
    public void batchDeleteFileByUrl(Collection<String> urls) {
        try {
            for (String url : urls) {
                String key = url.replace(publicUrl, StrUtil.EMPTY);
                boolean exist = client.doesObjectExist(config.getBucketName(), key);
                if (exist) {
                    client.deleteObject(config.getBucketName(), key);
                }
            }
        } finally {
            client.shutdown();
        }
    }
}

```

OssFileClientFactory：工厂类

```java
import com.dongguo.dianping.support.ApplicationContextHolder;

public class OssFileClientFactory {

    public static OssFileClient build() {
        OssProperties config = ApplicationContextHolder.getBean(OssProperties.class);
        return new OssFileClient(config);
    }
}
```

UploadController：

```java
import com.dongguo.dianping.entity.Result;
import com.dongguo.dianping.support.oss.OssFileClientFactory;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;
import java.io.IOException;

@Slf4j
@RestController
@RequestMapping("upload")
@Tag(
        name = "UploadController",
        description = "文件上传控制器接口")
public class UploadController {

    @PostMapping(value = "image", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    @Operation(
            summary = "uploadImage",
            description = "上传照片"
    )
    public Result uploadImage(@RequestParam("file") MultipartFile image) {
        try {
            // 生成新文件名
            String fileName = OssFileClientFactory.build().uploadFile(image);
            // 返回结果
            log.debug("文件上传成功，{}", fileName);
            return Result.ok(fileName);
        } catch (IOException e) {
            throw new RuntimeException("文件上传失败", e);
        }
    }

    /**
     * @param filename
     * @return
     */
    @Operation(
            summary = "deleteByFileName",
            description = "删除"
    )
    @GetMapping("/deleteByFileName")
    public Result deleteByFileName(@RequestParam("name") String filename) {
        OssFileClientFactory.build().deleteByFileName(filename);
        return Result.ok();
    }

    /**
     * @param filename
     * @return
     */
    @Operation(
            summary = "renameFile",
            description = "重命名"
    )
    @GetMapping("/renameFile")
    public Result renameFile(@RequestParam("name") String filename) {
        String newFileName = OssFileClientFactory.build().renameFile(filename);
        return Result.ok(newFileName);
    }

    /**
     * @param filename
     * @return
     */
    @Operation(
            summary = "downFile",
            description = "下载"
    )
    @GetMapping("/downFile")
    public Result downFile(@RequestParam("name") String filename, HttpServletResponse response) throws Exception {
        OssFileClientFactory.build().downFile(filename, response);
        return Result.ok();
    }
}
```

### 发布笔记

BlogServiceImpl：

```java
    @Override
    public Result saveBlog(Blog blog) {
        // 获取登录用户
        UserDTO user = UserThreadLocalCache.getUser();
        blog.setUserId(user.getId());

        String title = blog.getTitle();
        if (StrUtil.isBlank(title)){
            return Result.fail("标题不能为空");
        }
        // 保存探店博文
        boolean isSuccess = save(blog);
        if (!isSuccess){
            return Result.fail("新增笔记失败");
        }
        // 返回id
        return Result.ok();
    }
```

BlogController

```java
    @Resource
    private IBlogService blogService;

    @PostMapping
    @Operation(
            summary = "saveBlog",
            description = "发布笔记"
    )
    public Result saveBlog(@RequestBody Blog blog) {
        return blogService.saveBlog(blog);
    }
```

##  达人探店-查看探店笔记

实现查看发布探店笔记的接口

![image-20240324172458269](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403242037978.png)

BlogServiceImpl

```java
    @Override
    public Result queryBlogById(Long id) {
        Blog blog = getById(id);
        if (ObjectUtil.isEmpty(blog)){
            return Result.fail("笔记不存在");
        }
        //补充笔记用户相关信息
        queryBlogUser(blog);
        return Result.ok(blog);
    }
    
    private void queryBlogUser(Blog blog) {
        Long userId = blog.getUserId();
        User user = userService.getById(userId);
        blog.setIcon(user.getIcon());
        blog.setName(user.getNickName());
    }
```

BlogController

```java
    @GetMapping("/{id}")
    @Operation(
            summary = "queryBlogById",
            description = "查看笔记"
    )
    public Result queryBlogById(@PathVariable("id") Long id) {
        return blogService.queryBlogById(id);
    }
```

