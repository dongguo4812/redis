# 项目架构

![image-20240319171124630](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403191712307.png)

## 1.创建项目redis_dianping

后端项目redis_dianping

前端就不整了，使用swagger测试接口即可

## 2.引入依赖

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-redis</artifactId>
        <exclusions>
            <exclusion>
                <artifactId>spring-data-redis</artifactId>
                <groupId>org.springframework.data</groupId>
            </exclusion>
            <exclusion>
                <artifactId>lettuce-core</artifactId>
                <groupId>io.lettuce</groupId>
            </exclusion>
        </exclusions>
    </dependency>
    <dependency>
        <groupId>org.springframework.data</groupId>
        <artifactId>spring-data-redis</artifactId>
    </dependency>
    <dependency>
        <groupId>io.lettuce</groupId>
        <artifactId>lettuce-core</artifactId>
    </dependency>
    <dependency>
        <groupId>org.apache.commons</groupId>
        <artifactId>commons-pool2</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
        <scope>runtime</scope>
    </dependency>
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>com.baomidou</groupId>
        <artifactId>mybatis-plus-boot-starter</artifactId>
    </dependency>
    <!--hutool-->
    <dependency>
        <groupId>cn.hutool</groupId>
        <artifactId>hutool-all</artifactId>
    </dependency>
    <dependency>
        <groupId>org.apache.commons</groupId>
        <artifactId>commons-lang3</artifactId>
    </dependency>
    <dependency>
        <groupId>com.alibaba</groupId>
        <artifactId>fastjson</artifactId>
    </dependency>
    <dependency>
        <groupId>org.aspectj</groupId>
        <artifactId>aspectjweaver</artifactId>
    </dependency>
    <dependency>
        <groupId>org.redisson</groupId>
        <artifactId>redisson</artifactId>
    </dependency>
</dependencies>
```



## 3.application.yml配置

```yaml
server:
  port: 8081
spring:
  application:
    name: redis_dianping
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://127.0.0.1:3306/redis?useSSL=false&serverTimezone=UTC
    username: root
    password: root
  data:
    redis:
      host: 192.168.122.131
      port: 6379
      password: root
    lettuce:
      pool:
        max-active: 10
        max-idle: 10
        min-idle: 1
        time-between-eviction-runs: 10s
  jackson:
    default-property-inclusion: non_null # JSON处理时忽略非空字段
mybatis-plus:
  type-aliases-package: com.dongguo.redis.entity # 别名扫描包
logging:
  level:
    com.dongguo.redis: debug

```

## 4.配置类

MybatisConfig   MyBatis Plus分页插件

```java
import com.baomidou.mybatisplus.annotation.DbType;
import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;
import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class MybatisConfig {
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() {
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));
        return interceptor;
    }
}

```

RegexUtils正则校验工具类

```java
import cn.hutool.core.util.StrUtil;

/**
 * true 为无效  false为有效
 */
public class RegexUtils {
    /**
     * 手机号正则
     */
    public static final String PHONE_REGEX = "^1([38][0-9]|4[579]|5[0-3,5-9]|6[6]|7[0135678]|9[89])\\d{8}$";
    /**
     * 邮箱正则
     */
    public static final String EMAIL_REGEX = "^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\\.[a-zA-Z0-9_-]+)+$";
    /**
     * 密码正则。4~32位的字母、数字、下划线
     */
    public static final String PASSWORD_REGEX = "^\\w{4,32}$";
    /**
     * 验证码正则, 6位数字或字母
     */
    public static final String VERIFY_CODE_REGEX = "^[a-zA-Z\\d]{6}$";
    /**
     * 是否是无效手机格式
     * @param phone 要校验的手机号
     * @return true:符合，false：不符合
     */
    public static boolean isPhoneInvalid(String phone){
        return mismatch(phone, PHONE_REGEX);
    }
    /**
     * 是否是无效邮箱格式
     * @param email 要校验的邮箱
     * @return true:符合，false：不符合
     */
    public static boolean isEmailInvalid(String email){
        return mismatch(email, EMAIL_REGEX);
    }

    /**
     * 是否是无效验证码格式
     * @param code 要校验的验证码
     * @return true:符合，false：不符合
     */
    public static boolean isCodeInvalid(String code){
        return mismatch(code, VERIFY_CODE_REGEX);
    }

    // 校验是否不符合正则格式
    private static boolean mismatch(String str, String regex){
        if (StrUtil.isBlank(str)) {
            return true;
        }
        return !str.matches(regex);
    }
}

```



# 短信登录实战短信登录实战

## 基于Session实现登录流程

先不考虑使用redis实现，基于Session实现登录流程

**发送验证码：**

用户在提交手机号后，会校验手机号是否合法，如果不合法，则要求用户重新输入手机号

如果手机号合法，后台此时生成对应的验证码，同时将验证码进行保存到session，然后再通过短信的方式将验证码发送给用户

**短信验证码登录、注册：**

用户将验证码和手机号进行输入，后台从session中拿到当前验证码，然后和用户输入的验证码进行校验，如果不一致，则无法通过校验，如果一致，则后台根据手机号查询用户，如果用户不存在，则为用户创建账号信息，保存到数据库，存在则登录，无论是否存在，都会将用户信息保存到session中，方便后续获得当前登录信息

**校验登录状态:**

用户在请求时候，会从cookie中携带者JsessionId到后台，后台通过JsessionId从session中拿到用户信息，如果没有session信息，则进行拦截，如果有session信息，则将用户信息保存到threadLocal中，并且放行



![image-20240319171441782](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403191714868.png)

实现发送短信验证码功能

![image-20240319171506381](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403191715065.png)

点击登录，输入手机号，点击发送验证码

### 发送短信验证码功能

UserServiceImpl：

```java
        @Override
        public Result sendCode(String phone, HttpSession session) {
            //1校验手机号是否符合规定
            if (StringUtils.isBlank(phone)) {
                return Result.fail("手机号不能为空");
            }
            if (phone.length() != 11) {
                return Result.fail("手机号" + phone + "不符合要求");
            }
            boolean isMatch = RegexUtils.isPhoneInvalid(phone);
            if (isMatch) {
                return Result.fail("手机号" + phone + "不符合要求");
            }
            //2生成验证码
            String code = RandomUtil.randomNumbers(6);
            //3保存到session中
            session.setAttribute("code", code);
            log.debug("验证码发送成功:{}", code);
            return Result.ok("验证码发送成功:" + code);
        }
```

UserController：

```java
    @Operation(
            summary = "sendCode",
            description = "发送手机验证码"
    )
    @PostMapping("/sendCode")
    public Result sendCode(@RequestParam(value = "phone") String phone, HttpSession session) {
        return userService.sendCode(phone, session);
    }
```



### 短信验证码登录功能

UserServiceImpl

```java
    @Override
    public Result login(LoginFormBO loginForm, HttpSession session) {
        if (ObjectUtil.isEmpty(loginForm)) {
            return Result.fail("数据为空");
        }
        if (StringUtils.isBlank(loginForm.getPhone()) || StringUtils.isBlank(loginForm.getCode())) {
            return Result.fail("手机号或者验证码不能为空");
        }
        boolean isMatch = RegexUtils.isPhoneInvalid(loginForm.getPhone());
        if (isMatch) {
            return Result.fail("手机号" + loginForm.getPhone() + "不符合要求");
        }
        String code = session.getAttribute("code").toString();
        if (!loginForm.getCode().equals(code)) {
            return Result.fail("验证码错误");
        }

        LambdaUpdateWrapper<User> wrapper = new LambdaUpdateWrapper<>();
        wrapper.eq(User::getPhone, loginForm.getPhone());
        User user = userMapper.selectOne(wrapper);
        if (ObjectUtil.isEmpty(user)) {
            //注册新用户
            User newUser = new User()
                    .setPhone(loginForm.getPhone())
                    .setNickName(SystemConstants.USER_NICK_NAME_PREFIX + RandomUtil.randomString(SystemConstants.MAX_PAGE_SIZE));
            userMapper.insert(newUser);
        }
        //登录
        String token = UUID.randomUUID().toString(true);
        UserDTO userDTO = new UserDTO();
        BeanUtil.copyProperties(user, userDTO);
        session.setAttribute("user",userDTO);
        return Result.ok(token);
    }
```

UserController

```java
    /**
     * 登录功能  目前只实现手机+验证码登录即可
     *
     * @param loginForm 登录参数，包含手机号、验证码；或者手机号、密码
     */
    @PostMapping("/login")
    public Result login(@RequestBody LoginFormBO loginForm, HttpSession session) {
        return userService.login(loginForm,session);
    }
```

### 实现登录拦截功能

当用户发起请求时，会访问我们向tomcat注册的端口，任何程序想要运行，都需要有一个线程对当前端口号进行监听，tomcat也不例外，当监听线程知道用户想要和tomcat连接连接时，那会由监听线程创建socket连接，socket都是成对出现的，用户通过socket像互相传递数据，当tomcat端的socket接受到数据后，此时监听线程会从tomcat的线程池中取出一个线程执行用户请求，在我们的服务部署到tomcat后，线程会找到用户想要访问的工程，然后用这个线程转发到工程中的controller，service，dao中，并且访问对应的DB，在用户执行完请求后，再统一返回，再找到tomcat端的socket，再将数据写回到用户端的socket，完成请求和响应

![image-20240320094027340](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403202210733.png)

通过以上讲解，我们可以得知 每个用户其实对应都是去找tomcat线程池中的一个线程来完成工作的， 使用完成后再进行回收，既然每个请求都是独立的，所以在每个用户去访问我们的工程时，我们可以使用threadlocal来做到线程隔离，每个线程操作自己的一份数据

![image-20240320094215135](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403202208337.png)

拦截器LoginInterceptor

```java
import com.dongguo.redis.entity.DTO.UserDTO;
import com.dongguo.redis.support.threadlocal.UserThreadLocalCache;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;
import org.springframework.web.servlet.HandlerInterceptor;


/**
 * 登录拦截器
 */
public class LoginInterceptor implements HandlerInterceptor {

    /**
     * 在控制器方法（即处理请求的@RequestMapping注解的方法）之前调用
     * @param request
     * @param response
     * @param handler
     * @return
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
        //获取session
        HttpSession session = request.getSession();
        //获取session中用户信息
        Object user = session.getAttribute("user");
        if (user == null){
            //不存在，即未进行登录，进行拦截
            return false;
        }
        //存在，保存用户信息到threadLocal
        UserThreadLocalCache.setUser((UserDTO)user);
        //放行
        return true;
    }

    /**
     * 在整个请求处理完成之后调用
     * @param request
     * @param response
     * @param handler
     * @param ex
     * @throws Exception
     */
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        // 移除ThreadLocal用户信息
        UserThreadLocalCache.removeUser();
    }
}
```

MvcConfig：

在 Spring MVC 的配置中注册这个拦截器，让拦截器生效

```java
import com.dongguo.redis.support.interceptor.LoginInterceptor;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;


@Configuration
public class MvcConfig implements WebMvcConfigurer {


    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        //登录拦截器
        registry.addInterceptor(new LoginInterceptor())
                //排除不需要拦截的路径，视情况添加
                .excludePathPatterns(
                        "/v3/**",  //swagger也需要排除
                        "/swagger-ui/**",
                        "/swagger-ui.html",

                        "/shop/**", //店铺信息
                        "/voucher/**",  //优惠券信息
                        "/shop-type/**",    //店铺类型信息
                        "/blog/hot",    //查询热门博客
                        "/user/sendCode",  //发送短信验证码
                        "/user/login"  //登录
                ).order(1);
    }
}

```



### 获取用户信息

测试拦截器功能，必须登录后才能获取用户信息

![image-20240320101747433](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403202209790.png)

这个接口用户信息中的一些敏感信息是不需要返回的，所以直接返回UserDto对象就足够了。

并且拦截器会将session中的用户信息放入到ThreadLocal中，所以直接从ThreadLocal中获取user信息即可。

UserController：

```java
    /**
     * 请求接口时，拦截器会将session中的用户信息放入到ThreadLocal中
     * 所以直接从ThreadLocal中获取user信息即可。
     * @return
     */
    @GetMapping("/me")
    public Result me() {
        UserDTO user = UserThreadLocalCache.getUser();
        return Result.ok(user);
    }
```

### session共享问题

集群中，每个tomcat中都有一份属于自己的session,假设用户第一次访问第一台tomcat，并且把自己的信息存放到第一台服务器的session中，但是第二次这个用户访问到了第二台tomcat，那么在第二台服务器上，肯定没有第一台服务器存放的session，所以此时 整个登录拦截功能就会出现问题，我们能如何解决这个问题呢？早期的方案是session拷贝，就是说虽然每个tomcat上都有不同的session，但是每当任意一台服务器的session修改时，都会同步给其他的Tomcat服务器的session，这样的话，就可以实现session的共享了

但是这种方案具有两个大问题

1、每台服务器中都有完整的一份session数据，服务器压力过大。

2、session拷贝数据时，可能会出现延迟

![image-20240320110353355](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403202209293.png)

#### 解决方案

基于redis来完成，把session换成redis，redis数据本身就是共享的，就可以避免session共享的问题了

![image-20240320110630674](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403202209419.png)

## 基于Redis实现共享session登录

使用Redis保存session，可以直接使用String数据类型，以手机号为key，验证码为value。

使用Redis保存用户信息时，可以使用Hash数据类型也可以使用String数据类型。既然保存对象信息，那就选择hash。

在后台生成一个随机串token作为key，用户信息为value，请求接口时携带这个token就能完成我们的整体逻辑了

### 流程：

输入手机号生成验证码，将验证码保存到redis，登录时校验输入的验证码与redis中的验证码是否一致，如果一致，则根据手机号查询用户信息，不存在则新建，最后将用户数据保存到redis，并且生成token作为redis的key。

当我们校验用户是否登录时，会去携带着token进行访问，从redis中取出token对应的value，判断是否存在这个数据，如果没有则拦截，如果存在则将其保存到threadLocal中，并且放行。

![image-20240320112135358](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403202209888.png)





![image-20240320112356513](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403202209011.png)

### 修改代码

UserServiceImpl

```java
import cn.hutool.core.bean.BeanUtil;
import cn.hutool.core.bean.copier.CopyOptions;
import cn.hutool.core.lang.UUID;
import cn.hutool.core.util.ObjectUtil;
import cn.hutool.core.util.RandomUtil;
import com.baomidou.mybatisplus.core.conditions.update.LambdaUpdateWrapper;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.dongguo.redis.entity.BO.LoginFormBO;
import com.dongguo.redis.entity.DTO.UserDTO;
import com.dongguo.redis.entity.POJO.User;
import com.dongguo.redis.entity.Result;
import com.dongguo.redis.mapper.UserMapper;
import com.dongguo.redis.service.IUserService;
import com.dongguo.redis.utils.RedisConstants;
import com.dongguo.redis.utils.RegexUtils;
import com.dongguo.redis.utils.SystemConstants;
import jakarta.annotation.Resource;
import jakarta.servlet.http.HttpSession;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;
import java.time.Duration;
import java.util.HashMap;
import java.util.Map;

import static com.dongguo.redis.utils.RedisConstants.LOGIN_CODE_KEY;
import static com.dongguo.redis.utils.RedisConstants.LOGIN_CODE_TTL;

/**
 * <p>
 * 服务实现类
 * </p>
 */
@Service
@Slf4j
public class UserServiceImpl extends ServiceImpl<UserMapper, User> implements IUserService {
    @Autowired
    private UserMapper userMapper;
    @Resource
    private RedisTemplate redisTemplate;

    @Override
    public Result sendCode(String phone, HttpSession session) {
        //1校验手机号是否符合规定
        if (StringUtils.isBlank(phone)) {
            return Result.fail("手机号不能为空");
        }
        if (phone.length() != 11) {
            return Result.fail("手机号" + phone + "不符合要求");
        }
        boolean isMatch = RegexUtils.isPhoneInvalid(phone);
        if (isMatch) {
            return Result.fail("手机号" + phone + "不符合要求");
        }
        //2生成验证码
        String code = RandomUtil.randomNumbers(6);
        //3保存到session中
//            session.setAttribute("code", code);
        //保存到redis中
        redisTemplate.opsForValue().set(LOGIN_CODE_KEY + phone,
                code,
                Duration.ofMinutes(LOGIN_CODE_TTL));
        //4发送验证码
        log.debug("验证码发送成功:{}", code);
        return Result.ok("验证码发送成功:" + code);
    }

    @Override
    public Result login(LoginFormBO loginForm, HttpSession session) {
        if (ObjectUtil.isEmpty(loginForm)) {
            return Result.fail("数据为空");
        }
        if (StringUtils.isBlank(loginForm.getPhone()) || StringUtils.isBlank(loginForm.getCode())) {
            return Result.fail("手机号或者验证码不能为空");
        }
        boolean isMatch = RegexUtils.isPhoneInvalid(loginForm.getPhone());
        if (isMatch) {
            return Result.fail("手机号" + loginForm.getPhone() + "不符合要求");
        }
        Object obj = redisTemplate.opsForValue().get(LOGIN_CODE_KEY + loginForm.getPhone());
        if (obj == null){
            return Result.fail("验证码错误");
        }
//        String code = session.getAttribute("code").toString();

        LambdaUpdateWrapper<User> wrapper = new LambdaUpdateWrapper<>();
        wrapper.eq(User::getPhone, loginForm.getPhone());
        User user = userMapper.selectOne(wrapper);
        if (ObjectUtil.isEmpty(user)) {
            //注册新用户
            User newUser = new User()
                    .setPhone(loginForm.getPhone())
                    .setNickName(SystemConstants.USER_NICK_NAME_PREFIX + RandomUtil.randomString(SystemConstants.MAX_PAGE_SIZE));
            userMapper.insert(newUser);
        }
        //登录
        String token = UUID.randomUUID().toString(true);
        UserDTO userDTO = new UserDTO();
        BeanUtil.copyProperties(user, userDTO);
        Map<String, Object> userMap = new HashMap<>();
        BeanUtil.copyProperties(userDTO, userMap, new CopyOptions().setConverter((fieldName,filedValue) ->filedValue.toString()));
        redisTemplate.opsForHash().putAll(RedisConstants.LOGIN_USER_KEY + token, userMap);
        redisTemplate.expire(RedisConstants.LOGIN_USER_KEY + token, Duration.ofMinutes(RedisConstants.LOGIN_USER_TTL));
//        session.setAttribute("user", userDTO);
        return Result.ok(token);
    }
}
```

LoginInterceptor拦截器

```java
import cn.hutool.core.bean.BeanUtil;
import cn.hutool.core.util.ObjectUtil;
import com.dongguo.redis.entity.DTO.UserDTO;
import com.dongguo.redis.support.threadlocal.UserThreadLocalCache;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.web.servlet.HandlerInterceptor;
import java.util.Map;

import static com.dongguo.redis.utils.RedisConstants.LOGIN_USER_KEY;


/**
 * 登录拦截器
 */
public class LoginInterceptor implements HandlerInterceptor {
    private RedisTemplate redisTemplate;

    public LoginInterceptor(RedisTemplate redisTemplate) {
        this.redisTemplate = redisTemplate;
    }
    /**
     * 在控制器方法（即处理请求的@RequestMapping注解的方法）之前调用
     * @param request
     * @param response
     * @param handler
     * @return
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
   /*     //获取session
        HttpSession session = request.getSession();
        //获取session中用户信息
        Object user = session.getAttribute("user");
        if (user == null){
            //不存在，即未进行登录，进行拦截
            return false;
        }
        //存在，保存用户信息到threadLocal
        UserThreadLocalCache.setUser((UserDTO)user);
        */

        String token = request.getHeader("authorization");
        if (token == null){
            //不存在，即未进行登录，进行拦截
            response.setStatus(401);
            return false;
        }
        Map<Object, Object> userMap = redisTemplate.opsForHash().entries(LOGIN_USER_KEY + token);
        if (ObjectUtil.isEmpty(userMap)){
            response.setStatus(401);
            return false;
        }
        UserDTO userDTO = BeanUtil.mapToBean(userMap, UserDTO.class,false);

        //存在，保存用户信息到threadLocal
        UserThreadLocalCache.setUser(userDTO);
        //放行
        return true;
    }

    /**
     * 在整个请求处理完成之后调用
     * @param request
     * @param response
     * @param handler
     * @param ex
     * @throws Exception
     */
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        // 移除ThreadLocal用户信息
        UserThreadLocalCache.removeUser();
    }
}
```

MvcConfig传入stringRedisTemplate

```java
import com.dongguo.redis.support.interceptor.LoginInterceptor;
import jakarta.annotation.Resource;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;


@Configuration
public class MvcConfig implements WebMvcConfigurer {
    @Resource
    private RedisTemplate redisTemplate;
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        //登录拦截器
        registry.addInterceptor(new LoginInterceptor(redisTemplate))
                //排除不需要拦截的路径，视情况添加
                .excludePathPatterns(
                        "/v3/**",  //swagger也需要排除
                        "/swagger-ui/**",
                        "/swagger-ui.html",
                        "/shop/**", //店铺信息
                        "/voucher/**",  //优惠券信息
                        "/shop-type/**",    //店铺类型信息
                        "/blog/hot",    //查询热门博客
                        "/user/sendCode",  //发送短信验证码
                        "/user/login"  //登录
                ).order(1);
    }
}
```

SwaggerOpenApiConfig新增AUTHORIZATION

```java
import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Contact;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.info.License;
import io.swagger.v3.oas.models.security.SecurityRequirement;
import io.swagger.v3.oas.models.security.SecurityScheme;
import org.springframework.boot.SpringBootConfiguration;
import org.springframework.context.annotation.Bean;
import org.springframework.http.HttpHeaders;

import java.util.HashMap;

@SpringBootConfiguration
public class SwaggerOpenApiConfig {
    /***
     * 构建Swagger3.0文档说明
     * @return 返回 OpenAPI
     */
    @Bean
    public OpenAPI customOpenAPI() {

        // 联系人信息(contact)，构建API的联系人信息，用于描述API开发者的联系信息，包括名称、URL、邮箱等
        // name：文档的发布者名称 url：文档发布者的网站地址，一般为企业网站 email：文档发布者的电子邮箱
        Contact contact = new Contact()
                .name("东郭")                             // 作者名称
                .email("dongguo@qq.com")                   // 作者邮箱
                .url("https://www.dongguo.com")  // 介绍作者的URL地址
                .extensions(new HashMap<String, Object>()); // 使用Map配置信息（如key为"name","email","url"）

        // 授权许可信息(license)，用于描述API的授权许可信息，包括名称、URL等；假设当前的授权信息为Apache 2.0的开源标准
        License license = new License()
                .name("Apache 2.0")                         // 授权名称
                .url("https://www.apache.org/licenses/LICENSE-2.0.html")    // 授权信息
                .identifier("Apache-2.0")                   // 标识授权许可
                .extensions(new HashMap<String, Object>());// 使用Map配置信息（如key为"name","url","identifier"）

        //创建Api帮助文档的描述信息、联系人信息(contact)、授权许可信息(license)
        Info info = new Info()
                .title("Swagger3.0 (Open API) 框架学习示例文档")      // Api接口文档标题（必填）
                .description("学习Swagger框架而用来定义测试的文档")     // Api接口文档描述
                .version("1.0.0")                                  // Api接口版本
                .termsOfService("https://dongguo.com/")            // Api接口的服务条款地址
                .license(license)                                  // 设置联系人信息
                .contact(contact);                                 // 授权许可信息
        // 返回信息
        return new OpenAPI()
                .openapi("3.0.1")  // Open API 3.0.1(默认)
                .schemaRequirement(HttpHeaders.AUTHORIZATION, this.securityScheme())
                //全局安全校验项，也可以在对应的controller上加注解SecurityRequirement
                .addSecurityItem(new SecurityRequirement().addList(HttpHeaders.AUTHORIZATION))
                .info(info);       // 配置Swagger3.0描述信息
    }

    /**
     * 参考https://springdoc.org/#how-do-i-add-authorization-header-in-requests
     * @return
     */
    private SecurityScheme securityScheme() {
        SecurityScheme securityScheme = new SecurityScheme();
        //类型
        securityScheme.setType(SecurityScheme.Type.APIKEY);
        //请求头的name
        securityScheme.setName(HttpHeaders.AUTHORIZATION);
        //token所在未知
        securityScheme.setIn(SecurityScheme.In.HEADER);
        return securityScheme;
    }
}
```

![image-20240320144136466](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403202209401.png)

### 解决登录token过期问题

在用户登录时，将用户信息缓存到redis中，并设置过期时间30分。但是如果超过了30分钟，那token就无效了，我们需要只要是用户还在访问系统，那就刷新token有效期。

![image-20240320151038915](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403202209839.png)

```java
    /**
     * 在控制器方法（即处理请求的@RequestMapping注解的方法）之前调用
     * @param request
     * @param response
     * @param handler
     * @return
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
        String token = request.getHeader("authorization");
        if (token == null){
            //不存在，即未进行登录，进行拦截
            response.setStatus(401);
            return false;
        }
        String tokenKey = LOGIN_USER_KEY + token;
        Map<Object, Object> userMap = redisTemplate.opsForHash().entries(tokenKey);
        if (ObjectUtil.isEmpty(userMap)){
            response.setStatus(401);
            return false;
        }
        UserDTO userDTO = BeanUtil.mapToBean(userMap, UserDTO.class,false);

        //存在，保存用户信息到threadLocal
        UserThreadLocalCache.setUser(userDTO);
        //刷新token有效期
        stringRedisTemplate.expire(tokenKey, LOGIN_USER_TTL, TimeUnit.MINUTES);
        //放行
        return true;
    }
```

### 解决状态登录刷新问题

虽然我们在拦截器中设置了刷新token有效期的操作，但是这个登录拦截器他只拦截需要登录才能访问的路径，假设当前用户访问了一些不需要拦截的路径，那么这个拦截器就不会生效，所以此时token刷新的动作实际上就不会执行，这个方案是存在问题的



既然之前的拦截器无法对不需要拦截的路径生效，那么我们可以再添加一个拦截器，在第一个拦截器中拦截所有的路径，把第二个拦截器做的事情放入到第一个拦截器中，同时刷新令牌，因为第一个拦截器有了threadLocal的数据，所以此时第二个拦截器只需要判断拦截器中的user对象是否存在即可。

![image-20240320151337707](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403202209735.png)

RefreshTokenInterceptor 拦截器负责刷新token

```java
import cn.hutool.core.bean.BeanUtil;
import cn.hutool.core.util.StrUtil;
import com.dongguo.redis.entity.DTO.UserDTO;
import com.dongguo.redis.support.threadlocal.UserThreadLocalCache;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.web.servlet.HandlerInterceptor;
import java.util.Map;
import java.util.concurrent.TimeUnit;

import static com.dongguo.redis.utils.RedisConstants.LOGIN_USER_KEY;
import static com.dongguo.redis.utils.RedisConstants.LOGIN_USER_TTL;

public class RefreshTokenInterceptor implements HandlerInterceptor {

    private RedisTemplate redisTemplate;

    public RefreshTokenInterceptor(RedisTemplate redisTemplate) {
        this.redisTemplate = redisTemplate;
    }
    /**
     * 在控制器方法（即处理请求的@RequestMapping注解的方法）之前调用
     * @param request
     * @param response
     * @param handler
     * @return
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
       /*     //获取session
        HttpSession session = request.getSession();
        //获取session中用户信息
        Object user = session.getAttribute("user");
        if (user == null){
            //不存在，即未进行登录，进行拦截
            return false;
        }
        //存在，保存用户信息到threadLocal
        UserThreadLocalCache.setUser((UserDTO)user);
        */
        // 1.获取请求头中的token
        String token = request.getHeader("authorization");
        if (StrUtil.isBlank(token)) {
            return true;
        }
        // 2.基于TOKEN获取redis中的用户
        String tokenKey  = LOGIN_USER_KEY + token;
        Map<Object, Object> userMap = redisTemplate.opsForHash().entries(tokenKey);
        // 3.判断用户是否存在
        if (userMap.isEmpty()) {
            return true;
        }
        // 5.将查询到的hash数据转为UserDTO
        UserDTO userDTO = BeanUtil.mapToBean(userMap, UserDTO.class,false);
        // 6.存在，保存用户信息到 ThreadLocal
        UserThreadLocalCache.setUser(userDTO);
        // 7.刷新token有效期
        stringRedisTemplate.expire(tokenKey, LOGIN_USER_TTL, TimeUnit.MINUTES);
        // 8.放行
        return true;
    }
    /**
     * 在整个请求处理完成之后调用
     * @param request
     * @param response
     * @param handler
     * @param ex
     * @throws Exception
     */
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        // 移除用户
        UserThreadLocalCache.removeUser();
    }
}
```

LoginInterceptor：

```java
import com.dongguo.redis.support.threadlocal.UserThreadLocalCache;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.web.servlet.HandlerInterceptor;


/**
 * 登录拦截器
 */
public class LoginInterceptor implements HandlerInterceptor {

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
        if (UserThreadLocalCache.getUser() == null){
            response.setStatus(401);
            return false;
        }
        return true;
    }
}
```

MvcConfig

在 Spring MVC 的配置中注册这两个拦截器，让拦截器生效

RefreshTokenInterceptor先拦截，拦截所有请求，LoginInterceptor后拦截，拦截需要登录才能访问的请求

```java
import com.dongguo.redis.support.interceptor.LoginInterceptor;
import com.dongguo.redis.support.interceptor.RefreshTokenInterceptor;
import jakarta.annotation.Resource;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;


@Configuration
public class MvcConfig implements WebMvcConfigurer {
    @Resource
    private RedisTemplate redisTemplate;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        // token刷新的拦截器
        registry.addInterceptor(new RefreshTokenInterceptor(redisTemplate))
                .addPathPatterns("/**")
                .order(0);

        //登录拦截器
        registry.addInterceptor(new LoginInterceptor())
                //排除不需要拦截的路径，视情况添加
                .excludePathPatterns(
                        "/v3/**",  //swagger也需要排除
                        "/swagger-ui/**",
                        "/swagger-ui.html",
                        "/shop/**", //店铺信息
                        "/voucher/**",  //优惠券信息
                        "/shop-type/**",    //店铺类型信息
                        "/blog/hot",    //查询热门博客
                        "/user/sendCode",  //发送短信验证码
                        "/user/login"  //登录
                ).order(1);
    }
}
```

# 商户查询缓存实战

在我们查询商户信息时，查询数据库之前先查询缓存，如果缓存数据存在，则直接从缓存中返回，如果缓存数据不存在，再查询数据库，然后将数据存入redis。

![image-20240320184454869](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403202209351.png)

根据id查询店铺时，如果缓存未命中，则查询数据库，将数据库结果写入缓存，并设置超时时间

ShopController:

```java
import com.dongguo.redis.entity.Result;
import com.dongguo.redis.service.IShopService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.annotation.Resource;
import org.springframework.web.bind.annotation.*;


/**
 * <p>
 * 商户控制器
 * </p>
 */
@RestController
@RequestMapping("/shop")
@Tag(
        name = "ShopController",
        description = "商户控制器接口")
public class ShopController {

    @Resource
    public IShopService shopService;

    /**
     * 根据id查询商铺信息
     *
     * @param id 商铺id
     * @return 商铺详情数据
     */
    @GetMapping("/{id}")
    @Operation(
            summary = "queryShopById",
            description = "根据id查询商铺信息"
    )
    public Result queryShopById(@PathVariable("id") Long id) {
        return shopService.queryShopById(id);
    }
}
```

ShopServiceImpl:

```java
import cn.hutool.core.bean.BeanUtil;
import cn.hutool.core.util.ObjectUtil;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.dongguo.redis.entity.POJO.Shop;
import com.dongguo.redis.entity.Result;
import com.dongguo.redis.mapper.ShopMapper;
import com.dongguo.redis.service.IShopService;
import jakarta.annotation.Resource;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;
import java.util.*;
import java.util.concurrent.TimeUnit;

import static com.dongguo.redis.utils.RedisConstants.*;

/**
 * <p>
 * 服务实现类
 * </p>
 *
 */
@Service
public class ShopServiceImpl extends ServiceImpl<ShopMapper, Shop> implements IShopService {
    @Resource
    private RedisTemplate redisTemplate;
    @Autowired
    private ShopMapper shopMapper;

    @Override
    public Result queryShopById(Long id) {
        if (id == null) {
            return Result.fail("店铺id不能为空");
        }
        String shopCacheKey = CACHE_SHOP_KEY + id;
        //先查缓存
        Object object = redisTemplate.opsForValue().get(shopCacheKey);
        //判空
        if (ObjectUtil.isNotEmpty(object)) {
            //缓存查到 返回
            return Result.ok(object);
        }
        //缓存中没查到  查数据库
        Shop shop = shopMapper.selectById(id);
        if (ObjectUtil.isEmpty(shop)) {
            return Result.fail("店铺信息不存在");
        }
        //存到缓存中
        redisTemplate.opsForValue().set(shopCacheKey, shop, CACHE_SHOP_TTL, TimeUnit.MINUTES);
        return Result.ok(shop);
    }
}
```

## 实现商铺和缓存与数据库双写一致

根据id修改店铺时，先修改数据库，再删除缓存

ShopServiceImpl：

```java
    @Override
    @Transactional
    public Result updateShop(Shop shop) {
        Shop shopById = getById(shop.getId());
        if (ObjectUtil.isEmpty(shopById)) {
            return Result.fail("商铺不存在");
        }
        // 写入数据库
        updateById(shop);

        //删除缓存
        redisTemplate.delete(CACHE_SHOP_KEY + shop.getId());
        return Result.ok();
    }
```

ShopController：

```java
    /**
     * 更新商铺信息
     *
     * @param shop 商铺数据
     * @return 无
     */
    @PutMapping
    @Operation(
            summary = "updateShop",
            description = "更新商铺信息"
    )
    public Result updateShop(@RequestBody Shop shop) {
        return shopService.updateShop(shop);
    }
```

## 缓存穿透问题的解决思路

恶意频繁访问缓存数据库没有的数据，

![image-20240320210136811](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403202209709.png)

### 1缓存空对象  

**缓存空对象思路分析：**当我们访问不存在的数据时，先请求redis，但是此时redis中没有数据，就会访问到数据库，但是数据库中也没有数据，这个数据穿透了缓存，直击数据库，我们都知道数据库能够承载的并发不如redis这么高，如果大量的请求同时过来访问这种不存在的数据，这些请求就都会访问到数据库，简单的解决方案就是哪怕这个数据在数据库中也不存在，我们也把这个数据存入到redis中去，这样，下次用户过来访问这个不存在的数据，那么在redis中也能找到这个数据就不会进入到缓存了

![image-20240320210314147](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403202209684.png)

如果这个数据不存在，把这个数据写入到Redis中，并且将value设置为空，当再次发起查询时，我们如果发现命中之后，判断这个value是否是null，如果是null，则是之前写入的数据，证明是缓存穿透数据，如果不是，则直接返回数据。

![image-20240320210428865](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403202209483.png)

ShopServiceImpl：

```java
    @Override
    public Result queryShopById(Long id) {
        if (id == null) {
            return Result.fail("店铺id不能为空");
        }
        String shopCacheKey = CACHE_SHOP_KEY + id;
        //先查缓存
        Object object = redisTemplate.opsForValue().get(shopCacheKey);
        //判空
        if (ObjectUtil.isNotEmpty(object)) {
            //缓存查到 返回
            return Result.ok(object);
        }
        //缓存的空值   缓存的空字符串""
        if (ObjectUtil.equal(object,"")) {
            return Result.fail("店铺信息不存在");
        }
        //缓存中没查到  查数据库
        Shop shop = shopMapper.selectById(id);
        if (ObjectUtil.isEmpty(shop)) {
            //解决缓存穿透问题  缓存空对象
            redisTemplate.opsForValue().set(shopCacheKey, "", CACHE_NULL_TTL, TimeUnit.MINUTES);
            return Result.fail("店铺信息不存在");
        }
        //存到缓存中
        redisTemplate.opsForValue().set(shopCacheKey, shop, CACHE_SHOP_TTL, TimeUnit.MINUTES);
        return Result.ok(shop);
    }
```

### 2布隆过滤器 TODO





## 缓存击穿问题及解决思路

缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。



假设线程1在查询缓存之后，本来应该去查询数据库，然后把这个数据重新加载到缓存的，此时只要线程1走完这个逻辑，其他线程就都能从缓存中加载这些数据了，但是假设在线程1没有走完的时候，后续的线程2，线程3，线程4同时过来访问当前这个方法， 那么这些线程都不能从缓存中查询到数据，那么他们就会同一时刻来访问查询缓存，都没查到，接着同一时间去访问数据库，同时的去执行数据库代码，对数据库访问压力过大

![image-20240320214647199](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403202209116.png)

### 1.互斥锁

只能一个人一个人的来访问数据库，从而避免对于数据库访问压力过大，但这也会影响查询的性能，因为此时会让查询的性能从并行变成了串行。

假设现在线程1过来访问，他查询缓存没有命中，但是此时他获得到了锁的资源，那么线程1就会一个人去执行逻辑，假设现在线程2过来，线程2在执行过程中，并没有获得到锁，那么线程2就可以进行到休眠，直到线程1把锁释放后，线程2获得到锁，然后再来执行逻辑，此时就能够从缓存中拿到数据了。

![image-20240320214835660](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403202209459.png)

相较于原来从缓存中查询不到数据后直接查询数据库而言，现在的方案是 进行查询之后，如果从缓存没有查询到数据，则进行互斥锁的获取，获取互斥锁后，判断是否获得到了锁，如果没有获得到，则休眠，过一会再进行尝试，直到获取到锁为止，才能进行查询

如果获取到了锁的线程，再去进行查询，查询后将数据写入redis，再释放锁，返回数据，利用互斥锁就能保证只有一个线程去执行操作数据库的逻辑，防止缓存击穿

![image-20240321074253414](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403210743366.png)

核心思路就是利用redis的setnx方法来表示获取锁，该方法含义是redis中如果没有这个key，则插入成功，返回1，在RedisTemplate中返回true，  如果有这个key则插入失败，则返回0，在RedisTemplate返回false，我们可以通过true，或者是false，来表示是否有线程成功插入key，成功插入的key的线程我们认为他就是获得到锁的线程。

ShopServiceImpl:

```java
    @Override
    public Result queryShopById(Long id) {
        if (id == null) {
            return Result.fail("店铺id不能为空");
        }
        String shopCacheKey = CACHE_SHOP_KEY + id;
        //先查缓存
        Object object = redisTemplate.opsForValue().get(shopCacheKey);
        //判空
        if (ObjectUtil.isNotEmpty(object)) {
            //缓存查到 返回
            return Result.ok(object);
        }
        //缓存的空值   缓存的空字符串""
        if (ObjectUtil.equal(object, "")) {
            return Result.fail("店铺信息不存在");
        }
        //尝试加锁
        String lockKey = LOCK_SHOP_KEY + id;
        Boolean ifAbsent = redisTemplate.opsForValue().setIfAbsent(lockKey, id, LOCK_SHOP_TTL, TimeUnit.MINUTES);
        if (!ifAbsent) {
            //未获得锁，轮询
            try {
                TimeUnit.MILLISECONDS.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return queryShopById(id);
        }
        //缓存中没查到  查数据库
        Shop shop = shopMapper.selectById(id);
        if (ObjectUtil.isEmpty(shop)) {
            //解决缓存穿透问题  缓存空对象
            redisTemplate.opsForValue().set(shopCacheKey, "", CACHE_NULL_TTL, TimeUnit.MINUTES);
            return Result.fail("店铺信息不存在");
        }
        //存到缓存中
        redisTemplate.opsForValue().set(shopCacheKey, shop, CACHE_SHOP_TTL, TimeUnit.MINUTES);
        //删除锁
        redisTemplate.delete(lockKey);
        return Result.ok(shop);
    }
```

### 2.逻辑过期方案

方案分析：我们之所以会出现这个缓存击穿问题，主要原因是在于我们对key设置了过期时间，假设我们不设置过期时间，其实就不会有缓存击穿的问题，但是不设置过期时间，这样数据不就一直占用我们内存了吗，我们可以采用逻辑过期方案。

我们把过期时间设置在 redis的value中（expire为到过期时间时的时间戳），注意：这个过期时间并不会直接作用于redis，而是我们后续通过逻辑去处理。

假设线程1去查询缓存，然后从value中判断出来当前的数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞，获得了锁的线程他会开启一个 线程去进行 以前的重构数据的逻辑，直到新开的线程完成这个逻辑后，才释放锁， 而线程1直接进行返回，假设现在线程3过来访问，由于线程线程2持有着锁，所以线程3无法获得锁，线程3也直接返回数据，只有等到新开的线程2把重建数据构建完后，其他线程才能走返回正确的数据。

这种方案巧妙在于，异步的构建缓存，缺点在于在构建完缓存之前，返回的都是脏数据。

![image-20240320220812079](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403202210396.png)

**需求：修改根据id查询商铺的业务，基于逻辑过期方式来解决缓存击穿问题**

思路分析：当用户开始查询redis时，判断是否命中，如果没有命中则直接返回空数据，不查询数据库，而一旦命中后，将value取出，判断value中的过期时间是否满足，如果没有过期，则直接返回redis中的数据，如果过期，则在开启独立线程后直接返回之前的数据，独立线程去重构数据，重构完成后释放互斥锁。

![image-20240321074424249](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403210747154.png)

新建一个实体类RedisData

```java
import lombok.Data;
import java.util.Date;

@Data
public class RedisData {
    private Date expireTime;
    private Object data;
}
```

ShopServiceImpl

```java
    private static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10);

    @Override
    public Result queryShopById(Long id) {
        if (id == null) {
            return Result.fail("店铺id不能为空");
        }
        String shopCacheKey = CACHE_SHOP_KEY + id;
        //先查缓存
        Object object = redisTemplate.opsForValue().get(shopCacheKey);
        //缓存的空值   缓存的空字符串""
        if (ObjectUtil.equal(object, "")) {
            return Result.fail("店铺信息不存在");
        }
        //热点key续期，缓存中没有直接返回
        if (object == null){
            Shop shop = getAndCacheShop(id);
            return Result.ok(shop);
        }
        RedisData redisData = (RedisData) object;
        Shop shop = (Shop) redisData.getData();
        Date expireTime = redisData.getExpireTime();
        //判断是否过期
        if (expireTime.after(new Date())) {
            //没过期
            return Result.ok(shop);
        }
        //尝试加锁
        String lockKey = LOCK_SHOP_KEY + id;
        Boolean ifAbsent = redisTemplate.opsForValue().setIfAbsent(lockKey, id, LOCK_SHOP_TTL, TimeUnit.MINUTES);
        if (ifAbsent) {
            //开启独立线程 重建缓存
            CACHE_REBUILD_EXECUTOR.submit(() -> {
                try {
                    getAndCacheShop(id);
                } catch (Exception e) {
                    e.printStackTrace();
                } finally {
                    redisTemplate.delete(lockKey);
                }
            });
        }
        return Result.ok(shop);
    }

    private Shop getAndCacheShop(Long id) {
        //查询店铺数据
        Shop shop = shopMapper.selectById(id);
        if (ObjectUtil.isNotEmpty(shop)) {
            RedisData dataShop = new RedisData();
            dataShop.setData(shop);
            dataShop.setExpireTime(DateUtil.offsetMinute(new Date(), 10));
            redisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, dataShop);

        } else {
            //解决缓存穿透问题  缓存空对象
            redisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, "", CACHE_NULL_TTL, TimeUnit.MINUTES);
        }
        return shop;
    }
```

## 封装Redis工具类

基于RedisTemplate封装一个缓存工具类，满足下列需求：

- 方法1：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置TTL过期时间
- 方法2：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置逻辑过期时间，用于处理缓

存击穿问题

- 方法3：根据指定的key查询缓存，并反序列化为指定类型，利用缓存空值的方式解决缓存穿透问题
- 方法4：根据指定的key查询缓存，并反序列化为指定类型，需要利用逻辑过期解决缓存击穿问题

将逻辑进行封装

```java
import cn.hutool.core.date.DateUtil;
import cn.hutool.core.util.BooleanUtil;
import cn.hutool.core.util.ObjectUtil;
import com.dongguo.redis.entity.RedisData;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.stereotype.Component;
import java.time.Duration;
import java.util.Date;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.function.Function;

import static com.dongguo.redis.utils.RedisConstants.*;


@Slf4j
@Component
public class CacheClient {

    private final RedisTemplate redisTemplate;

    private static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10);

    public CacheClient(StringRedisTemplate stringRedisTemplate) {
        this.redisTemplate = stringRedisTemplate;
    }

    public void set(String key, Object value, Long time, TimeUnit unit) {
        redisTemplate.opsForValue().set(key, value, time, unit);
    }
    public void set(String key, Object value, Duration duration) {
        redisTemplate.opsForValue().set(key, value, duration);
    }

    /**
     *设置逻辑过期时间
     * @param key
     * @param value
     * @param time
     * @param unit
     */
    public void setWithLogicalExpire(String key, Object value, Long time, TimeUnit unit) {
        // 设置逻辑过期
        RedisData redisData = new RedisData();
        redisData.setData(value);
        redisData.setExpireTime(DateUtil.offsetSecond(new Date(), (int) unit.toSeconds(time)));
        // 写入Redis
        redisTemplate.opsForValue().set(key, redisData);
    }

    /**
     * 缓存空值
     * @param keyPrefix
     * @param id
     * @param dbFallback
     * @param time
     * @param unit
     * @return
     * @param <R>
     * @param <ID>
     */
    public <R, ID> R cacheShopWithNullValue(
            String keyPrefix, ID id, Function<ID, R> dbFallback, Long time, TimeUnit unit) {
        String key = keyPrefix + id;
        // 1.从redis查询商铺缓存
        Object object = redisTemplate.opsForValue().get(key);
        // 2.判断是否存在
        if (ObjectUtil.isNotEmpty(object)) {
            //缓存查到 返回
            return (R) object;
        }
        //3.缓存的空值   缓存的空字符串""
        if (ObjectUtil.equal(object, "")) {
            return null;
        }

        // 4.不存在，根据id查询数据库
        R r = dbFallback.apply(id);
        // 5.不存在，返回错误
        if (r == null) {
            // 将空值写入redis
            redisTemplate.opsForValue().set(key, "", CACHE_NULL_TTL, TimeUnit.MINUTES);
            // 返回错误信息
            return null;
        }
        // 6.存在，写入redis
        this.set(key, r, time, unit);
        return r;
    }

    /**
     * 逻辑过期
     * @param keyPrefix
     * @param id
     * @param dbFallback
     * @param time
     * @param unit
     * @return
     * @param <R>
     * @param <ID>
     */
    public <R, ID> R queryWithLogicalExpire(
            String keyPrefix, ID id, Function<ID, R> dbFallback, Long time, TimeUnit unit) {
        String key = keyPrefix + id;
        // 1.从redis查询商铺缓存
        Object object = redisTemplate.opsForValue().get(key);
        // 2.判断是否存在
        //缓存的空值   缓存的空字符串""
        if (ObjectUtil.equal(object, "")) {
            return null;
        }
        if (ObjectUtil.isEmpty(object)) {
            //3.不存在
            //查询店铺数据
            R r = dbFallback.apply(id);
            if (ObjectUtil.isNotEmpty(r)) {
                this.setWithLogicalExpire(key, r, time, unit);
            } else {
                //解决缓存穿透问题  缓存空对象
                redisTemplate.opsForValue().set(key, "", CACHE_NULL_TTL, TimeUnit.MINUTES);
            }
            return (R) object;
        }
        // 4.命中，需要先把json反序列化为对象
        RedisData redisData = (RedisData) object;
        R r = (R) redisData.getData();
        Date expireTime = redisData.getExpireTime();
        // 5.判断是否过期
        if (expireTime.after(new Date())) {
            // 5.1.未过期，直接返回店铺信息
            return r;
        }
        // 5.2.已过期，需要缓存重建
        // 6.缓存重建
        // 6.1.获取互斥锁
        String lockKey = LOCK_SHOP_KEY + id;
        boolean isLock = tryLock(lockKey);
        // 6.2.判断是否获取锁成功
        if (isLock) {
            // 6.3.成功，开启独立线程，实现缓存重建
            CACHE_REBUILD_EXECUTOR.submit(() -> {
                try {
                    // 查询数据库
                    R newR = dbFallback.apply(id);
                    // 重建缓存
                    this.setWithLogicalExpire(key, newR, time, unit);
                } catch (Exception e) {
                    throw new RuntimeException(e);
                } finally {
                    // 释放锁
                    unlock(lockKey);
                }
            });
        }
        // 6.4.返回过期的商铺信息
        return r;
    }

    /**
     * 互斥锁
     * @param keyPrefix
     * @param id
     * @param dbFallback
     * @param time
     * @param unit
     * @return
     * @param <R>
     * @param <ID>
     */
    public <R, ID> R queryWithMutex(
            String keyPrefix, ID id, Function<ID, R> dbFallback, Long time, TimeUnit unit) {
        String key = keyPrefix + id;
        // 1.从redis查询商铺缓存
        Object object = redisTemplate.opsForValue().get(key);
        //判空
        if (ObjectUtil.isNotEmpty(object)) {
            //缓存查到 返回
            return (R) object;
        }
        //缓存的空值   缓存的空字符串""
        if (ObjectUtil.equal(object, "")) {
            return null;
        }

        // 4.实现缓存重建
        // 4.1.获取互斥锁
        String lockKey = LOCK_SHOP_KEY + id;
        R r;
        try {
            boolean isLock = tryLock(lockKey);
            // 4.2.判断是否获取成功
            if (!isLock) {
                // 4.3.获取锁失败，休眠并重试
               TimeUnit.MILLISECONDS.sleep(100);
                return queryWithMutex(keyPrefix, id, dbFallback, time, unit);
            }
            // 4.4.获取锁成功，根据id查询数据库
            r = dbFallback.apply(id);
            // 5.不存在，返回错误
            if (r == null) {
                // 将空值写入redis
                redisTemplate.opsForValue().set(key, "", CACHE_NULL_TTL, TimeUnit.MINUTES);
                // 返回错误信息
                return null;
            }
            // 6.存在，写入redis
            this.set(key, r, time, unit);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        } finally {
            // 7.释放锁
            unlock(lockKey);
        }
        // 8.返回
        return r;
    }

    /**
     * 加锁
     * @param key
     * @return
     */
    private boolean tryLock(String key) {
        Boolean flag = redisTemplate.opsForValue().setIfAbsent(key, "1", 10, TimeUnit.SECONDS);
        return BooleanUtil.isTrue(flag);
    }

    /**
     * 解锁
     * @param key
     */
    private void unlock(String key) {
        redisTemplate.delete(key);
    }
}
```

# 优惠券秒杀

## 添加优惠卷

每个店铺都可以发布优惠券，分为平价券和特价券。平价券可以任意购买，而特价券需要秒杀抢购：

![image-20240321200423197](F:\note\image\image-20240321200423197.png)

tb_voucher表：优惠券的基本信息，优惠金额、使用规则等

tb_seckill_voucher表：优惠券的库存、开始抢购时间，结束抢购时间。特价优惠券才需要填写这些信息

平价卷由于优惠力度并不是很大，所以是可以任意领取

而特价券由于优惠力度大，所以就得限制数量，特价卷除了具有优惠卷的基本信息以外，还具有库存，抢购时间，结束时间等等字段
