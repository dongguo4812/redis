# 介绍

Redis Stream是Redis 5.0版本新增加的数据结构。

Redis Stream主要用于消息队列（MQ,Message Queue）,Redis本身是有一个Redis发布订阅(pub/sub)来实现消息队列的功能，但是发布订阅有个缺点就是消息无法持久化，如果出现网络断开、Redis宕机等，消息就会被丢弃。简单来说发布订阅(pub/sub)可以分发消息，但无法记录历史消息。

Redis Stream提供了消息的持久化和主备复制功能、支持自动生成全局唯一ID、支持ack确认消息的模式、支持消费组模式等。可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证消息不丢失。它算是redis自己消息功能的补充。

但是，一般主流MQ都固定了(Kafka/RabbitMQ/RocketMQ/Pulsar)。



# Stream结构

![image-20240302184827243](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403021848746.png)

- Message Content：消息内容

- Consumer group：消费组，通过XGROUP CREATE命令创建，同一个消费组可以有多个消费者

- Last_delivered_id：游标，每个消费组会有个游标last_delivered_id, 任意一个消费者读取了消息都会使游标last_delivered_id往前移动。

- Consumer：消费者，消费组中的消费者

- Pending_ids：消费者会有一个状态变量，用于记录被当前消费已读取但未ack的消息Id，如果客户端没有ack，这个变量里面的消息ID会越来越多，一旦某个消息被ack它就开始减少。这个pending_ids变量在Redis官方被称之为PEL(Pending Entries List),记录了当前已经被客户端读取的消息，但是还没有ack(Acknowledgecharacter：确认字符），它用来确保客户端至少消费了消息一次，而不会在网络传输的中途丢失了没处理

# 常见命令

## 四个特殊符号

### -  +

这两个符号分别代表了Stream中可能出现的最小ID和最大ID。在消费者组中，它们用来定义消息ID的范围，确保消费者可以消费到指定范围内的消息。

### $

表示只消费新的消息。它用于指定从当前Stream中最大的ID开始消费，这意味着只有当新的消息到达并且其ID大于当前最大ID时，这些消息才会被消费。

### >

这个符号用于指定一个绝对的ID，从该ID之后的消息将被消费。如果指定的ID大于当前Stream中的最大ID，那么将不会有消息被消费，直到有新的消息ID大于指定的ID为止。用于XREADGROUP命令，更新消费者组的最后ID。

### *

用于XADD命令，让系统自动生成id，使用当前的时间戳作为消息的ID

## 队列相关指令

### XADD

添加消息到队列末尾，消息ID必须要比上个ID大，默认用*表示自动生成ID，如果指定的Stream队列不存在，则该命令执行时会创建一个新的Stream队列

返回值为生成的消息ID，由两部分组成，毫秒时间戳-该毫秒内产生的第几条消息（从0开始），保证每次生成的id都是最大的。

```shell
127.0.0.1:6379> xadd mystream * userId 11 name zhangsan
1709380483821-0
127.0.0.1:6379> xadd mystream * userId 12 name lisi
1709380494315-0
127.0.0.1:6379> xadd mystream * userId 13 name wangwu
1709380920376-0
```

### XRANGE

XRANGE key start  end count n：用于获取消息列表，可以指定范围，忽略删除的消息

start 表示开始值 -代表最小值

end表示结束值 + 代表最大值

count表示最多获取多少个值

```shell
127.0.0.1:6379> xrange mystream - +
1709380483821-0
userId
11
name
zhangsan
1709380494315-0
userId
12
name
lisi
1709380920376-0
userId
13
name
wangwu
127.0.0.1:6379> XRANGE mystream - + count 1
1709380483821-0
userId
11
name
zhangsan
```

### XREVRANGE

XREVRANGE key end  start  count n ：倒序从大到小获取消息列表

```shell
127.0.0.1:6379> xrevrange mystream + - count 1
1709380920376-0
userId
13
name
wangwu
```

### XDEL

根据ID删除消息

```shell
127.0.0.1:6379> xrange mystream - + 
1709380483821-0
userId
11
name
zhangsan
1709380494315-0
userId
12
name
lisi
1709380920376-0
userId
13
name
wangwu
127.0.0.1:6379> xdel mystream 1709380920376-0
1
127.0.0.1:6379> xrange mystream - + 
1709380483821-0
userId
11
name
zhangsan
1709380494315-0
userId
12
name
lisi
```

### XLEN

获取stream队列消息的长度

```shell
127.0.0.1:6379> xlen mystream
2
```

### XTRIM

XTRIM key MAXLEN |MINID  ：用于对Stream的长度进行截取。

MAXLEN 允许的最大长度，对流进行修剪限制长度

MINID 允许最小id，从某个id值开始比该id值小的将会被抛弃

返回值为删除的长度

#### XTRIM key MAXLEN

```shell
127.0.0.1:6379> xadd mystream * k1 v1
1709383009750-0
127.0.0.1:6379> xadd mystream * k2 v2
1709383013709-0
127.0.0.1:6379> xadd mystream * k3 v3
1709383018126-0
127.0.0.1:6379> xadd mystream * k4 v4
1709383023214-0
127.0.0.1:6379> xadd mystream * k5 v5
1709383026486-0
127.0.0.1:6379> xrange mystream - +
1709383009750-0
k1
v1
1709383013709-0
k2
v2
1709383018126-0
k3
v3
1709383023214-0
k4
v4
1709383026486-0
k5
v5
127.0.0.1:6379> xtrim mystream maxlen 2
3
127.0.0.1:6379> xrange mystream - +
1709383023214-0
k4
v4
1709383026486-0
k5
v5
```

#### XTRIM key MINID

```shell
127.0.0.1:6379> xtrim mystream minid 1709383026486-0
1
127.0.0.1:6379> xrange mystream - +
1709383026486-0
k5
v5
```



### XREAD

xread COUNT [BLOCK milliseconds] STREAMS key ID：用于获取消息，只返回大于指定id的消息

count 最多读取条数

BLOCK 是否以阻塞的方式读取消息 默认不阻塞 milliseconds设置为0 表示永远阻塞

```shell
127.0.0.1:6379> xadd mystream * k1 v1
1709383742211-0
127.0.0.1:6379> xadd mystream * k2 v2
1709383750939-0
127.0.0.1:6379> xadd mystream * k3 v3
1709383757556-0
127.0.0.1:6379> xadd mystream * k4 v4
1709383763107-0
127.0.0.1:6379> xadd mystream * k5 v5
1709383795556-0
127.0.0.1:6379> xrange mystream - +
1709383742211-0
k1
v1
1709383750939-0
k2
v2
1709383757556-0
k3
v3
1709383763107-0
k4
v4
1709383795556-0
k5
```

#### 非阻塞

$：代表特殊ID，表示以当前Stream已经存储的最大的ID作为最后一个ID，当前Stream中不存在大于当前最大ID的消息，如果没有读取到新消息，会返回空数组。

0-0：代表从最小的ID开始获取Stream中的消息，当不指定count，将会返回Stream中的所有消息，注意也可以使用0（00/000也都是可以的)

```shell
127.0.0.1:6379> xread count 2 streams mystream $

127.0.0.1:6379> xread count 2 streams mystream 0
mystream
1709383742211-0
k1
v1
1709383750939-0
k2
v2
127.0.0.1:6379> xread count 2 streams mystream 0-0
mystream
1709383742211-0
k1
v1
1709383750939-0
k2
v2
```

#### 阻塞

一直阻塞在这里

```shell
127.0.0.1:6379> xread count 1 block 0 streams mystream $

```

另起一个客户端，新增一条消息

```shell
[root@redis ~]# redis-cli -a root
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.
127.0.0.1:6379> xadd mystream * k6 v6
"1709385838153-0"
```

此时接收到了消息

```shell
127.0.0.1:6379> xread count 1 block 0 streams mystream $
mystream
1709385838153-0
k6
v6
127.0.0.1:6379> 
```

## 消费组相关指令

### XGROUP CREATE

用于创建消费者组

创建消费者组的时候必须指定id ，id为0表示从头开始消费，为$表示只消费新的消息，

```shell
127.0.0.1:6379> xgroup create mystream groupA $
OK
127.0.0.1:6379> xgroup create mystream groupB 0
OK
127.0.0.1:6379> xgroup create mystream groupC 0
OK
```

### XREADGROUP group

“>” 表示从第一条尚未被消费的消息开始读取

消费组groupB内的消费者consumer1从mystream消息队列中读取所有消息

```shell
127.0.0.1:6379> xreadgroup group groupB consumer1 streams mystream >
1) 1) "mystream"
   2) 1) 1) "1709383742211-0"
         2) 1) "k1"
            2) "v1"
      2) 1) "1709383750939-0"
         2) 1) "k2"
            2) "v2"
      3) 1) "1709383757556-0"
         2) 1) "k3"
            2) "v3"
      4) 1) "1709383763107-0"
         2) 1) "k4"
            2) "v4"
      5) 1) "1709383795556-0"
         2) 1) "k5"
            2) "v5"
      6) 1) "1709385838153-0"
         2) 1) "k6"
            2) "v6"
127.0.0.1:6379> xreadgroup group groupB consumer2 streams mystream >
(nil)
127.0.0.1:6379> xreadgroup group groupC consumer1 streams mystream >
1) 1) "mystream"
   2) 1) 1) "1709383742211-0"
         2) 1) "k1"
            2) "v1"
      2) 1) "1709383750939-0"
         2) 1) "k2"
            2) "v2"
      3) 1) "1709383757556-0"
         2) 1) "k3"
            2) "v3"
      4) 1) "1709383763107-0"
         2) 1) "k4"
            2) "v4"
      5) 1) "1709383795556-0"
         2) 1) "k5"
            2) "v5"
      6) 1) "1709385838153-0"
         2) 1) "k6"
            2) "v6"

```

stream中的消息一旦被消费组里的一个消费者读取了，就不能再被该消费组内的其他消费者读取了（也不能重复消费），即同一个消费组里的消费者不能消费同一条消息。刚才的XREADGROUP命令再执行一次，此时读到的就是空值。

但是，不同消费组的消费者可以消费同一条消息。



消费组的目的：让组内的多个消费者共同分担读取消息，所以，我们通常会让每个消费者读取部分消息，从而实现消息读取负载在多个消费者间是均衡分布的



问题1：基于Stream实现的消息队列，如何保证消费者在发生故障或宕机重启后，仍然可以读取未处理完的消息？

Streams会自动使用内部队列（也称为PENDING List）留存消费组里每个消费者读取的消息保底措施，直到消费者使用XACK命令通知 Streams"消息已经处理完成"。

消费确认增加了消息的可靠性，一般在业务处理完成之后，需要执行XACK命令确认消息已经被消费完成

![image-20240303144023483](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403031440900.png)

### XPENDING

查询每个消费组内所有消息[已读但未确认的消息]

```shell
127.0.0.1:6379> xpending mystream groupB
1) (integer) 6
2) "1709383742211-0"
3) "1709385838153-0"
4) 1) 1) "consumer1"
      2) "6"
```

1709383742211-0为所有消费者读取的消息最小ID

1709385838153-0为所有消费者读取的消息最大ID

consumer1读取了6条消息



查看消费者消费了哪些消息

```shell
127.0.0.1:6379> xpending mystream groupB - + 10 consumer1
1) 1) "1709383742211-0"
   2) "consumer1"
   3) (integer) 20703503
   4) (integer) 1
2) 1) "1709383750939-0"
   2) "consumer1"
   3) (integer) 20703503
   4) (integer) 1
3) 1) "1709383757556-0"
   2) "consumer1"
   3) (integer) 20703503
   4) (integer) 1
4) 1) "1709383763107-0"
   2) "consumer1"
   3) (integer) 20703503
   4) (integer) 1
5) 1) "1709383795556-0"
   2) "consumer1"
   3) (integer) 20703503
   4) (integer) 1
6) 1) "1709385838153-0"
   2) "consumer1"
   3) (integer) 20703503
   4) (integer) 1
```



### XACK

向消息队列确认消息处理已完成

```shell
127.0.0.1:6379> xack mystream groupB 1709385838153-0
(integer) 1
127.0.0.1:6379> xpending mystream groupB - + 10 consumer1
1) 1) "1709383742211-0"
   2) "consumer1"
   3) (integer) 20864216
   4) (integer) 1
2) 1) "1709383750939-0"
   2) "consumer1"
   3) (integer) 20864216
   4) (integer) 1
3) 1) "1709383757556-0"
   2) "consumer1"
   3) (integer) 20864216
   4) (integer) 1
4) 1) "1709383763107-0"
   2) "consumer1"
   3) (integer) 20864216
   4) (integer) 1
5) 1) "1709383795556-0"
   2) "consumer1"
   3) (integer) 20864216
   4) (integer) 1
```

未确认之前一共6条消息，确认1条后该消息就被删除了，还剩5条消息

## XINFO

用于打印Stream\Consumer\Group的详细信息

Stream：

```shell
127.0.0.1:6379> xinfo stream mystream
 1) "length"
 2) (integer) 6
 3) "radix-tree-keys"
 4) (integer) 1
 5) "radix-tree-nodes"
 6) (integer) 2
 7) "last-generated-id"
 8) "1709385838153-0"
 9) "groups"
10) (integer) 3
11) "first-entry"
12) 1) "1709383742211-0"
    2) 1) "k1"
       2) "v1"
13) "last-entry"
14) 1) "1709385838153-0"
    2) 1) "k6"
       2) "v6"
```

Consumer：

```shell
127.0.0.1:6379> xinfo consumers mystream groupB
1) 1) "name"
   2) "consumer1"
   3) "pending"
   4) (integer) 5
   5) "idle"
   6) (integer) 21180585
```

Group：

```shell
127.0.0.1:6379> xinfo groups mystream
1) 1) "name"
   2) "groupA"
   3) "consumers"
   4) (integer) 0
   5) "pending"
   6) (integer) 0
   7) "last-delivered-id"
   8) "1709385838153-0"
2) 1) "name"
   2) "groupB"
   3) "consumers"
   4) (integer) 1
   5) "pending"
   6) (integer) 5
   7) "last-delivered-id"
   8) "1709385838153-0"
3) 1) "name"
   2) "groupC"
   3) "consumers"
   4) (integer) 1
   5) "pending"
   6) (integer) 6
   7) "last-delivered-id"
   8) "1709385838153-0"
```

