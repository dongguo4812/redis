# Redis内存管理

## 1.Redis的最大内存

`maxmemory <bytes>`：设置Redis实例可以使用的最大内存量，单位是字节。

![image-20240316201416898](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403162014141.png)

## 2.redis默认最大内存

如果没有设置Redis的最大内存，默认最大内存为0。

```shell
127.0.0.1:6379> config get maxmemory
1) "maxmemory"
2) "0"
```

这并不意味着最大内存为0，这表示在64位操作系统下不限制内存大小，理论上可达到物理内存上限。

在32位操作系统下最多使用3GB内存。

## 3.一般生产如何决定最大内存的值。

一般推荐Redis设置最大内存为最大物理内存的四分之三

## 4.如何修改redis内存设置

### 4.1.通过修改redis.cong配置文件（永久有效）

如设置Redis的最大内存使用量为1GB

```shell
maxmemory 1073741824
```

### 4.2通过命令修改（redis服务端重启失效）

```shell
127.0.0.1:6379> config set maxmemory 1073741824
OK
127.0.0.1:6379> config get maxmemory
1) "maxmemory"
2) "1073741824"
```

## 5.如何查看Redis内存情况

### 5.1 `info memory`获取Redis内存使用情况

```shell
127.0.0.1:6379> info memory
# Memory
used_memory:338305280
used_memory_human:322.63M
used_memory_rss:167133184
used_memory_rss_human:159.39M
used_memory_peak:343218592
used_memory_peak_human:327.32M
used_memory_peak_perc:98.57%
used_memory_overhead:856192
used_memory_startup:810072
used_memory_dataset:337449088
used_memory_dataset_perc:99.99%
allocator_allocated:338350296
allocator_active:338698240
allocator_resident:340955136
total_system_memory:1019568128
total_system_memory_human:972.34M
used_memory_lua:62464
used_memory_lua_human:61.00K
used_memory_scripts:2928
used_memory_scripts_human:2.86K
number_of_cached_scripts:10
maxmemory:1073741824
maxmemory_human:1.00G
maxmemory_policy:noeviction
allocator_frag_ratio:1.00
allocator_frag_bytes:347944
allocator_rss_ratio:1.01
allocator_rss_bytes:2256896
rss_overhead_ratio:0.49
rss_overhead_bytes:-173821952
mem_fragmentation_ratio:0.49
mem_fragmentation_bytes:-171131088
mem_not_counted_for_evict:0
mem_replication_backlog:0
mem_clients_slaves:0
mem_clients_normal:41024
mem_aof_buffer:0
mem_allocator:jemalloc-5.1.0
active_defrag_running:0
lazyfree_pending_objects:0
lazyfreed_objects:0
```

1. used_memory
   - **描述**: 表示Redis当前已分配的字节数大小。
   - **意义**: 这个值反映了Redis当前实际使用的内存量。
2. used_memory_human
   - **描述**: `used_memory` 的可读形式，通常以MB、GB等单位表示。
   - **意义**: 提供了一个更直观的视图来查看Redis使用的内存量。
3. used_memory_rss
   - **描述**: 常驻集大小（Resident Set Size，RSS），表示操作系统为Redis进程分配的物理内存量。
   - **意义**: 这个值通常大于 `used_memory`，因为RSS包括了Redis使用的所有内存，包括可能未使用的内存碎片。
4. used_memory_peak
   - **描述**: Redis的内存使用峰值，以字节为单位。
   - **意义**: 这个值表示Redis在生命周期中曾经使用过的最大内存量。
5. used_memory_peak_human
   - **描述**: `used_memory_peak` 的可读形式。
   - **意义**: 提供了一个更直观的视图来查看Redis使用过的最大内存量。
6. used_memory_rss_human
   - **描述**: `used_memory_rss` 的可读形式。
   - **意义**: 提供了Redis进程占用物理内存的直观视图。
7. mem_fragmentation_ratio
   - **描述**: 内存碎片率，表示 `used_memory_rss` 与 `used_memory` 的比值。
   - **意义**: 这个值可以帮助你了解Redis的内存碎片情况。如果值大于1，表示存在内存碎片；值越大，碎片越多。
8. mem_allocator
   - **描述**: Redis使用的内存分配器，如jemalloc、libc等。
   - **意义**: 不同的内存分配器可能有不同的性能和碎片特性。

### 5.2`config get maxmemory`获取当前Redis实例配置的 `maxmemory` 值

## 6.如果内存使用超出了设置的最大值会怎样

将最大内存设置为1字节，超出内存限制，触发OOM（Out Of Memory，内存溢出）错误。

```shell
127.0.0.1:6379> config set maxmemory 1
OK
127.0.0.1:6379> config get maxmemory
1) "maxmemory"
2) "1"
127.0.0.1:6379> set k1 v1111111
(error) OOM command not allowed when used memory > 'maxmemory'.
```

当内存使用接近或达到`maxmemory`预设限制时，Redis会根据配置的内存淘汰策略（eviction policy）来删除一些键以释放内存。

# Redis过期数据删除策略

在学习Redis缓存的时候我们说过，可以通过expire命令给Redis的key设置TTL（存活时间）。当key的TTL到期以后，再次访问name返回的是nil，说明这个key已经不存在了，对应的内存也得到释放。从而起到内存回收的目的。

这里有个问题需要我们思考：

是不是TTL到期就立即删除了呢？



Redis 采用了多种过期数据删除策略，主要包括定时删除、惰性删除和定期删除

## 定时删除

当数据到达过期时间时，由一个定时器任务立即执行对key的删除操作。

优点：可以节约内存，确保过期的key在到达过期时间时能够迅速被删除，从而释放不必要的内存占用。

 缺点：CPU性能消耗大，也会影响数据的读取操作。尤其是在高并发场景下，可能影响Redis服务器的响应时间和指令吞吐量。

## 惰性删除

当客户端尝试访问一个 key 时，Redis 会先检查这个 key 是否已经过期。如果 key 已经过期，Redis 就会删除这个 key，并且不会返回任何值给客户端。

优点：节省CPU资源，只有在key被访问时才进行过期检查。

缺点：如果过期数据很多且长时间没有被访问到，那么这些过期数据就会一直占用内存。



## 定期删除

Redis 默认会每隔一段时间随机抽取一些设置了过期时间的 key 进行检查，如果发现这些 key 已经过期，就会将它们删除。

例如Redis每隔100ms检查一些设置了过期时间的key是否可过，过期则进行删除。注意Redis不是将所有的key都检查一遍而是随机抽取一部分数据。

优点：资源消耗比较低

缺点：可能存在过期key在一定时间内没有被删除的情况，尤其是在高负载或大量key过期时。



定期删除策略的难点是确定删除操作执行的时长和频率：如果删除操作执行的太频繁或者执行的时间太长，定期删除就会和定时删除一样。如果删除操作执行的

频率过低或者执行的时间太短，定期删除又会和惰性删除一样了。

如果采用定期删除策略的话，服务器必须根据情况，合理的设置删除操作的执行时长和执行频率。

执行时长由Redis系统的性能决定。

执行频率可通过redis.conf设置：`hz 10`  表示1秒执行10次惰性删除

![image-20240316221258766](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403162213929.png)

执行频率有两种规则

SLOW模式规则：

1. **执行频率**：受到`server.hz`（默认为10）的影响，即每秒执行10次，每次执行的周期大约为100ms。
2. **执行时长**：每次执行清理操作的时间不超过执行周期的25%，即默认不超过25ms。这是为了确保定期删除不会长时间地阻塞Redis服务器，影响其他操作的响应性。
3. **清理过程**：逐个遍历数据库（db），再逐个遍历数据库中的桶（bucket），每次从桶中抽取20个键来判断是否过期。
4. **抽样与结束条件**：如果在规定的时间内（25ms）没有达到时间上限，并且已检查的过期键的比例大于10%，Redis会再次进行抽样检查。如果这两个条件中的任何一个不满足，则结束当前的清理过程。

FAST模式规则：（过期key比例大于10%时执行 ）

1. **执行频率**：FAST模式的执行频率受到`beforeSleep()`调用频率的影响，但Redis确保两次FAST模式之间的间隔不低于2ms。
2. **执行时长**：FAST模式每次执行清理的时间不超过1ms，这比SLOW模式更短，以确保快速清理过期键，减少潜在的性能影响。
3. **清理过程**：与SLOW模式类似，FAST模式也是逐个遍历数据库和桶，并抽取20个键来判断是否过期。
4. **触发条件**：FAST模式有一个额外的触发条件，即当过期键的比例小于10%时，FAST模式不会被执行。这是为了避免在过期键较少的情况下进行不必要的清理操作。

## 总结

在实际应用中，Redis结合了定期删除和惰性删除两种策略来管理过期数据。这样做可以在保证内存有效利用的同时，避免因为大量过期数据未被及时删除而导致的内存泄漏问题。通过合理地设置定期删除任务的执行频率和时长，以及结合惰性删除来处理访问时的过期检查，Redis能够在性能和内存使用之间取得一个较好的平衡。

但是如果定期删除没有抽查到、惰性删除没有被访问到的过期数据还是会堆积在内存中，导致Redis内存空间耗尽。

# Redis内存淘汰策略

当内存使用超过预设限制时会触发内存淘汰策略。

`redis.conf`:

![image-20240316223623902](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403162236006.png)

Redis支持8种内存淘汰策略：

- noeviction： 不淘汰任何key，但是内存满时不允许写入新数据返回error，默认就是这种策略。
- volatile-ttl： 对设置了TTL的key，比较key的剩余TTL值，TTL越小越先被淘汰
- allkeys-random：对全体key ，随机进行淘汰。
- volatile-random：对设置了TTL的key ，随机进行淘汰。
- allkeys-lru： 对全体key，基于LRU算法进行淘汰
- volatile-lru： 对设置了TTL的key，基于LRU算法进行淘汰
- allkeys-lfu： 对全体key，基于LFU算法进行淘汰
- volatile-lfu： 对设置了TTL的key，基于LFI算法进行淘汰

比较容易混淆的有两个：

- - LRU（Least Recently Used），最少最近使用。用当前时间减去最后一次访问时间，这个值越大则淘汰优先级越高。即淘汰最长时间未使用的数据。
  - LFU（Least Frequently Used），最少频率使用。会统计每个key的访问频率，值越小淘汰优先级越高。即淘汰一定时间内访问次数最少得数据。



分为两个维度：从过期键中筛选，从所有键中筛选

分为四个方面：LRU、LFU、random、ttl

最后用一副图来描述当前的这个流程

![image-20240316223742444](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403162237748.png)

## 内存淘汰策略如何选择

在所有的 key 都是最近最经常使用，那么就需要选择allkeys-lru 淘汰最近最不经常使用的key，如果你不确定使用哪种策略，那么推荐使用allkeys-lru

如果所有的key 的访问概率都是差不多的，那么可以选用allkeys-random策略随机淘汰数据

如果对数据有足够的了解，能够为key指定过期时间，那么可以选择volatile-ttl 淘汰即将过期的数据

## 如何设置内存淘汰策略

1.通过redis.conf配置文件（永久用小）

```shell
maxmemory-policy noeviction
```

2.使用conf命令（重启失效）

```shell
config set maxmemory-policy noeviction
```



# 区分惰性删除（Lazy Deletion）与 `lazyfree-lazy-eviction`

惰性删除是Redis处理过期键或删除操作的一种策略，它不会在键过期或需要删除时立即执行删除操作，而是等到这些键再次被访问时才执行删除。这可以避免不必要的CPU和内存开销。

`lazyfree-lazy-eviction`：当`lazyfree-lazy-eviction`设置为`yes`时，如果Redis因为内存满而无法容纳新写入的数据。Redis不会立即执行删除操作来释放这些键所占用的内存。会将这些键标记为待删除，并在后台异步地执行实际的删除操作。

先由内存淘汰策略选择哪些键进行删除，再由lazyfree-lazy-eviction决定删除操作的执行方式。