# 天猫聚划算热门商品分页查询

1.对于高并发的场景，就不用考虑只用mysql了。

2.在项目启动时，我们会将mysql里参加聚划算活动的商品预热到redis中，然后可以采用定时任务判断商品参加的活动时间决定上线还是下线。

3.商品列表支持分页功能，一页展示20条热门商品。

分析：对于可以分页的redis数据结构我们应该立马就会想到了list。

创建商品类Product

```java
import io.swagger.v3.oas.annotations.media.Schema;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.math.BigDecimal;

/**
 * @Author: Administrator
 * @Date: 2024-02-27
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
@Schema(title = "商品表", description = "聚划算活动商品表")
public class Product {
    //产品id
    private Long id;
    //产品名称
    private String name;
    //产品价格
    private BigDecimal price;
    //产品描述
    private String detail;
}
```

JhsTaskService模拟定时任务：创建一个线程，每分钟重建最新的商品列表

```java
import static com.dongguo.redis.utils.CacheKeyUtil.CACHE_JHS_KEY;

/**
 * @Author: Administrator
 * @Date: 2024-02-27
 */
@Service
@Slf4j
public class JhsTaskService {
    @Resource
    private RedisTemplate redisTemplate;

    @PostConstruct
    public void initJhs() {
        log.info("定时任务 淘宝聚划算功能获取商品列表 模拟=====" + DateUtil.now());
        new Thread(() -> {
            while (true) {
                List<Product> productList = getProducts();
                //删除缓存数据
                redisTemplate.delete(CACHE_JHS_KEY);
                //将最新获取到的聚划算商品缓存到redis
                redisTemplate.opsForList().leftPushAll(CACHE_JHS_KEY, productList);
                //设置过期时间
                redisTemplate.expire(CACHE_JHS_KEY, 1, TimeUnit.DAYS);
                log.info("定时任务 淘宝聚划算功能获取商品列表 已刷新");
                //模拟定时。间隔1分钟重新获取最新的聚划算商品
                try {
                    TimeUnit.MINUTES.sleep(1);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            }
        }, "t1").start();
    }


    /**
     * 模拟从数据库读取20件特价商品，用于加载到聚划算的页面中
     *
     * @return
     */
    public List<Product> getProducts() {
        List<Product> productList = new ArrayList<>(20);
        for (int i = 0; i < 20; i++) {
            Random random = new Random();
            //模拟生成id，随着定时任务的执行商品数不断增加
            long id = random.nextLong(10000);
            Product product = new Product(id, "product" + id, new BigDecimal(id), "detail" + id);
            productList.add(product);
        }
        return productList;
    }
}
```

JhsProductService

```java
import cn.hutool.core.collection.CollUtil;
import com.dongguo.redis.entity.Product;
import jakarta.annotation.Resource;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;

import java.util.List;

import static com.dongguo.redis.utils.CacheKeyUtil.CACHE_JHS_KEY;


/**
 * @Author: Administrator
 * @Date: 2024-02-27
 */
@Service
@Slf4j
public class JhsProductService {

    @Resource
    private RedisTemplate redisTemplate;
    @Autowired
    private JhsTaskService jhsTaskService;
    
    public List<Product> findJhsProductPage(int page, int size) {
        List productList;
        long start = (page - 1) * size;
        long end = start + size - 1;
        try {
            //查缓存
            productList = redisTemplate.opsForList().range(CACHE_JHS_KEY, start, end);
            if (CollUtil.isEmpty(productList)) {
                //可能查到的列表为空，说明正在重建缓存列表。需要查询数据库获取参加聚划算最新的商品列表,并将商品列表缓存到redis中
                productList = jhsTaskService.getProducts();
                //将最新获取到的聚划算商品缓存到redis
                redisTemplate.opsForList().leftPushAll(CACHE_JHS_KEY, productList);
                //设置过期时间
                redisTemplate.expire(CACHE_JHS_KEY, 1, TimeUnit.DAYS);
            }
        } catch (Exception e) {
            log.info("查询redis缓存失败 exception:" + e.getMessage());
            //这里异常一般是redis瘫痪或网络超时， 查询数据库
            productList = jhsTaskService.getProducts();
        }
        return productList;
    }
}
```

JhsProductController实现分页查询

```java
import com.dongguo.redis.entity.Product;
import com.dongguo.redis.service.JhsProductService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.annotation.Resource;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

/**
 * @Author: Administrator
 * @Date: 2024-02-27
 */
@RestController
@RequestMapping("/jhs")
@Tag(
        name = "JhsProductController",
        description = "聚划算控制器接口")
public class JhsProductController {

    @Resource
    private JhsProductService jhsProductService;


    /***
     * 分页查询聚划算商品
     */
    @Operation(
            summary = "findJhsProductPage",
            description = "分页查询聚划算商品，并返回响应结果信息"

    )
    @GetMapping("/findJhsProductPage")
    public List<Product> findJhsProductPage(@RequestParam(value = "page") int page,@RequestParam(value = "size") int size) {
        return jhsProductService.findJhsProductPage(page, size);
    }
}
```

## 问题：缓存击穿

定时任务会周期性的重建热门商品数据，在高并发场景下，删除热门商品重新缓存新的热门商品列表时的这一瞬间，可能还会存在大量的请求查询商品列表。这些请求查询redis缓存没有命中，导致大量的请求打到数据库上造成了缓存击穿。



## 解决方案

### 1.使用互斥锁

JhsTaskService这里将淘宝聚划算功能获取商品列表加入到缓存的代码注释，模拟重建缓存还没生成最新的商品列表的那一瞬间。在redisTemplate.opsForList().leftPushAll(CACHE_JHS_KEY, productList);代码行打上Thread级别的断点

```java
import cn.hutool.core.date.DateUtil;
import com.dongguo.redis.entity.Product;
import jakarta.annotation.PostConstruct;
import jakarta.annotation.Resource;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.concurrent.TimeUnit;

import static com.dongguo.redis.utils.CacheKeyUtil.CACHE_JHS_KEY;

/**
 * @Author: Administrator
 * @Date: 2024-02-27
 */
@Service
@Slf4j
public class JhsTaskService {
    @Resource
    private RedisTemplate redisTemplate;

    @PostConstruct
    public void initJhs() {
        log.info("定时任务 淘宝聚划算功能获取商品列表 模拟=====" + DateUtil.now());
        new Thread(() -> {
            while (true) {
                List<Product> productList = getProducts();
                //删除缓存数据
                redisTemplate.delete(CACHE_JHS_KEY);
                //将最新获取到的聚划算商品缓存到redis
                redisTemplate.opsForList().leftPushAll(CACHE_JHS_KEY, productList);
                //设置过期时间
                redisTemplate.expire(CACHE_JHS_KEY, 1, TimeUnit.DAYS);
                log.info("定时任务 淘宝聚划算功能获取商品列表 已刷新");
                //模拟定时。间隔1分钟重新获取最新的聚划算商品
                try {
                    TimeUnit.MINUTES.sleep(1);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            }
        }, "t1").start();
    }


    /**
     * 模拟从数据库读取20件特价商品，用于加载到聚划算的页面中
     *
     * @return
     */
    public List<Product> getProducts() {
        List<Product> productList = new ArrayList<>(20);
        for (int i = 0; i < 20; i++) {
            Random random = new Random();
            //模拟生成id，随着定时任务的执行商品数不断增加
            long id = random.nextLong(10000);
            Product product = new Product(id, "product" + id, new BigDecimal(id), "detail" + id);
            productList.add(product);
        }
        return productList;
    }
}
```

JhsProductService：通过加锁的方式解决缓存击穿

```java
    /**
     * 通过加锁的方式解决缓存击穿
     *
     * @param page
     * @param size
     * @return
     */
    public List<Product> findJhsProductPage2(int page, int size) {
        List productList;
        long start = (page - 1) * size;
        long end = start + size - 1;
        try {
            //查缓存
            productList = redisTemplate.opsForList().range(CACHE_JHS_KEY, start, end);
            if (CollUtil.isEmpty(productList)) {
                //双重校验锁
                synchronized (this) {
                    productList = redisTemplate.opsForList().range(CACHE_JHS_KEY, start, end);
                    if (CollUtil.isEmpty(productList)) {
                        //可能查到的列表为空，说明正在重建缓存列表。需要查询数据库获取参加聚划算最新的商品列表,并将商品列表缓存到redis中
                        productList = jhsTaskService.getProducts();
                        //将最新获取到的聚划算商品缓存到redis
                        redisTemplate.opsForList().leftPushAll(CACHE_JHS_KEY, productList);
                        //设置过期时间
                        redisTemplate.expire(CACHE_JHS_KEY, 1, TimeUnit.DAYS);
                    }
                }
            }
        } catch (Exception e) {
            log.info("查询redis缓存失败 exception:" + e.getMessage());
            //这里异常一般是redis瘫痪或网络超时， 查询数据库
            productList = jhsTaskService.getProducts();
        }
        return productList;
    }
```

JhsProductController调用jhsProductService.findJhsProductPage2()

```java
    /***
     * 分页查询聚划算商品
     */
    @Operation(
            summary = "findJhsProductPage",
            description = "分页查询聚划算商品，并返回响应结果信息"

    )
    @GetMapping("/findJhsProductPage")
    public List<Product> findJhsProductPage(@RequestParam(value = "page") int page,@RequestParam(value = "size") int size) {
        return jhsProductService.findJhsProductPage2(page, size);
    }
```

在缓存重建代码执行到redisTemplate.opsForList().leftPushAll(CACHE_JHS_KEY, productList);时，请求分页查询聚划算商品接口。缓存中查不到，获取锁后查询数据库并将商品列表缓存到redis中

### 2.使用多缓存策略，差异失效时间

这里使用的是两个不同key的redis缓存，当然也可以是多级缓存，比如ehcache+redis。

![image-20240312074452371](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403120745218.png)

定时任务将商品数据保存到redis缓存A、缓存B中，缓存A的有效时间比缓存B短，所以在业务访问时，先查缓存A，由缓存B做兜底。

JhsTaskService：

在redisTemplate.opsForList().leftPushAll(CACHE_JHS_A_KEY, productList);所在代码行打上Thread级别断点

```java
    @PostConstruct
    public void initJhs() {
        log.info("定时任务 淘宝聚划算功能获取商品列表 模拟=====" + DateUtil.now());
        new Thread(() -> {
            while (true) {
                List<Product> productList = getProducts();
                //删除缓存数据
                redisTemplate.delete(CACHE_JHS_B_KEY);
                //将最新获取到的聚划算商品缓存到redis
                redisTemplate.opsForList().leftPushAll(CACHE_JHS_B_KEY, productList);
                //设置过期时间
                redisTemplate.expire(CACHE_JHS_B_KEY, 2, TimeUnit.DAYS);

                //保证删除缓存B时，缓存A还能够命中,删除缓存A时，缓存B已经重建
                redisTemplate.delete(CACHE_JHS_A_KEY);
                redisTemplate.opsForList().leftPushAll(CACHE_JHS_A_KEY, productList);
                //设置过期时间
                redisTemplate.expire(CACHE_JHS_A_KEY, 1, TimeUnit.DAYS);
              /**
                //删除缓存数据
                redisTemplate.delete(CACHE_JHS_KEY);
                //将最新获取到的聚划算商品缓存到redis
                redisTemplate.opsForList().leftPushAll(CACHE_JHS_KEY, productList);
                //设置过期时间
                redisTemplate.expire(CACHE_JHS_KEY, 1, TimeUnit.DAYS); **/
                log.info("定时任务 淘宝聚划算功能获取商品列表 已刷新");
                //模拟定时。间隔1分钟重新获取最新的聚划算商品
                try {
                    TimeUnit.MINUTES.sleep(1);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            }
        }, "t1").start();
    }
```



先查缓存A，缓存A中没有再查缓存B。由于先更新缓存B，再更新缓存A。所以缓存B时能命中的并且是最新数据。

JhsProductService：

在 productList = redisTemplate.opsForList().range(CACHE_JHS_A_KEY, start, end);代码行打上Thread级别断点

```java
    /**
     * 多缓存策略
     *
     * @param page
     * @param size
     * @return
     */
    public List<Product> findJhsProductPage3(int page, int size) {
        List productList;
        long start = (page - 1) * size;
        long end = start + size - 1;
        try {
            //查缓存A
            productList = redisTemplate.opsForList().range(CACHE_JHS_A_KEY, start, end);
            if (CollUtil.isEmpty(productList)) {
                //不存在 查缓存B
                productList = redisTemplate.opsForList().range(CACHE_JHS_B_KEY, start, end);
                //差异失效时间 缓存A为空，缓存B的缓存已经重建一定有数据，所以无需判断是否为空
                log.info("缓存B命中");
            } else {
                log.info("缓存A命中");
            }
        } catch (Exception e) {
            log.info("查询redis缓存失败 exception:" + e.getMessage());
            //这里异常一般是redis瘫痪或网络超时， 查询数据库
            productList = jhsTaskService.getProducts();
        }
        return productList;
    }
}
```

JhsProductController：调用jhsProductService.findJhsProductPage3()

```java
    /***
     * 分页查询聚划算商品
     */
    @Operation(
            summary = "findJhsProductPage",
            description = "分页查询聚划算商品，并返回响应结果信息"

    )
    @GetMapping("/findJhsProductPage")
    public List<Product> findJhsProductPage(@RequestParam(value = "page") int page,@RequestParam(value = "size") int size) {
        return jhsProductService.findJhsProductPage3(page, size);
    }
```

在缓存重建代码执行到redisTemplate.opsForList().leftPushAll(CACHE_JHS_A_KEY, productList);时，请求分页查询聚划算商品接口。缓存A未命中，缓存B命中

