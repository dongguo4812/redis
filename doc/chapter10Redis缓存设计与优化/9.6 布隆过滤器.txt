通常我们会遇到很多要判断一个元素是否在某个集合中的业务场景,一般想到的是将集合中所有元素保存起来,然后通过比较确定。链表、树、哈希表等等数据结构都是这种思路。

但是随着集合中元素的增加,我们需要的存储空间也会呈现线性增长,最终达到瓶颈。同时检索速度也越来越慢，上述三种结构的检索时间复杂度分别为0(n)，O(logn)，0(1)，这个时候，布隆过滤器(Bloom Filter)就应运而生

![image-20240311080135789](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403110801024.png)

# 布隆过滤器

布隆过滤器（英语：Bloom Filter）是 1970 年由布隆提出的。它实际上是一个很长的初始值都为0的二进制数组(00000000)加一系列随机hash算法映射函数，主要用于判断一个元素是否在集合中。然而，与标准的set数据结构相比，布隆过滤器的检索结果并不是完全准确的。

当判断元素是否存在时，如果返回结果存在，实际中元素不一定真的存在；但如果返回不存在，则肯定不存在。

因此，布隆过滤器在判断去重时有一定的误判概率。这种误判主要发生在过滤器没有添加过的元素上，而对于已经添加过的元素，布隆过滤器则不会发生误判。

![image-20240310221253378](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403102213241.png)

布隆过滤器可以添加元素，但是不能删除元素，因为设计hash值判断，删掉元素会增加误判率。

## 原理

### 添加key时

使用多个hash函数对key进行hash运算得到一个整数索引值,对位数组长度进行取模运算得到一个位置,每个hash函数都会得到一个不同的位置，将这几个位置都置1就完成了add操作。

### 查询key时

只要有其中一位是零就表示这个key不存在,但如果都是1,则不一定存在对应的key。



### hash冲突导致数据不精准

#### 哈希碰撞

哈希函数的概念是：将任意大小的输入数据转换成特定大小的输出数据的函数，转换后的数据称为哈希值或哈希编码，也叫散列值

![image-20240311082033500](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403110820636.png)

如果两个散列值是不相同的（根据同一函数）那么这两个散列值的原始输入也是不相同的。

这个特性是散列函数具有确定性的结果，具有这种性质的散列函数称为单向散列函数。

散列函数的输入和输出不是唯一对应关系的，如果两个散列值相同，两个输入值很可能是相同的，但也可能不同，这种情况称为“散列碰撞(collision)”。

用hash表存储大数据量时，空间效率还是很低，当只有一个hash函数时，还很容易发生哈希碰撞。



**所以布隆过滤器采用多次hash函数，减少哈希碰撞的概率。**

当有变量被加入集合时，通过N个映射函数将这个变量映射成位图中的N个点，把它们置为1（假定有两个变量都通过3个映射函数）。

obj1第一次hash落到索引为1的位置，第二次hash落到索引为3的位置，第三次hash落到索引为12的位置。

obj2第一次hash落到索引为3的位置，第二次hash落到索引为8的位置，第三次hash落到索引为13的位置。

![](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403110812827.png)

查询某个变量的时候我们只要看看这些点是不是都是 1，如果这些点，有任何一个为零则被查询变量一定不在。如果都是 1，则被查询变量很可能存在，

**为什么说是可能存在,而不是一定存在呢?**

那是因为映射函数本身就是散列函数,散列函数是会有碰撞的。(见上图3号坑两个对象）

正是基于布隆过滤器的快速检测特性,我们可以在把数据写入数据库时，使用布隆过滤器做个标记。当缓存缺失后,应用查询数据库时,可以通过查询布隆过滤器快速判断数据是否存在。如果不存在,就不用再去Redis缓存、数据库中查询了。可能存在，再去查Redis缓存、数据库。

这样一来,即使发生缓存穿透了,大量请求只会查询Redis和布隆过滤器,而不会积压到数据库，也就不会影响数据库的正常运行。布隆过滤器可以使用Redis实现，本身就能承担较大的并发访问压力。

