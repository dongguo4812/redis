redis官网在分布式锁模块](https://redis.io/docs/manual/patterns/distributed-locks/)作者提到使用RedLock算法实现分布式锁，在Java中的实现是Redisson。

# Redis作者为什么会提出RedLck算法实现分布式锁呢？

## 基于SETNX的分布式锁有什么问题呢？

之前redis分布式锁的案例都是单机redis，存在单点故障。

那么使用主从+哨兵或者Cluster集群会存在什么问题呢？

![image-20240314143021181](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403141430135.png)

线程A 获取锁成功后，将键值对写入redis 的 master节点，在 redis将该键值对同步到slave节点之前， master发生了故障。redis触发故障转移,其中一个slave升级为新的master,此时新上位的master并不包含线程A写入的键值对,因此线程B尝试获取锁时可以成功拿到锁,此时相当于有两个线程都获取到了锁。我们使用分布式锁就是为了实现同一时间只能有线程获取锁成功，同一时间两个或以上的线程获取到锁是不被允许的。问题的根源还是由于主从数据不一致造成的。

## 提出RedLock算法解决这个问题

Redis提供了RedLock算法，用来实现基于多个实例的分布式锁。

锁变量由多个实例维护，即使有实例发生了故障，锁变量仍然是存在的，客户端还是可以完成锁操作。

RedLock算法是实现高可靠分布式锁的一种有效解决方案，可以再实际开发中使用。

## RedLock算法

RedLock算法为了解决数据不一致的问题，直接舍弃了异步复制，只是用master节点，舍弃slave节点，保证可用性。

加锁：依次尝试从N个master实例获取锁，客户端设置一个超时时间，防止客户端与一台宕机的reids主节点获取锁导致长期处于阻塞状态，如果一个实例不可用，客户端会尝试与其他Redis实例请求获取锁。

客户端只有在满足一下两个条件时才认为加锁成功：1.至少在N/2 + 1个redis实例上获取到锁；2.客户端获取锁的总耗时没有超过锁的有效时间。

解锁：在所有实例上进行解锁，即使某些redis实例没有加锁成功。



# RedLock的实现Redisson实战

## pom引入Redisson依赖

```xml
		<dependency>
			<groupId>org.redisson</groupId>
			<artifactId>redisson</artifactId>
		</dependency>
```

## 单实例redisson实现分布式锁

### Redisson配置

```java
import org.redisson.Redisson;
import org.redisson.api.RedissonClient;
import org.redisson.config.Config;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;

import java.io.Serializable;

/**
 * redis序列化工具类
 */

@Configuration
public class RedisConfig {


    /**
     * @param lettuceConnectionFactory
     * @return redis序列化的工具配置类
     * 1) "order:696"  序列化过
     * 2) "\xac\xed\x00\x05t\x00\order:696"   没有序列化过
     */
    @Bean
    public RedisTemplate<String, Serializable> redisTemplate(LettuceConnectionFactory lettuceConnectionFactory) {
        RedisTemplate<String, Serializable> redisTemplate = new RedisTemplate<>();
        redisTemplate.setConnectionFactory(lettuceConnectionFactory);
        //设置key序列化方式string
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        //设置value的序列化方式json
        redisTemplate.setValueSerializer(new GenericJackson2JsonRedisSerializer());
        redisTemplate.setHashKeySerializer(new StringRedisSerializer());
        redisTemplate.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());
        redisTemplate.afterPropertiesSet();
        return redisTemplate;
    }
    /**
     * redisson单机配置
     * @return
     */
    @Bean
    public Redisson redisson() {
        Config config = new Config();
        config.useSingleServer()
                // use "rediss://" for SSL connection
                .setAddress("redis://192.168.122.131:6379").setPassword("root");
        return (Redisson) Redisson.create(config);
    }
}
```

将redis实现分布式锁的saleTicketV8()改造成使用redisson实现分布式锁

InventoryService:

```java
    @Resource
    private Redisson redisson;

    /**
     * Redisson实现分布式锁
     * @return
     */
    public String saleTicketByRedisson() {
        String key = CACHE_INVENTORY_KEY;
        RLock lock = redisson.getLock(CACHE_INVENTORY_LOCK_KEY);
        lock.lock(30, TimeUnit.SECONDS);
        try {
            //查询库存信息
            Object obj = redisTemplate.opsForValue().get(key);
            if (null != obj) {
                int inventory = (Integer) obj;
                //判断库存是否足够
                if (inventory > 0) {
                    //扣减库存，减1
                    inventory -= 1;
                    redisTemplate.opsForValue().set(key, inventory);
                    log.info("端口号：{} 售出一张票，还剩下{}张票", port, inventory);
                    return "端口号：" + port + " 售出一张票，还剩下" + inventory + "张票";
                }
            }
        } finally {
            lock.unlock();
        }
        return "端口号：" + port + " 售票失败，库存为0";
    }
```

InventoryController:

```java
    @Operation(
            summary = "saleTicket",
            description = "售票"
    )
    @GetMapping("/saleTicket")
    public String saleTicket() {
        return inventoryService.saleTicketByRedisson();
    }
```

### 测试

使用Jmeter压测，一切正常。

8081：

![image-20240314162203127](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403141622543.png)8082:

![image-20240314162151616](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403141622980.png)





这样就没问题了吗，那测试一下redisson的自动续期功能吧。

```java
    /**
     * Redisson实现分布式锁
     *
     * @return
     */
    public String saleTicketByRedisson2() {
        String key = CACHE_INVENTORY_KEY;
        RLock lock = redisson.getLock(CACHE_INVENTORY_LOCK_KEY);
        lock.lock(30, TimeUnit.SECONDS);
        try {
            //查询库存信息
            Object obj = redisTemplate.opsForValue().get(key);
            if (null != obj) {
                int inventory = (Integer) obj;
                //判断库存是否足够
                if (inventory > 0) {
                    //扣减库存，减1
                    inventory -= 1;
                    redisTemplate.opsForValue().set(key, inventory);
                    log.info("端口号：{} 售出一张票，还剩下{}张票", port, inventory);
                    try {
                        TimeUnit.SECONDS.sleep(50);
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                    return "端口号：" + port + " 售出一张票，还剩下" + inventory + "张票";
                }
            }
        } finally {
            lock.unlock();
        }
        return "端口号：" + port + " 售票失败，库存为0";
    }
```

业务执行时间超过过期时间还是会出现误删锁的问题：attempt to unlock lock, not locked by current thread by node id: 460b5b40-b5c8-4c31-b306-1fb18b4413c5 thread-id: 77

```java
java.lang.IllegalMonitorStateException: attempt to unlock lock, not locked by current thread by node id: 460b5b40-b5c8-4c31-b306-1fb18b4413c5 thread-id: 77
	at org.redisson.RedissonBaseLock.lambda$unlockAsync$3(RedissonBaseLock.java:331) ~[redisson-3.19.1.jar:3.19.1]
	at java.base/java.util.concurrent.CompletableFuture.uniHandle(CompletableFuture.java:934) ~[na:na]
	at java.base/java.util.concurrent.CompletableFuture$UniHandle.tryFire(CompletableFuture.java:911) ~[na:na]
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510) ~[na:na]
	at java.base/java.util.concurrent.CompletableFuture.complete(CompletableFuture.java:2147) ~[na:na]
	at org.redisson.command.CommandBatchService.lambda$executeAsync$7(CommandBatchService.java:322) ~[redisson-3.19.1.jar:3.19.1]
	at java.base/java.util.concurrent.CompletableFuture.uniWhenComplete(CompletableFuture.java:863) ~[na:na]
	at java.base/java.util.concurrent.CompletableFuture$UniWhenComplete.tryFire(CompletableFuture.java:841) ~[na:na]
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510) ~[na:na]
	at java.base/java.util.concurrent.CompletableFuture.complete(CompletableFuture.java:2147) ~[na:na]
	at org.redisson.command.RedisCommonBatchExecutor.handleResult(RedisCommonBatchExecutor.java:163) ~[redisson-3.19.1.jar:3.19.1]
	at org.redisson.command.RedisExecutor.checkAttemptPromise(RedisExecutor.java:524) ~[redisson-3.19.1.jar:3.19.1]
	at org.redisson.command.RedisExecutor.lambda$execute$4(RedisExecutor.java:176) ~[redisson-3.19.1.jar:3.19.1]
	at java.base/java.util.concurrent.CompletableFuture.uniWhenComplete(CompletableFuture.java:863) ~[na:na]
	at java.base/java.util.concurrent.CompletableFuture$UniWhenComplete.tryFire(CompletableFuture.java:841) ~[na:na]
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510) ~[na:na]
	at java.base/java.util.concurrent.CompletableFuture.complete(CompletableFuture.java:2147) ~[na:na]
	at org.redisson.client.handler.CommandDecoder.decodeCommandBatch(CommandDecoder.java:325) ~[redisson-3.19.1.jar:3.19.1]
	at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:217) ~[redisson-3.19.1.jar:3.19.1]
	at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:144) ~[redisson-3.19.1.jar:3.19.1]
	at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:120) ~[redisson-3.19.1.jar:3.19.1]
	at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:529) ~[netty-codec-4.1.107.Final.jar:4.1.107.Final]
	at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366) ~[netty-codec-4.1.107.Final.jar:4.1.107.Final]
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:290) ~[netty-codec-4.1.107.Final.jar:4.1.107.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444) ~[netty-transport-4.1.107.Final.jar:4.1.107.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420) ~[netty-transport-4.1.107.Final.jar:4.1.107.Final]
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412) ~[netty-transport-4.1.107.Final.jar:4.1.107.Final]
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410) ~[netty-transport-4.1.107.Final.jar:4.1.107.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:440) ~[netty-transport-4.1.107.Final.jar:4.1.107.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420) ~[netty-transport-4.1.107.Final.jar:4.1.107.Final]
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919) ~[netty-transport-4.1.107.Final.jar:4.1.107.Final]
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166) ~[netty-transport-4.1.107.Final.jar:4.1.107.Final]
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:788) ~[netty-transport-4.1.107.Final.jar:4.1.107.Final]
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724) ~[netty-transport-4.1.107.Final.jar:4.1.107.Final]
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650) ~[netty-transport-4.1.107.Final.jar:4.1.107.Final]
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562) ~[netty-transport-4.1.107.Final.jar:4.1.107.Final]
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997) ~[netty-common-4.1.107.Final.jar:4.1.107.Final]
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[netty-common-4.1.107.Final.jar:4.1.107.Final]
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.107.Final.jar:4.1.107.Final]
	at java.base/java.lang.Thread.run(Thread.java:833) ~[na:na]
```

这是因为lock(long leaseTime, TimeUnit unit):默认不会开启自动续期，

只有使用lock()才会自动续期，默认的锁过期时间是30秒，看门狗每10秒检查一次锁的状态，将过期时间重置。

所以想要实现自动续期功能，需要使用lock()：

```java
    /**
     * Redisson自动续期
     *
     * @return
     */
    public String saleTicketByRedissonV2() {
        String key = CACHE_INVENTORY_KEY;
        RLock lock = redisson.getLock(CACHE_INVENTORY_LOCK_KEY);
        lock.lock();
        try {
            //查询库存信息
            Object obj = redisTemplate.opsForValue().get(key);
            if (null != obj) {
                int inventory = (Integer) obj;
                //判断库存是否足够
                if (inventory > 0) {
                    //扣减库存，减1
                    inventory -= 1;
                    redisTemplate.opsForValue().set(key, inventory);
                    log.info("端口号：{} 售出一张票，还剩下{}张票", port, inventory);
                    try {
                        TimeUnit.SECONDS.sleep(50);
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                    return "端口号：" + port + " 售出一张票，还剩下" + inventory + "张票";
                }
            }
        } finally {
            lock.unlock();
        }
        return "端口号：" + port + " 售票失败，库存为0";
    }
```

如果你不想要默认过期时间30s，想要自定义设置过期时间，而不得不使用lock(long leaseTime, TimeUnit unit)时，需要在某个时刻手动检查并释放锁（例如，在业务逻辑执行完毕后，但锁的租赁时间尚未到期），那么使用 `if (lock != null && lock.isHeldByCurrentThread()) { lock.unlock(); }` 是有意义的，尽管它不是原子操作。但是在这种情况下，仍然应该显式释放它，以降低并发出现误删锁的问题。

```java
    /**
     * Redisson实现分布式锁
     *
     * @return
     */
    public String saleTicketByRedisson() {
        String key = CACHE_INVENTORY_KEY;
        RLock lock = redisson.getLock(CACHE_INVENTORY_LOCK_KEY);
        lock.lock(30, TimeUnit.SECONDS);
        try {
            //查询库存信息
            Object obj = redisTemplate.opsForValue().get(key);
            if (null != obj) {
                int inventory = (Integer) obj;
                //判断库存是否足够
                if (inventory > 0) {
                    //扣减库存，减1
                    inventory -= 1;
                    redisTemplate.opsForValue().set(key, inventory);
                    log.info("端口号：{} 售出一张票，还剩下{}张票", port, inventory);
                    try {
                        TimeUnit.SECONDS.sleep(50);
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                    return "端口号：" + port + " 售出一张票，还剩下" + inventory + "张票";
                }
            }
        } finally {
            if (lock != null && lock.isHeldByCurrentThread()) {
                lock.unlock();
            }
        }
        return "端口号：" + port + " 售票失败，库存为0";
    }
```

总结

- 如果业务逻辑需要严格的排他性执行，并且执行时间可能超过一个可预测的固定时间窗口，那么应该使用 `lock()` 方法而不是 `lock(long leaseTime, TimeUnit unit)`。
- 在释放锁之前，始终检查锁是否由当前线程持有是一个好习惯，可以避免潜在的问题。
- 即使使用 `lock(long leaseTime, TimeUnit unit)` 并且锁已经过期，如果当前线程仍然持有锁对象，那么仍然应该显式释放它。



## 多实例redisson实现分布式锁

使用三台实例实现RedLock算法的Redisson分布式锁，这三台实例都是完全独立的。

| IP              | PORT | 角色   |
| --------------- | ---- | ------ |
| 192.168.122.132 | 7001 | master |
| 192.168.122.133 | 7002 | master |
| 192.168.122.134 | 7003 | master |

![image-20240314154459176](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403141545619.png)

### Redisson RedLock实现加锁解锁

RedisConfig配置类

```java
import org.redisson.Redisson;
import org.redisson.api.RedissonClient;
import org.redisson.config.Config;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;

import java.io.Serializable;

/**
 * redis序列化工具类
 */

@Configuration
public class RedisConfig {


    /**
     * @param lettuceConnectionFactory
     * @return redis序列化的工具配置类
     * 1) "order:696"  序列化过
     * 2) "\xac\xed\x00\x05t\x00\order:696"   没有序列化过
     */
    @Bean
    public RedisTemplate<String, Serializable> redisTemplate(LettuceConnectionFactory lettuceConnectionFactory) {
        RedisTemplate<String, Serializable> redisTemplate = new RedisTemplate<>();
        redisTemplate.setConnectionFactory(lettuceConnectionFactory);
        //设置key序列化方式string
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        //设置value的序列化方式json
        redisTemplate.setValueSerializer(new GenericJackson2JsonRedisSerializer());
        redisTemplate.setHashKeySerializer(new StringRedisSerializer());
        redisTemplate.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());
        redisTemplate.afterPropertiesSet();
        return redisTemplate;
    }
    
    /**
     * 单机配置
     * @return
     */
    @Bean
    public Redisson redisson() {
        Config config = new Config();
        config.useSingleServer()
                // use "rediss://" for SSL connection
                .setAddress("redis://192.168.122.131:6379").setPassword("root");
        return (Redisson) Redisson.create(config);
    }
    
    /**
     * RedLock 3个各自独立的master
     * @return
     */
    @Bean
    RedissonClient redissonClient1(){
        Config config = new Config();
        config.useSingleServer().setAddress("redis://192.168.122.132:7001").setPassword("root");
        return Redisson.create(config);
    }
    @Bean
    RedissonClient redissonClient2(){
        Config config = new Config();
        config.useSingleServer().setAddress("redis://192.168.122.133:7002").setPassword("root");
        return Redisson.create(config);
    }

    @Bean
    RedissonClient redissonClient3(){
        Config config = new Config();
        config.useSingleServer().setAddress("redis://192.168.122.134:7003").setPassword("root");
        return Redisson.create(config);
    }
}
```

InventoryService：

```java
    @Resource
    private RedissonClient redissonClient1;
    @Resource
    private RedissonClient redissonClient2;
    @Resource
    private RedissonClient redissonClient3;

    /**
     * Redisson RedLock
     *
     * @return
     */
    public String saleTicketByRedissonV3() {
        String key = CACHE_INVENTORY_KEY;
        RLock lock1 = redissonClient1.getLock(CACHE_INVENTORY_LOCK_KEY);
        RLock lock2 = redissonClient2.getLock(CACHE_INVENTORY_LOCK_KEY);
        RLock lock3 = redissonClient3.getLock(CACHE_INVENTORY_LOCK_KEY);
        RedissonRedLock redLock = new RedissonRedLock(lock1, lock2, lock3);
        try {
            //waitTime:3 抢锁的等待时间3秒
            //leaseTime:300 key的过期时间30秒
            if (redLock.tryLock(3, 30, TimeUnit.SECONDS)) {
                log.info("端口号：{}，线程：{}，抢到锁了", port, Thread.currentThread().getId());
                //查询库存信息
                Object obj = redisTemplate.opsForValue().get(key);
                if (null != obj) {
                    int inventory = (Integer) obj;
                    //判断库存是否足够
                    if (inventory > 0) {
                        //扣减库存，减1
                        inventory -= 1;
                        redisTemplate.opsForValue().set(key, inventory);
                        log.info("端口号：{} 售出一张票，还剩下{}张票", port, inventory);
                        return "端口号：" + port + " 售出一张票，还剩下" + inventory + "张票";
                    }
                }
            } else {
                log.info("端口号：{},线程{}，没有抢到锁", port, Thread.currentThread().getId());
            }
        } catch (Exception e) {
            log.error("RedLock error:{}", e);
        } finally {
            redLock.unlock();
        }
        return "端口号：" + port + " 售票失败，库存为0";
    }
```

InventoryController：

```java
    @Operation(
            summary = "saleTicket",
            description = "售票"
    )
    @GetMapping("/saleTicket")
    public String saleTicket() {
        return inventoryService.saleTicketByRedissonV3();
    }
```

启动时三个RedissonClient初始化成功

![image-20240314205556209](F:\note\image\image-20240314205556209.png)

测试

8081

![image-20240314215639325](F:\note\image\image-20240314215639325.png)

8082

![](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403142156354.png)

### 模拟业务执行时间超过了锁的过期时间

```java
    @Resource
    private RedissonClient redissonClient1;
    @Resource
    private RedissonClient redissonClient2;
    @Resource
    private RedissonClient redissonClient3;

    /**
     * Redisson RedLock
     *
     * @return
     */
    public String saleTicketByRedissonV3() {
        String key = CACHE_INVENTORY_KEY;
        RLock lock1 = redissonClient1.getLock(CACHE_INVENTORY_LOCK_KEY);
        RLock lock2 = redissonClient2.getLock(CACHE_INVENTORY_LOCK_KEY);
        RLock lock3 = redissonClient3.getLock(CACHE_INVENTORY_LOCK_KEY);
        RedissonRedLock redLock = new RedissonRedLock(lock1, lock2, lock3);
        try {
            //waitTime:3 抢锁的等待时间3秒
            //leaseTime:30 key的过期时间30秒
            if (redLock.tryLock(3, 30, TimeUnit.SECONDS)) {
                log.info("端口号：{}，线程：{}，抢到锁了", port, Thread.currentThread().getId());
                //查询库存信息
                Object obj = redisTemplate.opsForValue().get(key);
                if (null != obj) {
                    int inventory = (Integer) obj;
                    //判断库存是否足够
                    if (inventory > 0) {
                        //扣减库存，减1
                        inventory -= 1;
                        redisTemplate.opsForValue().set(key, inventory);
                        log.info("端口号：{} 售出一张票，还剩下{}张票", port, inventory);
                        //模拟业务执行时间超过了锁的过期时间
                        TimeUnit.SECONDS.sleep(100);
                        return "端口号：" + port + " 售出一张票，还剩下" + inventory + "张票";
                    }
                }
            } else {
                log.info("端口号：{},线程{}，没有抢到锁", port, Thread.currentThread().getId());
            }
        } catch (Exception e) {
            log.error("RedLock error:{}", e);
        } finally {
            redLock.unlock();
        }
        return "端口号：" + port + " 售票失败，库存为0";
    }
```

请求http://192.168.122.131/inventory/saleTicket

```java
2024-03-15T05:46:17.706+08:00  INFO 38840 --- [redis_distributed_lock] [nio-8082-exec-1] c.d.redis.service.InventoryService       : 端口号：8082，线程：178，抢到锁了
2024-03-15T05:46:17.983+08:00  INFO 38840 --- [redis_distributed_lock] [nio-8082-exec-1] c.d.redis.service.InventoryService       : 端口号：8082 售出一张票，还剩下98张票
2024-03-15T05:46:47.787+08:00  INFO 38840 --- [redis_distributed_lock] [nio-8082-exec-2] c.d.redis.service.InventoryService       : 端口号：8082，线程：179，抢到锁了
2024-03-15T05:46:47.791+08:00  INFO 38840 --- [redis_distributed_lock] [nio-8082-exec-2] c.d.redis.service.InventoryService       : 端口号：8082 售出一张票，还剩下97张票
```

这里有个问题，redLock.tryLock()还是不会续期，超过过期时间锁就删除了，即使你业务还没有结束。所以一定要保证过期时间远大于业务执行时间。经过测试redLock.tryLock()，RedLock会自动续期的。

```java
    public String saleTicketByRedissonV3() {
        String key = CACHE_INVENTORY_KEY;
        RLock lock1 = redissonClient1.getLock(CACHE_INVENTORY_LOCK_KEY);
        RLock lock2 = redissonClient2.getLock(CACHE_INVENTORY_LOCK_KEY);
        RLock lock3 = redissonClient3.getLock(CACHE_INVENTORY_LOCK_KEY);
        RedissonRedLock redLock = new RedissonRedLock(lock1, lock2, lock3);
        try {
            if (redLock.tryLock()) {
                log.info("端口号：{}，线程：{}，抢到锁了", port, Thread.currentThread().getId());
                //查询库存信息
                Object obj = redisTemplate.opsForValue().get(key);
                if (null != obj) {
                    int inventory = (Integer) obj;
                    //判断库存是否足够
                    if (inventory > 0) {
                        //扣减库存，减1
                        inventory -= 1;
                        redisTemplate.opsForValue().set(key, inventory);
                        log.info("端口号：{} 售出一张票，还剩下{}张票", port, inventory);
                        //模拟业务执行时间超过了锁的过期时间
                        TimeUnit.SECONDS.sleep(100);
                        return "端口号：" + port + " 售出一张票，还剩下" + inventory + "张票";
                    }
                }
            } else {
                log.info("端口号：{},线程{}，没有抢到锁", port, Thread.currentThread().getId());
            }
        } catch (Exception e) {
            log.error("RedLock error:{}", e);
        } finally {
            redLock.unlock();
        }
        return "端口号：" + port + " 售票失败，库存为0";
    }
```



### 7003宕机，查看RedLock锁是否还能正常加锁解锁。

```shell
[root@redis-7003 myredis]# redis-cli -a root -p 7003
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.
127.0.0.1:7003> shutdown
not connected> quit
```

请求http://192.168.122.131/inventory/saleTicket，一切正常

![image-20240315055529197](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403150558826.png)



![image-20240315055539752](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403150558148.png)



### 7002也宕机，查看RedLock锁是否还能正常加锁解锁。

```shll
[root@redis-7002 ~]# redis-cli -a root -p 7002 -c
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.
127.0.0.1:7002> shutdown
not connected> quit
```

超过一般以上的实例宕机，加锁失败。

![image-20240315055751364](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403150558295.png)



## 结论：

注意，RedLock也是非绝对安全的

RedLock解决了单Redis节点的分布式锁在failover的时候锁失效的问题，但节点如果出现奔溃重启，对锁的安全性依旧存在问题。

1. ·假如一共有5个Redis节点：A,B,C,D,E。

1. 客户端1成功锁住了A，B，C，获取锁成功（但D和E没有锁住）。

1. 节点C崩溃重启，但客户端1在C上加的锁没有持久化下来，aof机制导致。

1. 节点C重启后，客户端2锁住了C，D,E，获取锁成功。·

Redis 的 AOF 持久化方式是每秒执行fsync写一次磁盘，最坏情况下可能丢失1秒的数据。

·尽可能不丢数据，Redis允许设置成每次修改数据都进行fsync，但会降低性能。·

即使执行了fsync也仍然有可能丢失数据，因为也取决操作系统的刷盘策略，文件系统写到了buffer里面。

·建议延迟重启，一个节点崩溃后，先不立即重启它，而是等待一段时间再重启，这段时间应该大于锁的有效时间。

那这个节点在重启前所参与的锁都会过期，它在重启后就不会对现有的锁造成影响。
