[redis官网在分布式锁模块](https://redis.io/docs/manual/patterns/distributed-locks/)作者提到使用RedLock算法实现分布式锁，在Java中的实现是Redisson。

# Redis作者为什么会提出RedLck算法实现分布式锁呢？

## 基于SETNX的分布式锁有什么问题呢？

之前redis分布式锁的案例都是单机redis，存在单点故障。

那么使用主从+哨兵或者Cluster集群会存在什么问题呢？

![image-20240314143021181](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403141430135.png)

线程A 获取锁成功后，将键值对写入redis 的 master节点，在 redis将该键值对同步到slave节点之前， master发生了故障。redis触发故障转移,其中一个slave升级为新的master,此时新上位的master并不包含线程A写入的键值对,因此线程B尝试获取锁时可以成功拿到锁,此时相当于有两个线程都获取到了锁。我们使用分布式锁就是为了实现同一时间只能有线程获取锁成功，同一时间两个或以上的线程获取到锁是不被允许的。问题的根源还是由于主从数据不一致造成的。

## 提出RedLock算法解决这个问题

Redis提供了RedLock算法，用来实现基于多个实例的分布式锁。

锁变量由多个实例维护，即使有实例发生了故障，锁变量仍然是存在的，客户端还是可以完成锁操作。

RedLock算法是实现高可靠分布式锁的一种有效解决方案，可以再实际开发中使用。

## RedLock算法

RedLock算法为了解决数据不一致的问题，直接舍弃了异步复制，只是用master节点，舍弃slave节点，保证可用性。

加锁：依次尝试从N个master实例获取锁，客户端设置一个超时时间，防止客户端与一台宕机的reids主节点获取锁导致长期处于阻塞状态，如果一个实例不可用，客户端会尝试与其他Redis实例请求获取锁。

客户端只有在满足一下两个条件时才认为加锁成功：1.至少在N/2 + 1个redis实例上获取到锁；2.客户端获取锁的总耗时没有超过锁的有效时间。

解锁：在所有实例上进行解锁，即使某些redis实例没有加锁成功。

![image-20240314154459176](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403141545619.png)

# RedLock的实现Redisson实战

## 1.pom引入Redisson依赖

```xml
		<dependency>
			<groupId>org.redisson</groupId>
			<artifactId>redisson</artifactId>
		</dependency>
```

## 2.Redisson配置

```java
import org.redisson.Redisson;
import org.redisson.api.RedissonClient;
import org.redisson.config.Config;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;

import java.io.Serializable;

/**
 * redis序列化工具类
 */

@Configuration
public class RedisConfig {


    /**
     * @param lettuceConnectionFactory
     * @return redis序列化的工具配置类
     * 1) "order:696"  序列化过
     * 2) "\xac\xed\x00\x05t\x00\order:696"   没有序列化过
     */
    @Bean
    public RedisTemplate<String, Serializable> redisTemplate(LettuceConnectionFactory lettuceConnectionFactory) {
        RedisTemplate<String, Serializable> redisTemplate = new RedisTemplate<>();
        redisTemplate.setConnectionFactory(lettuceConnectionFactory);
        //设置key序列化方式string
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        //设置value的序列化方式json
        redisTemplate.setValueSerializer(new GenericJackson2JsonRedisSerializer());
        redisTemplate.setHashKeySerializer(new StringRedisSerializer());
        redisTemplate.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());
        redisTemplate.afterPropertiesSet();
        return redisTemplate;
    }
    /**
     * redisson单机配置
     * @return
     */
    @Bean
    public Redisson redisson() {
        Config config = new Config();
        config.useSingleServer()
                // use "rediss://" for SSL connection
                .setAddress("redis://192.168.122.131:6379").setPassword("root");
        return (Redisson) Redisson.create(config);
    }
}
```

## 3.将redis实现分布式锁的saleTicketV8()改造成使用redisson实现分布式锁

InventoryService:

```java
    @Resource
    private Redisson redisson;

    /**
     * Redisson实现分布式锁
     * @return
     */
    public String saleTicketByRedisson() {
        String key = CACHE_INVENTORY_KEY;
        RLock lock = redisson.getLock(CACHE_INVENTORY_LOCK_KEY);
        lock.lock(30, TimeUnit.SECONDS);
        try {
            //查询库存信息
            Object obj = redisTemplate.opsForValue().get(key);
            if (null != obj) {
                int inventory = (Integer) obj;
                //判断库存是否足够
                if (inventory > 0) {
                    //扣减库存，减1
                    inventory -= 1;
                    redisTemplate.opsForValue().set(key, inventory);
                    log.info("端口号：{} 售出一张票，还剩下{}张票", port, inventory);
                    return "端口号：" + port + " 售出一张票，还剩下" + inventory + "张票";
                }
            }
        } finally {
            lock.unlock();
        }
        return "端口号：" + port + " 售票失败，库存为0";
    }
```

InventoryController:

```java
    @Operation(
            summary = "saleTicket",
            description = "售票"
    )
    @GetMapping("/saleTicket")
    public String saleTicket() {
        return inventoryService.saleTicketByRedisson();
    }
```

## 4.测试

使用Jmeter压测，一切正常。

8081：

![image-20240314162203127](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403141622543.png)8082:

![image-20240314162151616](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403141622980.png)





这样就没问题了吗，那测试一下redisson的自动续期功能吧。

```java
    /**
     * Redisson实现分布式锁
     *
     * @return
     */
    public String saleTicketByRedisson2() {
        String key = CACHE_INVENTORY_KEY;
        RLock lock = redisson.getLock(CACHE_INVENTORY_LOCK_KEY);
        lock.lock(30, TimeUnit.SECONDS);
        try {
            //查询库存信息
            Object obj = redisTemplate.opsForValue().get(key);
            if (null != obj) {
                int inventory = (Integer) obj;
                //判断库存是否足够
                if (inventory > 0) {
                    //扣减库存，减1
                    inventory -= 1;
                    redisTemplate.opsForValue().set(key, inventory);
                    log.info("端口号：{} 售出一张票，还剩下{}张票", port, inventory);
                    try {
                        TimeUnit.SECONDS.sleep(50);
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                    return "端口号：" + port + " 售出一张票，还剩下" + inventory + "张票";
                }
            }
        } finally {
            lock.unlock();
        }
        return "端口号：" + port + " 售票失败，库存为0";
    }
```

业务执行时间超过过期时间还是会出现误删锁的问题：attempt to unlock lock, not locked by current thread by node id: 460b5b40-b5c8-4c31-b306-1fb18b4413c5 thread-id: 77

```java
java.lang.IllegalMonitorStateException: attempt to unlock lock, not locked by current thread by node id: 460b5b40-b5c8-4c31-b306-1fb18b4413c5 thread-id: 77
	at org.redisson.RedissonBaseLock.lambda$unlockAsync$3(RedissonBaseLock.java:331) ~[redisson-3.19.1.jar:3.19.1]
	at java.base/java.util.concurrent.CompletableFuture.uniHandle(CompletableFuture.java:934) ~[na:na]
	at java.base/java.util.concurrent.CompletableFuture$UniHandle.tryFire(CompletableFuture.java:911) ~[na:na]
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510) ~[na:na]
	at java.base/java.util.concurrent.CompletableFuture.complete(CompletableFuture.java:2147) ~[na:na]
	at org.redisson.command.CommandBatchService.lambda$executeAsync$7(CommandBatchService.java:322) ~[redisson-3.19.1.jar:3.19.1]
	at java.base/java.util.concurrent.CompletableFuture.uniWhenComplete(CompletableFuture.java:863) ~[na:na]
	at java.base/java.util.concurrent.CompletableFuture$UniWhenComplete.tryFire(CompletableFuture.java:841) ~[na:na]
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510) ~[na:na]
	at java.base/java.util.concurrent.CompletableFuture.complete(CompletableFuture.java:2147) ~[na:na]
	at org.redisson.command.RedisCommonBatchExecutor.handleResult(RedisCommonBatchExecutor.java:163) ~[redisson-3.19.1.jar:3.19.1]
	at org.redisson.command.RedisExecutor.checkAttemptPromise(RedisExecutor.java:524) ~[redisson-3.19.1.jar:3.19.1]
	at org.redisson.command.RedisExecutor.lambda$execute$4(RedisExecutor.java:176) ~[redisson-3.19.1.jar:3.19.1]
	at java.base/java.util.concurrent.CompletableFuture.uniWhenComplete(CompletableFuture.java:863) ~[na:na]
	at java.base/java.util.concurrent.CompletableFuture$UniWhenComplete.tryFire(CompletableFuture.java:841) ~[na:na]
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510) ~[na:na]
	at java.base/java.util.concurrent.CompletableFuture.complete(CompletableFuture.java:2147) ~[na:na]
	at org.redisson.client.handler.CommandDecoder.decodeCommandBatch(CommandDecoder.java:325) ~[redisson-3.19.1.jar:3.19.1]
	at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:217) ~[redisson-3.19.1.jar:3.19.1]
	at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:144) ~[redisson-3.19.1.jar:3.19.1]
	at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:120) ~[redisson-3.19.1.jar:3.19.1]
	at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:529) ~[netty-codec-4.1.107.Final.jar:4.1.107.Final]
	at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366) ~[netty-codec-4.1.107.Final.jar:4.1.107.Final]
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:290) ~[netty-codec-4.1.107.Final.jar:4.1.107.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444) ~[netty-transport-4.1.107.Final.jar:4.1.107.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420) ~[netty-transport-4.1.107.Final.jar:4.1.107.Final]
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412) ~[netty-transport-4.1.107.Final.jar:4.1.107.Final]
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410) ~[netty-transport-4.1.107.Final.jar:4.1.107.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:440) ~[netty-transport-4.1.107.Final.jar:4.1.107.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420) ~[netty-transport-4.1.107.Final.jar:4.1.107.Final]
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919) ~[netty-transport-4.1.107.Final.jar:4.1.107.Final]
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166) ~[netty-transport-4.1.107.Final.jar:4.1.107.Final]
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:788) ~[netty-transport-4.1.107.Final.jar:4.1.107.Final]
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724) ~[netty-transport-4.1.107.Final.jar:4.1.107.Final]
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650) ~[netty-transport-4.1.107.Final.jar:4.1.107.Final]
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562) ~[netty-transport-4.1.107.Final.jar:4.1.107.Final]
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997) ~[netty-common-4.1.107.Final.jar:4.1.107.Final]
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[netty-common-4.1.107.Final.jar:4.1.107.Final]
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.107.Final.jar:4.1.107.Final]
	at java.base/java.lang.Thread.run(Thread.java:833) ~[na:na]
```

这是因为lock(long leaseTime, TimeUnit unit):默认不会开启自动续期，

只有使用lock()才会自动续期，默认的锁过期时间是30秒，看门狗每10秒检查一次锁的状态，将过期时间重置。

所以想要实现自动续期功能，需要使用lock()：

```java
    /**
     * Redisson自动续期
     *
     * @return
     */
    public String saleTicketByRedissonV2() {
        String key = CACHE_INVENTORY_KEY;
        RLock lock = redisson.getLock(CACHE_INVENTORY_LOCK_KEY);
        lock.lock();
        try {
            //查询库存信息
            Object obj = redisTemplate.opsForValue().get(key);
            if (null != obj) {
                int inventory = (Integer) obj;
                //判断库存是否足够
                if (inventory > 0) {
                    //扣减库存，减1
                    inventory -= 1;
                    redisTemplate.opsForValue().set(key, inventory);
                    log.info("端口号：{} 售出一张票，还剩下{}张票", port, inventory);
                    try {
                        TimeUnit.SECONDS.sleep(50);
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                    return "端口号：" + port + " 售出一张票，还剩下" + inventory + "张票";
                }
            }
        } finally {
            lock.unlock();
        }
        return "端口号：" + port + " 售票失败，库存为0";
    }
```

如果你不想要默认过期时间30s，想要自定义设置过期时间，而不得不使用lock(long leaseTime, TimeUnit unit)时，需要在某个时刻手动检查并释放锁（例如，在业务逻辑执行完毕后，但锁的租赁时间尚未到期），那么使用 `if (lock != null && lock.isHeldByCurrentThread()) { lock.unlock(); }` 是有意义的，尽管它不是原子操作。但是在这种情况下，仍然应该显式释放它，以降低并发出现误删锁的问题。

```java
    /**
     * Redisson实现分布式锁
     *
     * @return
     */
    public String saleTicketByRedisson() {
        String key = CACHE_INVENTORY_KEY;
        RLock lock = redisson.getLock(CACHE_INVENTORY_LOCK_KEY);
        lock.lock(30, TimeUnit.SECONDS);
        try {
            //查询库存信息
            Object obj = redisTemplate.opsForValue().get(key);
            if (null != obj) {
                int inventory = (Integer) obj;
                //判断库存是否足够
                if (inventory > 0) {
                    //扣减库存，减1
                    inventory -= 1;
                    redisTemplate.opsForValue().set(key, inventory);
                    log.info("端口号：{} 售出一张票，还剩下{}张票", port, inventory);
                    try {
                        TimeUnit.SECONDS.sleep(50);
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                    return "端口号：" + port + " 售出一张票，还剩下" + inventory + "张票";
                }
            }
        } finally {
            if (lock != null && lock.isHeldByCurrentThread()) {
                lock.unlock();
            }
        }
        return "端口号：" + port + " 售票失败，库存为0";
    }
```

总结

- 如果业务逻辑需要严格的排他性执行，并且执行时间可能超过一个可预测的固定时间窗口，那么应该使用 `lock()` 方法而不是 `lock(long leaseTime, TimeUnit unit)`。
- 在释放锁之前，始终检查锁是否由当前线程持有是一个好习惯，可以避免潜在的问题。
- 即使使用 `lock(long leaseTime, TimeUnit unit)` 并且锁已经过期，如果当前线程仍然持有锁对象，那么仍然应该显式释放它。







