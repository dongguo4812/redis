redis官网在分布式锁模块](https://redis.io/docs/manual/patterns/distributed-locks/)作者提到使用RedLock算法实现分布式锁，在Java中的实现是Redisson。

# Redis作者为什么会提出RedLck算法实现分布式锁呢？

## 基于SETNX的分布式锁有什么问题呢？

之前redis分布式锁的案例都是单机redis，存在单点故障。

那么使用主从+哨兵或者Cluster集群会存在什么问题呢？

![image-20240314143021181](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403141430135.png)

线程A 获取锁成功后，将键值对写入redis 的 master节点，在 redis将该键值对同步到slave节点之前， master发生了故障。redis触发故障转移,其中一个slave升级为新的master,此时新上位的master并不包含线程A写入的键值对,因此线程B尝试获取锁时可以成功拿到锁,此时相当于有两个线程都获取到了锁。我们使用分布式锁就是为了实现同一时间只能有线程获取锁成功，同一时间两个或以上的线程获取到锁是不被允许的。问题的根源还是由于主从数据不一致造成的。

## 提出RedLock算法解决这个问题

Redis提供了RedLock算法，用来实现基于多个实例的分布式锁。

锁变量由多个实例维护，即使有实例发生了故障，锁变量仍然是存在的，客户端还是可以完成锁操作。

RedLock算法是实现高可靠分布式锁的一种有效解决方案，可以再实际开发中使用。

## RedLock算法

RedLock算法为了解决数据不一致的问题，直接舍弃了异步复制，只是用master节点，舍弃slave节点，保证可用性。

加锁：依次尝试从N个master实例获取锁，客户端设置一个超时时间，防止客户端与一台宕机的reids主节点获取锁导致长期处于阻塞状态，如果一个实例不可用，客户端会尝试与其他Redis实例请求获取锁。

客户端只有在满足一下两个条件时才认为加锁成功：1.至少在N/2 + 1个redis实例上获取到锁；2.客户端获取锁的总耗时没有超过锁的有效时间。

解锁：在所有实例上进行解锁，即使某些redis实例没有加锁成功。



# RedLock的实现

pom引入Redisson依赖

```xml
		<dependency>
			<groupId>org.redisson</groupId>
			<artifactId>redisson</artifactId>
		</dependency>
```

## 单实例redisson实现分布式锁

### Redisson配置

```java
import org.redisson.Redisson;
import org.redisson.api.RedissonClient;
import org.redisson.config.Config;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;

import java.io.Serializable;

/**
 * redis序列化工具类
 */

@Configuration
public class RedisConfig {


    /**
     * @param lettuceConnectionFactory
     * @return redis序列化的工具配置类
     * 1) "order:696"  序列化过
     * 2) "\xac\xed\x00\x05t\x00\order:696"   没有序列化过
     */
    @Bean
    public RedisTemplate<String, Serializable> redisTemplate(LettuceConnectionFactory lettuceConnectionFactory) {
        RedisTemplate<String, Serializable> redisTemplate = new RedisTemplate<>();
        redisTemplate.setConnectionFactory(lettuceConnectionFactory);
        //设置key序列化方式string
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        //设置value的序列化方式json
        redisTemplate.setValueSerializer(new GenericJackson2JsonRedisSerializer());
        redisTemplate.setHashKeySerializer(new StringRedisSerializer());
        redisTemplate.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());
        redisTemplate.afterPropertiesSet();
        return redisTemplate;
    }
    /**
     * redisson单机配置
     * @return
     */
    @Bean
    public Redisson redisson() {
        Config config = new Config();
        config.useSingleServer()
                // use "rediss://" for SSL connection
                .setAddress("redis://192.168.122.131:6379").setPassword("root");
        return (Redisson) Redisson.create(config);
    }
}
```

将redis实现分布式锁的saleTicketV8()改造成使用redisson实现分布式锁

InventoryService:

```java
    @Resource
    private Redisson redisson;

    /**
     * Redisson实现分布式锁
     * @return
     */
    public String saleTicketByRedisson() {
        String key = CACHE_INVENTORY_KEY;
        RLock lock = redisson.getLock(CACHE_INVENTORY_LOCK_KEY);
        lock.lock(30, TimeUnit.SECONDS);
        try {
            //查询库存信息
            Object obj = redisTemplate.opsForValue().get(key);
            if (null != obj) {
                int inventory = (Integer) obj;
                //判断库存是否足够
                if (inventory > 0) {
                    //扣减库存，减1
                    inventory -= 1;
                    redisTemplate.opsForValue().set(key, inventory);
                    log.info("端口号：{} 售出一张票，还剩下{}张票", port, inventory);
                    return "端口号：" + port + " 售出一张票，还剩下" + inventory + "张票";
                }
            }
        } finally {
            lock.unlock();
        }
        return "端口号：" + port + " 售票失败，库存为0";
    }
```

InventoryController:

```java
    @Operation(
            summary = "saleTicket",
            description = "售票"
    )
    @GetMapping("/saleTicket")
    public String saleTicket() {
        return inventoryService.saleTicketByRedisson();
    }
```

### 测试

使用Jmeter压测，一切正常。

8081：

![image-20240314162203127](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403141622543.png)8082:

![image-20240314162151616](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403141622980.png)



大家都知道,Redisson内部提供了一个监控锁的看门狗,它的作用是在Redisson实例被关闭前,不断的延长锁的有效期。默认情况下,看门狗的检查锁的超时时间是30秒钟,也可以通过修改Config.lockWatchdogTimeout来另行指定。

那我们来测试一下redisson的自动续期功能吧。

```java
    /**
     * Redisson实现分布式锁
     *
     * @return
     */
    public String saleTicketByRedisson2() {
        String key = CACHE_INVENTORY_KEY;
        RLock lock = redisson.getLock(CACHE_INVENTORY_LOCK_KEY);
        lock.lock(30, TimeUnit.SECONDS);
        try {
            //查询库存信息
            Object obj = redisTemplate.opsForValue().get(key);
            if (null != obj) {
                int inventory = (Integer) obj;
                //判断库存是否足够
                if (inventory > 0) {
                    //扣减库存，减1
                    inventory -= 1;
                    redisTemplate.opsForValue().set(key, inventory);
                    log.info("端口号：{} 售出一张票，还剩下{}张票", port, inventory);
                    try {
                        TimeUnit.SECONDS.sleep(50);
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                    return "端口号：" + port + " 售出一张票，还剩下" + inventory + "张票";
                }
            }
        } finally {
            lock.unlock();
        }
        return "端口号：" + port + " 售票失败，库存为0";
    }
```

业务执行时间超过过期时间还是会出现误删锁的问题：attempt to unlock lock, not locked by current thread by node id: 460b5b40-b5c8-4c31-b306-1fb18b4413c5 thread-id: 77

```java
java.lang.IllegalMonitorStateException: attempt to unlock lock, not locked by current thread by node id: 460b5b40-b5c8-4c31-b306-1fb18b4413c5 thread-id: 77
	at org.redisson.RedissonBaseLock.lambda$unlockAsync$3(RedissonBaseLock.java:331) ~[redisson-3.19.1.jar:3.19.1]
	at java.base/java.util.concurrent.CompletableFuture.uniHandle(CompletableFuture.java:934) ~[na:na]
	at java.base/java.util.concurrent.CompletableFuture$UniHandle.tryFire(CompletableFuture.java:911) ~[na:na]
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510) ~[na:na]
	at java.base/java.util.concurrent.CompletableFuture.complete(CompletableFuture.java:2147) ~[na:na]
	at org.redisson.command.CommandBatchService.lambda$executeAsync$7(CommandBatchService.java:322) ~[redisson-3.19.1.jar:3.19.1]
	at java.base/java.util.concurrent.CompletableFuture.uniWhenComplete(CompletableFuture.java:863) ~[na:na]
	at java.base/java.util.concurrent.CompletableFuture$UniWhenComplete.tryFire(CompletableFuture.java:841) ~[na:na]
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510) ~[na:na]
	at java.base/java.util.concurrent.CompletableFuture.complete(CompletableFuture.java:2147) ~[na:na]
	at org.redisson.command.RedisCommonBatchExecutor.handleResult(RedisCommonBatchExecutor.java:163) ~[redisson-3.19.1.jar:3.19.1]
	at org.redisson.command.RedisExecutor.checkAttemptPromise(RedisExecutor.java:524) ~[redisson-3.19.1.jar:3.19.1]
	at org.redisson.command.RedisExecutor.lambda$execute$4(RedisExecutor.java:176) ~[redisson-3.19.1.jar:3.19.1]
	at java.base/java.util.concurrent.CompletableFuture.uniWhenComplete(CompletableFuture.java:863) ~[na:na]
	at java.base/java.util.concurrent.CompletableFuture$UniWhenComplete.tryFire(CompletableFuture.java:841) ~[na:na]
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510) ~[na:na]
	at java.base/java.util.concurrent.CompletableFuture.complete(CompletableFuture.java:2147) ~[na:na]
	at org.redisson.client.handler.CommandDecoder.decodeCommandBatch(CommandDecoder.java:325) ~[redisson-3.19.1.jar:3.19.1]
	at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:217) ~[redisson-3.19.1.jar:3.19.1]
	at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:144) ~[redisson-3.19.1.jar:3.19.1]
	at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:120) ~[redisson-3.19.1.jar:3.19.1]
	at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:529) ~[netty-codec-4.1.107.Final.jar:4.1.107.Final]
	at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366) ~[netty-codec-4.1.107.Final.jar:4.1.107.Final]
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:290) ~[netty-codec-4.1.107.Final.jar:4.1.107.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444) ~[netty-transport-4.1.107.Final.jar:4.1.107.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420) ~[netty-transport-4.1.107.Final.jar:4.1.107.Final]
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412) ~[netty-transport-4.1.107.Final.jar:4.1.107.Final]
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410) ~[netty-transport-4.1.107.Final.jar:4.1.107.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:440) ~[netty-transport-4.1.107.Final.jar:4.1.107.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420) ~[netty-transport-4.1.107.Final.jar:4.1.107.Final]
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919) ~[netty-transport-4.1.107.Final.jar:4.1.107.Final]
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166) ~[netty-transport-4.1.107.Final.jar:4.1.107.Final]
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:788) ~[netty-transport-4.1.107.Final.jar:4.1.107.Final]
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724) ~[netty-transport-4.1.107.Final.jar:4.1.107.Final]
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650) ~[netty-transport-4.1.107.Final.jar:4.1.107.Final]
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562) ~[netty-transport-4.1.107.Final.jar:4.1.107.Final]
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997) ~[netty-common-4.1.107.Final.jar:4.1.107.Final]
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[netty-common-4.1.107.Final.jar:4.1.107.Final]
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.107.Final.jar:4.1.107.Final]
	at java.base/java.lang.Thread.run(Thread.java:833) ~[na:na]
```

这是因为lock(long leaseTime, TimeUnit unit):默认不会开启自动续期，

只有使用lock()才会自动续期，默认的锁过期时间是30秒，看门狗每10秒检查一次锁的状态，将过期时间重置。

https://github.com/redisson/redisson/wiki/8.-distributed-locks-and-synchronizers/#81-lock Lock指出

![image-20240315105635149](F:\note\image\image-20240315105635149.png)

所以想要实现自动续期功能，需要使用lock()：

```java
    /**
     * Redisson自动续期
     *
     * @return
     */
    public String saleTicketByRedissonV2() {
        String key = CACHE_INVENTORY_KEY;
        RLock lock = redisson.getLock(CACHE_INVENTORY_LOCK_KEY);
        lock.lock();
        try {
            //查询库存信息
            Object obj = redisTemplate.opsForValue().get(key);
            if (null != obj) {
                int inventory = (Integer) obj;
                //判断库存是否足够
                if (inventory > 0) {
                    //扣减库存，减1
                    inventory -= 1;
                    redisTemplate.opsForValue().set(key, inventory);
                    log.info("端口号：{} 售出一张票，还剩下{}张票", port, inventory);
                    try {
                        TimeUnit.SECONDS.sleep(50);
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                    return "端口号：" + port + " 售出一张票，还剩下" + inventory + "张票";
                }
            }
        } finally {
            lock.unlock();
        }
        return "端口号：" + port + " 售票失败，库存为0";
    }
```

如果你不想要默认过期时间30s，想要自定义设置过期时间，可以通过修改Config.lockWatchdogTimeout来另行指定。如果不得不使用lock(long leaseTime, TimeUnit unit)时，需要在某个时刻手动检查并释放锁（例如，在业务逻辑执行完毕后，但锁的租赁时间尚未到期），那么使用 `if (lock != null && lock.isHeldByCurrentThread()) { lock.unlock(); }` 是有意义的，尽管它不是原子操作。但是在这种情况下，仍然应该显式释放它，以降低并发出现误删锁的问题。

```java
    /**
     * Redisson实现分布式锁
     *
     * @return
     */
    public String saleTicketByRedisson() {
        String key = CACHE_INVENTORY_KEY;
        RLock lock = redisson.getLock(CACHE_INVENTORY_LOCK_KEY);
        lock.lock(30, TimeUnit.SECONDS);
        try {
            //查询库存信息
            Object obj = redisTemplate.opsForValue().get(key);
            if (null != obj) {
                int inventory = (Integer) obj;
                //判断库存是否足够
                if (inventory > 0) {
                    //扣减库存，减1
                    inventory -= 1;
                    redisTemplate.opsForValue().set(key, inventory);
                    log.info("端口号：{} 售出一张票，还剩下{}张票", port, inventory);
                    try {
                        TimeUnit.SECONDS.sleep(50);
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                    return "端口号：" + port + " 售出一张票，还剩下" + inventory + "张票";
                }
            }
        } finally {
            if (lock != null && lock.isHeldByCurrentThread()) {
                lock.unlock();
            }
        }
        return "端口号：" + port + " 售票失败，库存为0";
    }
```

总结

- 如果业务逻辑需要严格的排他性执行，并且执行时间可能超过一个可预测的固定时间窗口，那么应该使用 `lock()` 方法而不是 `lock(long leaseTime, TimeUnit unit)`。
- 在释放锁之前，始终检查锁是否由当前线程持有是一个好习惯，可以避免潜在的问题。
- 即使使用 `lock(long leaseTime, TimeUnit unit)` 并且锁已经过期，如果当前线程仍然持有锁对象，那么仍然应该显式释放它。



## 多实例redisson实现分布式锁

使用三台实例实现RedLock算法的Redisson分布式锁，这三台实例都是完全独立的。

| IP              | PORT | 角色   |
| --------------- | ---- | ------ |
| 192.168.122.132 | 7001 | master |
| 192.168.122.133 | 7002 | master |
| 192.168.122.134 | 7003 | master |

![image-20240314154459176](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403141545619.png)

为什么不是主从或者集群呢？

因为redis在进行主从复制时是异步完成的, 比如在clientA获取锁后, 主redis复制数据到从redis过程中崩溃了,导致没有复制到从redis中,然后从redis选举出一个升级为主redis, 造成新的主redis没有clientA设置的锁,这是clientB尝试获取锁,并且能够成功获取锁，导致互斥失效;

### Redisson RedLock实现加锁解锁

RedisConfig配置类

```java
import org.redisson.Redisson;
import org.redisson.api.RedissonClient;
import org.redisson.config.Config;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;

import java.io.Serializable;

/**
 * redis序列化工具类
 */

@Configuration
public class RedisConfig {


    /**
     * @param lettuceConnectionFactory
     * @return redis序列化的工具配置类
     * 1) "order:696"  序列化过
     * 2) "\xac\xed\x00\x05t\x00\order:696"   没有序列化过
     */
    @Bean
    public RedisTemplate<String, Serializable> redisTemplate(LettuceConnectionFactory lettuceConnectionFactory) {
        RedisTemplate<String, Serializable> redisTemplate = new RedisTemplate<>();
        redisTemplate.setConnectionFactory(lettuceConnectionFactory);
        //设置key序列化方式string
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        //设置value的序列化方式json
        redisTemplate.setValueSerializer(new GenericJackson2JsonRedisSerializer());
        redisTemplate.setHashKeySerializer(new StringRedisSerializer());
        redisTemplate.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());
        redisTemplate.afterPropertiesSet();
        return redisTemplate;
    }
    
    /**
     * 单机配置
     * @return
     */
    @Bean
    public Redisson redisson() {
        Config config = new Config();
        config.useSingleServer()
                // use "rediss://" for SSL connection
                .setAddress("redis://192.168.122.131:6379").setPassword("root");
        return (Redisson) Redisson.create(config);
    }
    
    /**
     * RedLock 3个各自独立的master
     * @return
     */
    @Bean
    RedissonClient redissonClient1(){
        Config config = new Config();
        config.useSingleServer().setAddress("redis://192.168.122.132:7001").setPassword("root");
        return Redisson.create(config);
    }
    @Bean
    RedissonClient redissonClient2(){
        Config config = new Config();
        config.useSingleServer().setAddress("redis://192.168.122.133:7002").setPassword("root");
        return Redisson.create(config);
    }

    @Bean
    RedissonClient redissonClient3(){
        Config config = new Config();
        config.useSingleServer().setAddress("redis://192.168.122.134:7003").setPassword("root");
        return Redisson.create(config);
    }
}
```

InventoryService：

https://github.com/redisson/redisson/wiki/8.-distributed-locks-and-synchronizers/#84-redlock RedLock提到Redisson使用RedLock实现多实例分布式锁已经被弃用了

![image-20240315110245021](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403151102460.png)

那么我们MultiLock多重锁的方式来实现，Redisson中的RedLock实现是基于MultiLock的概念，将多个锁合并为一个大锁，对一个大锁进行统一的申请加锁以及释放锁。

![image-20240315110157894](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403151101180.png)

```java
    @Resource
    private RedissonClient redissonClient1;
    @Resource
    private RedissonClient redissonClient2;
    @Resource
    private RedissonClient redissonClient3;

    /**
     * Redisson RedLock
     *
     * @return
     */
    public String saleTicketByRedissonV3() {
        String key = CACHE_INVENTORY_KEY;
        RLock lock1 = redissonClient1.getLock(CACHE_INVENTORY_LOCK_KEY);
        RLock lock2 = redissonClient2.getLock(CACHE_INVENTORY_LOCK_KEY);
        RLock lock3 = redissonClient3.getLock(CACHE_INVENTORY_LOCK_KEY);
        RedissonRedLock redLock = new RedissonRedLock(lock1, lock2, lock3);
        try {
            //waitTime:3 抢锁的等待时间3秒
            //leaseTime:300 key的过期时间30秒
            if (redLock.tryLock(3, 30, TimeUnit.SECONDS)) {
                log.info("端口号：{}，线程：{}，抢到锁了", port, Thread.currentThread().getId());
                //查询库存信息
                Object obj = redisTemplate.opsForValue().get(key);
                if (null != obj) {
                    int inventory = (Integer) obj;
                    //判断库存是否足够
                    if (inventory > 0) {
                        //扣减库存，减1
                        inventory -= 1;
                        redisTemplate.opsForValue().set(key, inventory);
                        log.info("端口号：{} 售出一张票，还剩下{}张票", port, inventory);
                        return "端口号：" + port + " 售出一张票，还剩下" + inventory + "张票";
                    }
                }
            } else {
                log.info("端口号：{},线程{}，没有抢到锁", port, Thread.currentThread().getId());
            }
        } catch (Exception e) {
            log.error("RedLock error:{}", e);
        } finally {
            redLock.unlock();
        }
        return "端口号：" + port + " 售票失败，库存为0";
    }
```

InventoryController：

```java
    @Operation(
            summary = "saleTicket",
            description = "售票"
    )
    @GetMapping("/saleTicket")
    public String saleTicket() {
        return inventoryService.saleTicketByRedissonV3();
    }
```

启动时三个RedissonClient初始化成功

![image-20240314205556209](F:\note\image\image-20240314205556209.png)

测试

8081

![image-20240314215639325](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403150915011.png)

8082

![](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403150915921.png)

### 模拟业务执行时间超过了锁的过期时间

```java
    @Resource
    private RedissonClient redissonClient1;
    @Resource
    private RedissonClient redissonClient2;
    @Resource
    private RedissonClient redissonClient3;

    /**
     * Redisson RedLock
     *
     * @return
     */
    public String saleTicketByRedissonV3() {
        String key = CACHE_INVENTORY_KEY;
        RLock lock1 = redissonClient1.getLock(CACHE_INVENTORY_LOCK_KEY);
        RLock lock2 = redissonClient2.getLock(CACHE_INVENTORY_LOCK_KEY);
        RLock lock3 = redissonClient3.getLock(CACHE_INVENTORY_LOCK_KEY);
        RedissonRedLock redLock = new RedissonRedLock(lock1, lock2, lock3);
        try {
            //waitTime:3 抢锁的等待时间3秒
            //leaseTime:30 key的过期时间30秒
            if (redLock.tryLock(3, 30, TimeUnit.SECONDS)) {
                log.info("端口号：{}，线程：{}，抢到锁了", port, Thread.currentThread().getId());
                //查询库存信息
                Object obj = redisTemplate.opsForValue().get(key);
                if (null != obj) {
                    int inventory = (Integer) obj;
                    //判断库存是否足够
                    if (inventory > 0) {
                        //扣减库存，减1
                        inventory -= 1;
                        redisTemplate.opsForValue().set(key, inventory);
                        log.info("端口号：{} 售出一张票，还剩下{}张票", port, inventory);
                        //模拟业务执行时间超过了锁的过期时间
                        TimeUnit.SECONDS.sleep(100);
                        return "端口号：" + port + " 售出一张票，还剩下" + inventory + "张票";
                    }
                }
            } else {
                log.info("端口号：{},线程{}，没有抢到锁", port, Thread.currentThread().getId());
            }
        } catch (Exception e) {
            log.error("RedLock error:{}", e);
        } finally {
            redLock.unlock();
        }
        return "端口号：" + port + " 售票失败，库存为0";
    }
```

请求http://192.168.122.131/inventory/saleTicket

```java
2024-03-15T05:46:17.706+08:00  INFO 38840 --- [redis_distributed_lock] [nio-8082-exec-1] c.d.redis.service.InventoryService       : 端口号：8082，线程：178，抢到锁了
2024-03-15T05:46:17.983+08:00  INFO 38840 --- [redis_distributed_lock] [nio-8082-exec-1] c.d.redis.service.InventoryService       : 端口号：8082 售出一张票，还剩下98张票
2024-03-15T05:46:47.787+08:00  INFO 38840 --- [redis_distributed_lock] [nio-8082-exec-2] c.d.redis.service.InventoryService       : 端口号：8082，线程：179，抢到锁了
2024-03-15T05:46:47.791+08:00  INFO 38840 --- [redis_distributed_lock] [nio-8082-exec-2] c.d.redis.service.InventoryService       : 端口号：8082 售出一张票，还剩下97张票
```

这里有个问题，redLock.tryLock()还是不会续期，超过过期时间锁就删除了，即使你业务还没有结束。

https://github.com/redisson/redisson/wiki/8.-distributed-locks-and-synchronizers/#81-lock MultiLock指出

![image-20240315105415695](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403151054452.png)

所以一定要保证过期时间远大于业务执行时间。经过测试redLock.tryLock()，RedLock会自动续期的。

```java
    public String saleTicketByRedissonV3() {
        String key = CACHE_INVENTORY_KEY;
        RLock lock1 = redissonClient1.getLock(CACHE_INVENTORY_LOCK_KEY);
        RLock lock2 = redissonClient2.getLock(CACHE_INVENTORY_LOCK_KEY);
        RLock lock3 = redissonClient3.getLock(CACHE_INVENTORY_LOCK_KEY);
        RedissonRedLock redLock = new RedissonRedLock(lock1, lock2, lock3);
        try {
            if (redLock.tryLock()) {
                log.info("端口号：{}，线程：{}，抢到锁了", port, Thread.currentThread().getId());
                //查询库存信息
                Object obj = redisTemplate.opsForValue().get(key);
                if (null != obj) {
                    int inventory = (Integer) obj;
                    //判断库存是否足够
                    if (inventory > 0) {
                        //扣减库存，减1
                        inventory -= 1;
                        redisTemplate.opsForValue().set(key, inventory);
                        log.info("端口号：{} 售出一张票，还剩下{}张票", port, inventory);
                        //模拟业务执行时间超过了锁的过期时间
                        TimeUnit.SECONDS.sleep(100);
                        return "端口号：" + port + " 售出一张票，还剩下" + inventory + "张票";
                    }
                }
            } else {
                log.info("端口号：{},线程{}，没有抢到锁", port, Thread.currentThread().getId());
            }
        } catch (Exception e) {
            log.error("RedLock error:{}", e);
        } finally {
            redLock.unlock();
        }
        return "端口号：" + port + " 售票失败，库存为0";
    }
```



### 7003宕机，查看RedLock锁是否还能正常加锁解锁。

```shell
[root@redis-7003 myredis]# redis-cli -a root -p 7003
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.
127.0.0.1:7003> shutdown
not connected> quit
```

请求http://192.168.122.131/inventory/saleTicket，一切正常

![image-20240315055529197](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403150558826.png)



![image-20240315055539752](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403150558148.png)



### 7002也宕机，查看RedLock锁是否还能正常加锁解锁。

```shll
[root@redis-7002 ~]# redis-cli -a root -p 7002 -c
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.
127.0.0.1:7002> shutdown
not connected> quit
```

超过一般以上的实例宕机，加锁失败。

![image-20240315055751364](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403150558295.png)



### 结论：

RedLock的设计初衷是为了解决单个Redis节点作为分布式锁时的单点故障问题。它通过要求客户端在多个独立的Redis节点上获取锁，只有当大多数节点成功获取锁时才认为整体获取锁成功。但节点如果出现崩溃重启，对锁的安全性依旧存在问题。

- 假如一共有5个Redis节点：A,B,C,D,E。

- 客户端1成功锁住了A，B，C，获取锁成功（但D和E没有锁住）。

- 节点C崩溃重启，但客户端1在C上加的锁没有持久化下来，aof机制导致C上的锁丢失。

- 节点C重启后，客户端2锁住了C，D,E，获取锁成功。·

Redis的AOF持久化默认配置是每秒执行一次fsync，这意味着最坏情况下可能丢失1秒内的数据。而设置成每次修改数据都进行fsync会严重影响性能，这通常不是推荐的做法。

即使执行了fsync，数据的安全性仍然取决于操作系统的刷盘策略，因为数据可能首先被写入到操作系统的文件系统缓存中。

建议延迟重启，一个节点崩溃后，先不立即重启它，而是等待一段时间再重启，这段时间应该大于锁的有效时间。

因为在这个等待期间，任何依赖于该节点上锁的分布式操作都应该已经完成或者超时。重启后就不会对现有的锁造成影响。

# Redisson源码解析

## lock.lock(）

### 1.Redison获取的锁，默认过期时间为30秒

```
lock.lock()     //默认过期时间30秒
```

查看源码RedissonLock.java，所得有效时间是通过commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout();获得的

```java
public class RedissonLock extends RedissonBaseLock {
	//锁的有效时间
    protected long internalLockLeaseTime;

    protected final LockPubSub pubSub;

    final CommandAsyncExecutor commandExecutor;

    public RedissonLock(CommandAsyncExecutor commandExecutor, String name) {
        super(commandExecutor, name);
        this.commandExecutor = commandExecutor;
        this.internalLockLeaseTime = commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout();
        this.pubSub = commandExecutor.getConnectionManager().getSubscribeService().getLockPubSub();
    }
    .......
}
```

查看Config.getLockWatchdogTimeout()方法lockWatchdogTimeout值是30000

```java
public class Config { 
    private long lockWatchdogTimeout = 30 * 1000;
    
 	public long getLockWatchdogTimeout() {
        return lockWatchdogTimeout;
    }
}    
```



追踪lock.lock(）源码，默认的过期时间设置为-1,时间单位为null。

```java
    @Override
    public void lock() {
        try {
            lock(-1, null, false);
        } catch (InterruptedException e) {
            throw new IllegalStateException();
        }
    }
```

继续追踪到tryAcquireAsync(long waitTime, long leaseTime, TimeUnit unit, long threadId)方法，当

leaseTime=-1时执行tryLockInnerAsync(),时间单位为TimeUnit.MILLISECONDS毫秒。此时internalLockLeaseTime值为30000，所以默认过期时间是30秒。

```java
ttlRemainingFuture = tryLockInnerAsync(waitTime, internalLockLeaseTime,
                    TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);
```

tryAcquireAsync(long waitTime, long leaseTime, TimeUnit unit, long threadId):

```java
    private <T> RFuture<Long> tryAcquireAsync(long waitTime, long leaseTime, TimeUnit unit, long threadId) {
        RFuture<Long> ttlRemainingFuture;
        if (leaseTime > 0) {
            ttlRemainingFuture = tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);
        } else {
            ttlRemainingFuture = tryLockInnerAsync(waitTime, internalLockLeaseTime,
                    TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);
        }
        CompletionStage<Long> f = ttlRemainingFuture.thenApply(ttlRemaining -> {
            // lock acquired
            if (ttlRemaining == null) {
                if (leaseTime > 0) {
                    internalLockLeaseTime = unit.toMillis(leaseTime);
                } else {
                    scheduleExpirationRenewal(threadId);
                }
            }
            return ttlRemaining;
        });
        return new CompletableFutureWrapper<>(f);
    }
```

tryLockInnerAsync()加锁，看到这个lua脚本应该会有似曾相识的感觉，因为之前使用lua脚本实现redis分布式锁就这这么写的。

1.如果锁不存在 或 锁存在但获取锁的线程是当前线程，则通过hset设置值，value值+1，并设置过期时间。  加锁成功

2.如果锁存在但获取锁的线程不是当前线程，返回锁的过期时间。 加锁失败

```java
    <T> RFuture<T> tryLockInnerAsync(long waitTime, long leaseTime, TimeUnit unit, long threadId, RedisStrictCommand<T> command) {
        return evalWriteAsync(getRawName(), LongCodec.INSTANCE, command,
                "if ((redis.call('exists', KEYS[1]) == 0) " +
                            "or (redis.call('hexists', KEYS[1], ARGV[2]) == 1)) then " +
                        "redis.call('hincrby', KEYS[1], ARGV[2], 1); " +
                        "redis.call('pexpire', KEYS[1], ARGV[1]); " +
                        "return nil; " +
                    "end; " +
                    "return redis.call('pttl', KEYS[1]);",
                Collections.singletonList(getRawName()), unit.toMillis(leaseTime), getLockName(threadId));
    }
```

### 2.缓存续期

执行完tryLockInnerAsync()获取锁成功后,是异步编程代码，意思是异步获取锁成功后acquired为true，leaseTime=-1，则执行scheduleExpirationRenewal(threadId);

```java
        CompletionStage<Boolean> f = acquiredFuture.thenApply(acquired -> {
            // lock acquired
            if (acquired) {
                if (leaseTime > 0) {
                    internalLockLeaseTime = unit.toMillis(leaseTime);
                } else {
                    scheduleExpirationRenewal(threadId);
                }
            }
            return acquired;
        });
```

RedissonBaseLock：

实现缓存续期的方法是renewExpiration();

```java
    protected void scheduleExpirationRenewal(long threadId) {
        ExpirationEntry entry = new ExpirationEntry();
        ExpirationEntry oldEntry = EXPIRATION_RENEWAL_MAP.putIfAbsent(getEntryName(), entry);
        if (oldEntry != null) {
            oldEntry.addThreadId(threadId);
        } else {
            entry.addThreadId(threadId);
            try {
                renewExpiration();
            } finally {
                if (Thread.currentThread().isInterrupted()) {
                    cancelExpirationRenewal(threadId);
                }
            }
        }
    }
```

renewExpiration：

开启一个定时任务，延迟时间是internalLockLeaseTime / 3, TimeUnit.MILLISECONDS，即10秒。

```java
    private void renewExpiration() {
        ExpirationEntry ee = EXPIRATION_RENEWAL_MAP.get(getEntryName());
        if (ee == null) {
            return;
        }
        
        Timeout task = commandExecutor.getConnectionManager().newTimeout(new TimerTask() {
            @Override
            public void run(Timeout timeout) throws Exception {
                ExpirationEntry ent = EXPIRATION_RENEWAL_MAP.get(getEntryName());
                if (ent == null) {
                    return;
                }
                Long threadId = ent.getFirstThreadId();
                if (threadId == null) {
                    return;
                }
                
                CompletionStage<Boolean> future = renewExpirationAsync(threadId);
                future.whenComplete((res, e) -> {
                    if (e != null) {
                        log.error("Can't update lock {} expiration", getRawName(), e);
                        EXPIRATION_RENEWAL_MAP.remove(getEntryName());
                        return;
                    }
                    
                    if (res) {
                        // reschedule itself
                        renewExpiration();
                    } else {
                        cancelExpirationRenewal(null);
                    }
                });
            }
        }, internalLockLeaseTime / 3, TimeUnit.MILLISECONDS);
        
        ee.setTimeout(task);
    }
```

renewExpirationAsync：

实现缓存续期的lua脚本，缓存过期时间重新设置为internalLockLeaseTime 30秒

```java
    protected CompletionStage<Boolean> renewExpirationAsync(long threadId) {
        return evalWriteAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,
                "if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then " +
                        "redis.call('pexpire', KEYS[1], ARGV[1]); " +
                        "return 1; " +
                        "end; " +
                        "return 0;",
                Collections.singletonList(getRawName()),
                internalLockLeaseTime, getLockName(threadId));
    }
```

使用`whenComplete`方法注册一个回调函数，该函数在异步操作完成时执行。

如果操作成功且返回`true`续期成功，则重新安排`renewExpiration`任务以确保锁的过期时间持续得到续订；那么这个定时任务每隔10秒执行一直续期，将过期时间设置为30秒。

如果操作失败或返回`false`续期失败，则调用`cancelExpirationRenewal`来取消过期续订。从`task`中移除与`threadId`相关联的线程，取消定时任务。

```java
                CompletionStage<Boolean> future = renewExpirationAsync(threadId);
                future.whenComplete((res, e) -> {
                    if (e != null) {
                        log.error("Can't update lock {} expiration", getRawName(), e);
                        EXPIRATION_RENEWAL_MAP.remove(getEntryName());
                        return;
                    }
                    
                    if (res) {
                        // reschedule itself
                        renewExpiration();
                    } else {
                        cancelExpirationRenewal(null);
                    }
                });
```

## lock.unlcok()

```java
    @Override
    public void unlock() {
        try {
            get(unlockAsync(Thread.currentThread().getId()));
        } catch (RedisException e) {
            if (e.getCause() instanceof IllegalMonitorStateException) {
                throw (IllegalMonitorStateException) e.getCause();
            } else {
                throw e;
            }
        }
        
//        Future<Void> future = unlockAsync();
//        future.awaitUninterruptibly();
//        if (future.isSuccess()) {
//            return;
//        }
//        if (future.cause() instanceof IllegalMonitorStateException) {
//            throw (IllegalMonitorStateException)future.cause();
//        }
//        throw commandExecutor.convertException(future);
    }
```

追踪源码unlockInnerAsync()

释放锁的lua脚本

1.如果释放锁的线程与当前获得锁的线程不是同一个线程，直接返回null

2.否则通过hincrby减1，释放一次锁，如果锁重入次数大于0，刷新过期时间。

3.锁重入次数不是大于0，删除key并发布锁释放的消息。

```java
    protected RFuture<Boolean> unlockInnerAsync(long threadId) {
        return evalWriteAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,
              "if (redis.call('hexists', KEYS[1], ARGV[3]) == 0) then " +
                        "return nil;" +
                    "end; " +
                    "local counter = redis.call('hincrby', KEYS[1], ARGV[3], -1); " +
                    "if (counter > 0) then " +
                        "redis.call('pexpire', KEYS[1], ARGV[2]); " +
                        "return 0; " +
                    "else " +
                        "redis.call('del', KEYS[1]); " +
                        "redis.call('publish', KEYS[2], ARGV[1]); " +
                        "return 1; " +
                    "end; " +
                    "return nil;",
                Arrays.asList(getRawName(), getChannelName()), LockPubSub.UNLOCK_MESSAGE, internalLockLeaseTime, getLockName(threadId));
    }
```

