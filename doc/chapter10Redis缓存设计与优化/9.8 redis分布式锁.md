

单机锁：同一个JVM虚拟机内，使用synchronized或者Lock接口

分布式锁：多个不同JVM虚拟机，使用分布式锁

# 分布式锁需要具备的条件

- 独占性：      OnlyOne，任何时刻只能有且仅有一个线程持有

- 高可用：     若redis集群环境下，不能因为某一个节点挂了而出现获取锁和释放锁失败的情况。高并发场景，性能依然可以。

- 防死锁：     杜绝死锁，必须有超时控制机制或者解锁操作。

- 不乱抢：     防止张冠李戴，不能删除别人的锁，只能释放自己加的锁

- 重入性：     同一个节点的同一个线程如果获得锁之后，也可以再次获取这个锁。

# reids分布式锁命令

## 1.SETNX key value

当key不存在的时候，创建key。

注：SETNX key value 和 EXPIRE key seconds两个操作并不是原子性的，这意味着在SETNX和EXPIRE 之间系统崩溃，可能导致key永久有效。

```shell
127.0.0.1:6379> SETNX k1 v1
(integer) 1
127.0.0.1:6379> EXPIRE k1 10
(integer) 1
```

为了确保这两个操作的原子性，可以使用SET key value [NX | XX]  [EX seconds | PX milliseconds] 

## 2.SET key value [NX | XX]  [EX seconds | PX milliseconds] 

EX: key在多少秒后过期

PX: key在多少毫秒后过期

NX：当key不存在的时候，创建key，等同于SETNX

XX: 当key存在的时候，覆盖key

# 单机锁实战

需求：实现买票扣减库存的业务。

## 1.创建项目redis_distributed_lock，修改pom

```xml
	<dependencies>
		<dependency>
			<groupId>com.dongguo</groupId>
			<artifactId>redis_core</artifactId>
			<version>0.0.1-SNAPSHOT</version>
		</dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <!--导入SpringBoot集成Open API 3.0（Swagger3.0）的坐标 -->
        <dependency>
            <groupId>org.springdoc</groupId>
            <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
        </dependency>
		<dependency>
			<groupId>org.projectlombok</groupId>
			<artifactId>lombok</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>log4j</groupId>
			<artifactId>log4j</artifactId>
		</dependency>
	</dependencies>
```

## 2.配置application.yml

```yaml
server:
  port: 8081
spring:
  application:
    name: redis_distributed_lock
  # ========================redis相关配置=====================
  data:
    redis:
      host: 192.168.122.131
      port: 6379
      password: root
# ========================swagger=====================
springdoc:
  swagger-ui:
    enabled: true
    path: /swagger-ui.html
```

## 3.代码实现

InventoryService：使用synchronized解决库存超卖问题。

```java
import jakarta.annotation.Resource;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;
import static com.dongguo.redis.utils.CacheKeyUtil.CACHE_INVENTORY_KEY;

/**
 * @Author: Administrator
 * @Date: 2024-03-12
 */
@Service
@Slf4j
public class InventoryService {
    @Value(value = "${server.port}")
    private Integer port;
    @Resource
    private RedisTemplate redisTemplate;

    public void initInventory() {
        //初始化库存100
        redisTemplate.opsForValue().set(CACHE_INVENTORY_KEY, 100);
    }

    public synchronized String saleTicket() {

        //查询库存信息
        Object obj = redisTemplate.opsForValue().get(CACHE_INVENTORY_KEY);
        if (null != obj) {
            int inventory = (Integer) obj;
            //判断库存是否足够
            if (inventory > 0) {
                //扣减库存，减1
                inventory -= 1;
                redisTemplate.opsForValue().set(CACHE_INVENTORY_KEY, inventory);
                log.info("端口号：{} 售出一张票，还剩下{}张票", port, inventory);
                return "端口号：" + port + " 售出一张票，还剩下" + inventory + "张票";
            }
        }
        return "端口号：" + port + " 售票失败，库存为0";
    }
}
```

InventoryController：

```java
import com.dongguo.redis.service.InventoryService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.annotation.Resource;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * @Author: Administrator
 * @Date: 2024-03-12
 */
@RestController
@RequestMapping("/inventory")
@Tag(
        name = "InventoryController",
        description = "库存控制器接口")
public class InventoryController {

    @Resource
    private InventoryService inventoryService;

    @Operation(
            summary = "initInventory",
            description = "初始化库存"
    )
    @GetMapping("/initInventory")
    public void initInventory() {
        inventoryService.initInventory();
    }

    @Operation(
            summary = "saleTicket",
            description = "售票"
    )
    @GetMapping("/saleTicket")
    public String saleTicket() {
        return inventoryService.saleTicket();
    }
}
```

如果是单体项目，使用synchronized是可以解决超卖问题的，但是如果是分布式项目，还是会出现超卖问题，那就需要使用分布式锁了。

# 分布式锁实战

架构：使用nginx实现反向代理、负载均衡，请求负载均衡落在两个实例上。



![image-20240312190952214](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403121910237.png)

## Nginx配置负载均衡

### windows启动nginx

nginx这里使用win版的，路径为E:\software\nginx\nginx-1.24.0-distributed-lock

启动nginx: `start nginx.exe`

查看是否能正常访问：localhost:80，

![image-20240312224805659](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403122248832.png)

访问不成功，请排查是否80端口冲突：`netstat -aon|findstr 80`

通过对应PID，查看冲突的应用是哪个，`tasklist|findstr PID`

4关闭nginx：`nginx -s stop`

重启nginx：	`nginx -s reload`

每次启动都是开启一个新的进程，查看开启了多少个nginx：`tasklist |findstr "nginx.exe"`

 强制杀死所有nginx进程：`taskkill /f /t /im "nginx.exe"`

#### 1.配置文件nginx.conf配置反向代理和负载均衡配置

配置反向代理和负载均衡，轮询访问两个实例。

```shell
    #负载均衡
   	upstream mynginx {
           server 127.0.0.1:8081 max_fails=5 fail_timeout=10s weight=1;
           server 127.0.0.1:8082 max_fails=5 fail_timeout=10s weight=1;
   	}
    server {
        listen       80;
        server_name  localhost;

        location / {
           # root   html;
			proxy_pass http://mynginx;
            index  index.html index.htm;
        }


        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
    }
```

#### 2.启动nginx

```shell
start nginx.exe
```

#### 启动两个实例8081/8082

只有一个项目怎么启动多个实例呢？

#### 1.设置项目允许运行多个实例

右键RedisDistributedLockApplication，点击Edit Configration

![image-20240312204426912](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403122044321.png)

也可以在工具栏中找到该项目点击Edit Configration*

![image-20240312204444490](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403122044578.png)

点击Modify options，选中allow multiple instances，项目允许运行多个实例

![image-20240312204452220](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403122044374.png)

#### 2.启动两个实例

然后继续选中addVM options，填入-Dserver.port=8081，点击运行就启动一个新的实例，填入-Dserver.port=8082，点击运行再启动一个新的实例了

![image-20240312204608263](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403122046201.png)

这样就启动了两个代码相同，端口不同的实例

![image-20240312204717627](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403122047452.png)

访问接口：http://localhost/inventory/saleTicket，多次请求。

8082实例：

![image-20240313071241154](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403130713438.png)

8081实例：

![image-20240313071258501](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403130713914.png)

### **linux启动nginx**

进入到nginx目录/opt/nginx-1.24.0/conf，进行相同的nginx.conf配置

启动nginx：`sbin/nginx -c conf/nginx.conf`

关闭nginx：`sbin/nginx -s stop`

访问http://192.168.122.131/inventory/saleTicket

![image-20240313081824315](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403130818536.png)

![image-20240313083025607](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403130830971.png)

每请求一次，票数减1，表面上看是没什么问题。在高并发下有没有问题，那就需要进一步的验证了。

## 高并发压测

使用Jmeter模拟高并发请求，打开Jmeter后添加一个线程组

![image-20240313092817442](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403130929507.png)

设置100个线程，在1秒钟内一致性

![image-20240313092952975](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403130929621.png)

在线程组中，添加一个http请求

![image-20240313093123916](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403130931105.png)

配置http请求对应http://192.168.122.131/inventory/saleTicket

![image-20240313093436783](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403130934815.png)

添加一个几个监听器，查看压测情况。

![image-20240313093949102](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403131019369.png)

运行当前线程组

![image-20240313094033839](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403131019640.png)

运行结果报告，100个线程的请求都成功了：

![image-20240313101335333](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403131019545.png)

按照正常情况来说，100个请求，库存正好扣减为0，但是查看reids库存还有28

![image-20240313101912421](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403131019172.png)

查看8081和8082实例的控制台，发现他们存在卖出同一张票的情况，那这样就出现了经典的超卖现象了。

![image-20240313102058684](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403131021021.png)



![image-20240313102117972](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403131021379.png)

分析：在单机幻境下，可以使用synchronized或Lock来解决库存超卖的问题。但是在分布式系统中，竞争的线程可能不再同一实例上，单机锁鞭长莫及了。所以我们需要使用分布式锁（比如redis或zookeeper实现），让所有实例都能访问到同一把锁。

## 分布式锁

修改代码，使用redis实现分布式锁，解决超卖问题

InventoryService：

```java
import cn.hutool.core.lang.UUID;
import jakarta.annotation.Resource;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;
import java.util.concurrent.TimeUnit;
import static com.dongguo.redis.utils.CacheKeyUtil.CACHE_INVENTORY_KEY;
import static com.dongguo.redis.utils.CacheKeyUtil.CACHE_INVENTORY_LOCK_KEY;

/**
 * @Author: Administrator
 * @Date: 2024-03-12
 */
@Service
@Slf4j
public class InventoryService {
    @Value(value = "${server.port}")
    private Integer port;
    @Resource
    private RedisTemplate redisTemplate;

    public void initInventory() {
        //初始化库存100
        redisTemplate.opsForValue().set(CACHE_INVENTORY_KEY, 100);
    }

    /**
     * redis分布式锁解决分布式场景超卖问题
     * @return
     */
    public String saleTicketV2() {
        String key = CACHE_INVENTORY_KEY;
        String lockKey = CACHE_INVENTORY_LOCK_KEY;
        String value = UUID.fastUUID() + ":" + Thread.currentThread().getId();
        Boolean absent = redisTemplate.opsForValue().setIfAbsent(lockKey, value);
        if (!absent) {
            //获取不到锁，进行重试
            try {
                TimeUnit.MILLISECONDS.sleep(20);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            return saleTicketV2();
        }
        try {
            //查询库存信息
            Object obj = redisTemplate.opsForValue().get(key);
            if (null != obj) {
                int inventory = (Integer) obj;
                //判断库存是否足够
                if (inventory > 0) {
                    //扣减库存，减1
                    inventory -= 1;
                    redisTemplate.opsForValue().set(key, inventory);
                    log.info("端口号：{} 售出一张票，还剩下{}张票", port, inventory);
                    return "端口号：" + port + " 售出一张票，还剩下" + inventory + "张票";
                }
            }
        } finally {
            redisTemplate.delete(lockKey);
        }
        return "端口号：" + port + " 售票失败，库存为0";
    }
}
```

InventoryController：

```java
    @Operation(
            summary = "saleTicket",
            description = "售票"
    )
	@GetMapping("/saleTicket")
    public String saleTicket() {
        return inventoryService.saleTicketV2();
    }
```

重启两个实例，将Jmeter再次运行线程组。

压测完后，查看redis中库存扣减为0了，这是符合预期的。

```shell
127.0.0.1:6379> get redis:inventory
"0"
```

然后看一下两个实例的控制台

8081：

![image-20240313134558952](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403131348996.png)

8082：

![image-20240313134611776](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403131348277.png)

目前使用redis实现分布式锁，解决超卖问题，那么让我们来分析下代码还可能会有什么问题吧。



### 问题1：递归重试可能出现栈溢出的问题。

使用自旋替代递归重试，而且代码中使用while替代if。

InventoryService：

```java
    /**
     * 自旋代替递归
     * @return
     */
    public String saleTicketV3() {
        String key = CACHE_INVENTORY_KEY;
        String lockKey = CACHE_INVENTORY_LOCK_KEY;
        String value = UUID.fastUUID() + ":" + Thread.currentThread().getId();
        //获取不到锁，自旋
        while (!redisTemplate.opsForValue().setIfAbsent(lockKey, value)) {
            try {
                TimeUnit.MILLISECONDS.sleep(20);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
        try {
            //查询库存信息
            Object obj = redisTemplate.opsForValue().get(key);
            if (null != obj) {
                int inventory = (Integer) obj;
                //判断库存是否足够
                if (inventory > 0) {
                    //扣减库存，减1
                    inventory -= 1;
                    redisTemplate.opsForValue().set(key, inventory);
                    log.info("端口号：{} 售出一张票，还剩下{}张票", port, inventory);
                    return "端口号：" + port + " 售出一张票，还剩下" + inventory + "张票";
                }
            }
        } finally {
            redisTemplate.delete(lockKey);
        }
        return "端口号：" + port + " 售票失败，库存为0";
    }
```

InventoryController：

```java
    @Operation(
            summary = "saleTicket",
            description = "售票"
    ) 
	@GetMapping("/saleTicket")
    public String saleTicket() {
        return inventoryService.saleTicketV3();
    }
```

### 问题2：分布式锁没有设置过期时间，如果加锁后，机器宕机了，就无法释放锁导致死锁。机器重启后，那么之后的请求就会无限自旋了。

加锁时设置一个过期时间，要注意的是加锁和设置过期时间这两个操作要是原子操作。

InventoryService：

```java
    /**
     * 分布式锁设置过期时间
     * 注意加锁和设置过期时间要保证原子性
     *
     * @return
     */
    public String saleTicketV4() {
        String key = CACHE_INVENTORY_KEY;
        String lockKey = CACHE_INVENTORY_LOCK_KEY;
        String value = UUID.fastUUID() + ":" + Thread.currentThread().getId();
        //获取不到锁，自旋
        while (!redisTemplate.opsForValue().setIfAbsent(lockKey, value, 30, TimeUnit.SECONDS)) {
            try {
                TimeUnit.MILLISECONDS.sleep(20);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
        try {
            //查询库存信息
            Object obj = redisTemplate.opsForValue().get(key);
            if (null != obj) {
                int inventory = (Integer) obj;
                //判断库存是否足够
                if (inventory > 0) {
                    //扣减库存，减1
                    inventory -= 1;
                    redisTemplate.opsForValue().set(key, inventory);
                    log.info("端口号：{} 售出一张票，还剩下{}张票", port, inventory);
                    return "端口号：" + port + " 售出一张票，还剩下" + inventory + "张票";
                }
            }
        } finally {
            redisTemplate.delete(lockKey);
        }
        return "端口号：" + port + " 售票失败，库存为0";
    }
```

InventoryController：

```java
    @Operation(
            summary = "saleTicket",
            description = "售票"
    )
	@GetMapping("/saleTicket")
    public String saleTicket() {
        return inventoryService.saleTicketV4();
    }
```

### 问题3：加锁设置过期时间，如果业务执行时间超过了过期时间，锁自动过期了后执行删除锁的操作，可能会删除其他线程的锁。

![image-20240313150239675](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403131502251.png)

在删除锁之前判断是否是自己加的锁。

InventoryService：

```java
    /**
     * 判断是否是自己加的锁，再释放锁
     * @return
     */
    public String saleTicketV5() {
        String key = CACHE_INVENTORY_KEY;
        String lockKey = CACHE_INVENTORY_LOCK_KEY;
        String value = UUID.fastUUID() + ":" + Thread.currentThread().getId();
        //获取不到锁，自旋
        while (!redisTemplate.opsForValue().setIfAbsent(lockKey, value, 30, TimeUnit.SECONDS)) {
            try {
                TimeUnit.MILLISECONDS.sleep(20);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
        try {
            //查询库存信息
            Object obj = redisTemplate.opsForValue().get(key);
            if (null != obj) {
                int inventory = (Integer) obj;
                //判断库存是否足够
                if (inventory > 0) {
                    //扣减库存，减1
                    inventory -= 1;
                    redisTemplate.opsForValue().set(key, inventory);
                    log.info("端口号：{} 售出一张票，还剩下{}张票", port, inventory);
                    return "端口号：" + port + " 售出一张票，还剩下" + inventory + "张票";
                }
            }
        } finally {
            //判断是自己上的锁，才释放锁
            if (value.equals(redisTemplate.opsForValue().get(key))){
                redisTemplate.delete(lockKey);
            }
        }
        return "端口号：" + port + " 售票失败，库存为0";
    }
```

InventoryController：

```java
    @Operation(
            summary = "saleTicket",
            description = "售票"
    )
    @GetMapping("/saleTicket")
    public String saleTicket() {
        return inventoryService.saleTicketV5();
    }
```

### 问题4：判断是否是自己上的锁和删除锁这两个操作不是原子操作

RedisTemplate并没有为这两个操作提供原子操作，那么只能我们自己去实现。可以使用Lua脚本实现原子操作。

https://redis.io/docs/manual/patterns/distributed-locks/ 官网中给出了这两个操作的lua脚本

```lua
if redis.call("get",KEYS[1]) == ARGV[1] then
    return redis.call("del",KEYS[1])
else
    return 0
end
```

KEYS[1] : key

ARGV[1]  : value

InventoryService：

```java
    /**
     * lua脚本实现判断是否是自己上的锁和删除锁是一个原子操作。
     *
     * @return
     */
    public String saleTicketV6() {
        String key = CACHE_INVENTORY_KEY;
        String lockKey = CACHE_INVENTORY_LOCK_KEY;
        String value = UUID.fastUUID() + ":" + Thread.currentThread().getId();
        //获取不到锁，自旋
        while (!redisTemplate.opsForValue().setIfAbsent(lockKey, value, 30, TimeUnit.SECONDS)) {
            try {
                TimeUnit.MILLISECONDS.sleep(20);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
        try {
            //查询库存信息
            Object obj = redisTemplate.opsForValue().get(key);
            if (null != obj) {
                int inventory = (Integer) obj;
                //判断库存是否足够
                if (inventory > 0) {
                    //扣减库存，减1
                    inventory -= 1;
                    redisTemplate.opsForValue().set(key, inventory);
                    log.info("端口号：{} 售出一张票，还剩下{}张票", port, inventory);
                    return "端口号：" + port + " 售出一张票，还剩下" + inventory + "张票";
                }
            }
        } finally {
            String luaScript =
                    "if redis.call('get',KEYS[1]) == ARGV[1] then " +
                            "return redis.call('del',KEYS[1]) " +
                            "else " +
                            "return 0 " +
                            "end";
            //返回值为0,1 使用Boolean接收，自动拆箱机制会将0 或 1 自动转换为 boolean 类型的 false 或 true
            redisTemplate.execute(new DefaultRedisScript(luaScript, Boolean.class), Collections.singletonList(lockKey), value);
        }
        return "端口号：" + port + " 售票失败，库存为0";
    }
```

InventoryController

```java
    @Operation(
            summary = "saleTicket",
            description = "售票"
    )
    @GetMapping("/saleTicket")
    public String saleTicket() {
        return inventoryService.saleTicketV6();
    }
```

说明：new DefaultRedisScript(luaScript, Long.class)中luaScript是执行的lua脚本，Long.class是指定脚本返回值的类型。

```java
	/**
	 * Creates a new {@link DefaultRedisScript}
	 *
	 * @param script must not be {@literal null}.
	 * @param resultType can be {@literal null}.
	 */
	public DefaultRedisScript(String script, @Nullable Class<T> resultType) {

		this.setScriptText(script);
		this.resultType = resultType;
	}
```

### 问题5：redis实现的分布式锁setnx不是可重入的，如何兼顾锁的可重入性呢？

使用lua脚本通过hash实现分布式锁加锁解锁，从而实现锁的可重入。

#### 1.加锁，先判断key是否存在

使用setnx实现分布式锁时，value是UUID:ThreadID,

使用hash实现分布式锁field是：UUID:ThreadID，value是重入的次数。

加锁思路：

使用`exists key`判断是否存在key，返回0说明不存在，使用`hset key field 1`新增key。返回1说明存在，需要进一步判断是不是自己的锁。

使用`hexists key field`判断是不是自己的锁，返回0说明不是，返回1说明是，获取锁成功，使用`hincrby key field 1`将重入次数+1。  

`hincrby key field 1`在key不存在时，会创建key。可以替代`hset key field 1`

对应的lua脚本：

```lua
if redis.call('exists', KEYS[1]) == 0 or redis.call('hexists', KEYS[1], ARGV[1]) == 1 then  
    redis.call('hincrby', KEYS[1], ARGV[1], 1)  
    redis.call('expire', KEYS[1], ARGV[2])  
    return 1  
else  
    return 0  
end
```

KEYS[1] : key

ARGV[1] : value

ARGV[2] : 过期时间

#### 2.解锁，有锁，并且是自己的锁

解锁思路：

使用`hexists key field`判断是否存在自己的锁，返回0，说明没有锁，什么都不干；

返回1，说明存在自己的锁，直接调用`hincrby key field -1`进行解锁-1;

当value变为0，表示重入的锁都已经解锁，`del key`删除key

对应的lua脚本：

```lua
if redis.call('HEXISTS', KEYS[1], ARGV[1]) == 0 then  
    return nil  
elseif redis.call('HINCRBY', KEYS[1], ARGV[1], -1) == 0 then  
    return redis.call('del', KEYS[1])  
else  
    return 0  
end
```

KEYS[1]: key

ARGV[1]: field

#### 3.将lua脚本整合到项目中。

##### 3.1新建RedisDistributedLock类并，实现Lock接口

根据Lock锁的接口规范实现Redis的可重入锁。

RedisDistributedLock：主要实现lock()、unlock()两个方法。

```java
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.script.DefaultRedisScript;
import java.util.Collections;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;

/**
 * Redis分布式锁
 * lua脚本实现分布式锁的可重入性，实现Lock接口
 */
@Slf4j
public class RedisDistributedLock implements Lock {

    private RedisTemplate redisTemplate;
    private String key;
    private String value;
    private Integer expire;

    /**
     * 默认过期时间30秒
     *
     * @param redisTemplate
     * @param key
     * @param uuid
     */
    public RedisDistributedLock(RedisTemplate redisTemplate, String key, String uuid) {
        this.redisTemplate = redisTemplate;
        this.key = key;
        //同一个实例uuid相同，不同线程对应不同的ThreadId
        this.value = uuid + ":" + Thread.currentThread().getId();
        this.expire = 30;
    }

    /**
     * 加锁方法
     * 阻塞方法。如果当前线程未持有锁，它会一直等待，直到获取到锁为止。
     * 这里简化lock方法直接调用tryLock方法
     */
    @Override
    public void lock() {
        tryLock();
    }

    /**
     * 非阻塞方法。如果当前线程能够立即获取到锁，则返回true；如果锁被其他线程持有，则立即返回false
     *
     * @return
     */
    @Override
    public boolean tryLock() {
        return tryLock(expire, TimeUnit.SECONDS);

    }

    /**
     * 真正调用的加锁方法
     *
     * @param time the maximum time to wait for the lock
     * @param unit the time unit of the {@code time} argument
     * @return
     */
    @Override
    public boolean tryLock(long time, TimeUnit unit) {
        //将过期时间转换为秒
        long expire = unit.toSeconds(time);
        String script =
                "if redis.call('exists', KEYS[1]) == 0 or redis.call('hexists', KEYS[1], ARGV[1]) == 1 then  " +
                        "    redis.call('hincrby', KEYS[1], ARGV[1], 1)  " +
                        "    redis.call('expire', KEYS[1], ARGV[2])  " +
                        "    return 1  " +
                        "else  " +
                        "    return 0  " +
                        "end";
        while (!(Boolean) redisTemplate.execute(new DefaultRedisScript<>(script, Boolean.class), Collections.singletonList(key), value, expire)) {
            try {
                TimeUnit.MILLISECONDS.sleep(10);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
        log.info("lock()   key:{}, value:{}", key, value);
        return true;
    }

    /**
     * 解锁方法
     */
    @Override
    public void unlock() {
        String script =
                "if redis.call('HEXISTS', KEYS[1], ARGV[1]) == 0 then  " +
                        "    return nil  " +
                        "elseif redis.call('HINCRBY', KEYS[1], ARGV[1], -1) == 0 then  " +
                        "    return redis.call('del', KEYS[1])  " +
                        "else  " +
                        "    return 0  " +
                        "end";
        log.info("unlock()   key:{}, value:{}", key, value);
        Object flag = redisTemplate.execute(new DefaultRedisScript<>(script, Long.class), Collections.singletonList(key), value);
        /**
         * 即返回nil
         */
        if (null == flag) {
            throw new RuntimeException("this lock doesn't exists!");
        }
    }

    @Override
    public void lockInterruptibly() throws InterruptedException {

    }

    @Override
    public Condition newCondition() {
        return null;
    }
}
```

DistributedLockFactory：提供RedisDistributedLock的工厂类。

RedisDistributedLock锁通过redis的hash实现，field为UUID+ThreadId，每次创建RedisDistributedLock的话field都不同，那同一个线程就无法实现可重入性了，这里通过DistributedLockFactory在容器初始化时生成全局的唯一UUID，这样同一个线程对应的field就不变了。

```java
import cn.hutool.core.util.IdUtil;
import cn.hutool.core.util.StrUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Component;
import java.util.concurrent.locks.Lock;
import static com.dongguo.redis.utils.CacheKeyUtil.CACHE_INVENTORY_LOCK_KEY;
import static com.dongguo.redis.utils.CommonConst.REDIS;

/**
 * 创建redis分布式锁的工厂类
 */
@Component
public class DistributedLockFactory {
    @Autowired
    private RedisTemplate redisTemplate;
    private String uuid;

    public DistributedLockFactory() {
        //每个实例对应一个全局唯一uuid
        this.uuid = IdUtil.fastUUID();
    }

    public Lock getDistributedLock(String lockType) {
        if (StrUtil.isBlank(lockType)) {
            return null;
        }
        if (REDIS.equalsIgnoreCase(lockType)) {
            return new RedisDistributedLock(redisTemplate, CACHE_INVENTORY_LOCK_KEY, uuid);
        }
        return null;
    }
}
```

InventoryService：测试RedisDistributedLock锁是否有效

```java
import cn.hutool.core.lang.UUID;
import cn.hutool.core.util.IdUtil;
import com.dongguo.redis.myredis.DistributedLockFactory;
import jakarta.annotation.Resource;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.script.DefaultRedisScript;
import org.springframework.stereotype.Service;
import java.util.Collections;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Lock;
import static com.dongguo.redis.utils.CacheKeyUtil.CACHE_INVENTORY_KEY;
import static com.dongguo.redis.utils.CacheKeyUtil.CACHE_INVENTORY_LOCK_KEY;
import static com.dongguo.redis.utils.CommonConst.REDIS;
/**
 * @Author: Administrator
 * @Date: 2024-03-12
 */
@Service
@Slf4j
public class InventoryService {
    @Value(value = "${server.port}")
    private Integer port;
    @Resource
    private RedisTemplate redisTemplate;

    @Resource
    private DistributedLockFactory distributedLockFactory;

    /**
     * lua脚本实现分布式锁可重入性
     * @return
     */
    public String saleTicketV7() {
        String key = CACHE_INVENTORY_KEY;
        Lock redisLock = distributedLockFactory.getDistributedLock(REDIS);
        redisLock.lock();
        try {
            //查询库存信息
            Object obj = redisTemplate.opsForValue().get(key);
            if (null != obj) {
                int inventory = (Integer) obj;
                //判断库存是否足够
                if (inventory > 0) {
                    //扣减库存，减1
                    inventory -= 1;
                    redisTemplate.opsForValue().set(key, inventory);
                    log.info("端口号：{} 售出一张票，还剩下{}张票", port, inventory);
                    return "端口号：" + port + " 售出一张票，还剩下" + inventory + "张票";
                }
            }
        } finally {
            redisLock.unlock();
        }
        return "端口号：" + port + " 售票失败，库存为0";
    }
}
```

InventoryController：

```java
    @Operation(
            summary = "saleTicket",
            description = "售票"
    )
    @GetMapping("/saleTicket")
    public String saleTicket() {
        return inventoryService.saleTicketV7();
    }
```

通过Jmeter压测后：

8081：

![image-20240314103111647](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403141031324.png)

8082：

![image-20240314103205359](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403141032690.png)

#### 4.测试可重入性

InventoryService：两次加锁，两次解锁

```java
import cn.hutool.core.lang.UUID;
import cn.hutool.core.util.IdUtil;
import com.dongguo.redis.myredis.DistributedLockFactory;
import jakarta.annotation.Resource;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.script.DefaultRedisScript;
import org.springframework.stereotype.Service;
import java.util.Collections;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Lock;
import static com.dongguo.redis.utils.CacheKeyUtil.CACHE_INVENTORY_KEY;
import static com.dongguo.redis.utils.CacheKeyUtil.CACHE_INVENTORY_LOCK_KEY;

/**
 * @Author: Administrator
 * @Date: 2024-03-12
 */
@Service
@Slf4j
public class InventoryService {
    @Value(value = "${server.port}")
    private Integer port;
    @Resource
    private RedisTemplate redisTemplate;

    @Resource
    private DistributedLockFactory distributedLockFactory;

    /**
     * lua脚本实现分布式锁可重入性
     * @return
     */
    public String saleTicketV7() {
        String key = CACHE_INVENTORY_KEY;
        Lock redisLock = distributedLockFactory.getDistributedLock(REDIS);
        redisLock.lock();
        try {

            //查询库存信息
            Object obj = redisTemplate.opsForValue().get(key);
            if (null != obj) {
                int inventory = (Integer) obj;
                //判断库存是否足够
                if (inventory > 0) {
                    //扣减库存，减1
                    inventory -= 1;
                    redisTemplate.opsForValue().set(key, inventory);
                    reEntryTest();

                    log.info("端口号：{} 售出一张票，还剩下{}张票", port, inventory);
                    return "端口号：" + port + " 售出一张票，还剩下" + inventory + "张票";
                }
            }
        } finally {
            redisLock.unlock();
        }
        return "端口号：" + port + " 售票失败，库存为0";
    }

    private void reEntryTest() {
        Lock redisLock = distributedLockFactory.getDistributedLock(REDIS);
        redisLock.lock();
        try {
            log.info("==============测试可重入性===============");
        } finally {
            redisLock.unlock();
        }
    }
} 
```

测试可重入性成功。

![image-20240314103951517](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403141039353.png)

### 问题:6：在问题4中提到过，业务执行时间超过过期时间的问题

虽然说可以预估业务执行的时间设置富裕的过期时间，但是网络拥堵或者服务器过载等情况还是可能导致业务执行的时间超过过期时间的。

确保过期时间大于业务执行时间：如何实现过期时间自动续期

```lua
if redis.call('HEXISTS', KEYS[1], ARGV[1]) == 1 then  
    return redis.call('expire', KEYS[1], ARGV[2])  
else  
    return 0  
end
```

RedisDistributedLock：在加锁时，开启一个定时任务，每隔设置过期时间的1/3，执行一次续期

```java
    /**
     * 真正调用的加锁方法
     *
     * @param time the maximum time to wait for the lock
     * @param unit the time unit of the {@code time} argument
     * @return
     */
    @Override
    public boolean tryLock(long time, TimeUnit unit) {
        //将过期时间转换为秒
        this.expire = unit.toSeconds(time);
        String script =
                "if redis.call('exists', KEYS[1]) == 0 or redis.call('hexists', KEYS[1], ARGV[1]) == 1 then  " +
                        "    redis.call('hincrby', KEYS[1], ARGV[1], 1)  " +
                        "    redis.call('expire', KEYS[1], ARGV[2])  " +
                        "    return 1  " +
                        "else  " +
                        "    return 0  " +
                        "end";
        while (!(Boolean) redisTemplate.execute(new DefaultRedisScript<>(script, Boolean.class), Collections.singletonList(key), value, expire)) {
            try {
                TimeUnit.MILLISECONDS.sleep(10);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
        log.info("lock()   key:{}, value:{}", key, value);

        //新建一个后台扫描程序，监测key的过期时间，每过expire/3,实现续期expire
        reExpire();
        return true;
    }

    private void reExpire() {
        String script =
                "if redis.call('HEXISTS', KEYS[1], ARGV[1]) == 1 then  " +
                        "    return redis.call('expire', KEYS[1], ARGV[2])  " +
                        "else  " +
                        "    return 0  " +
                        "end";
        new Timer().schedule(new TimerTask() {
            @Override
            public void run() {
                if ((Boolean) redisTemplate.execute(new DefaultRedisScript<>(script, Boolean.class), Collections.singletonList(key), value, expire)) {
                    log.info("自动续期  key:{}, value:{}", key, value);
                    reExpire();
                }
                //key不存在，退出定时任务
                cancel();
            }
            //延迟时间 毫秒
        }, (this.expire * 1000) / 3);
    }
```

InventoryService：执行业务代码时，睡眠100秒，测试自动续期功能

```java
    /**
     * 实现自动续期
     * @return
     */
    public String saleTicketV8() {
        String key = CACHE_INVENTORY_KEY;
        Lock redisLock = distributedLockFactory.getDistributedLock(REDIS);
        redisLock.lock();
        try {
            //查询库存信息
            Object obj = redisTemplate.opsForValue().get(key);
            if (null != obj) {
                int inventory = (Integer) obj;
                //判断库存是否足够
                if (inventory > 0) {
                    //扣减库存，减1
                    inventory -= 1;
                    redisTemplate.opsForValue().set(key, inventory);
                    //业务执行时间超过超时时间
                    try {
                        TimeUnit.SECONDS.sleep(100);
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                    log.info("端口号：{} 售出一张票，还剩下{}张票", port, inventory);
                    return "端口号：" + port + " 售出一张票，还剩下" + inventory + "张票";
                }
            }
        } finally {
            redisLock.unlock();
        }
        return "端口号：" + port + " 售票失败，库存为0";
    }
```

InventoryController：

```java
    @Operation(
            summary = "saleTicket",
            description = "售票"
    )
    @GetMapping("/saleTicket")
    public String saleTicket() {
        return inventoryService.saleTicketV8();
    }
```



