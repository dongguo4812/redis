

单机锁：同一个JVM虚拟机内，使用synchronized或者Lock接口

分布式锁：多个不同JVM虚拟机，使用分布式锁

# 分布式锁需要具备的条件

- 独占性：      OnlyOne，任何时刻只能有且仅有一个线程持有

- 高可用：     若redis集群环境下，不能因为某一个节点挂了而出现获取锁和释放锁失败的情况。高并发场景，性能依然可以。

- 防死锁：     杜绝死锁，必须有超时控制机制或者解锁操作。

- 不乱抢：     防止张冠李戴，不能删除别人的锁，只能释放自己加的锁

- 重入性：     同一个节点的同一个线程如果获得锁之后，也可以再次获取这个锁。

# 分布式锁

## 1.SETNX key value

当key不存在的时候，创建key。

注：SETNX key value 和 EXPIRE key seconds两个操作并不是原子性的，这意味着在SETNX和EXPIRE 之间系统崩溃，可能导致key永久有效。

```shell
127.0.0.1:6379> SETNX k1 v1
(integer) 1
127.0.0.1:6379> EXPIRE k1 10
(integer) 1
```

为了确保这两个操作的原子性，可以使用SET key value [NX | XX]  [EX seconds | PX milliseconds] 

## 2.SET key value [NX | XX]  [EX seconds | PX milliseconds] 

EX: key在多少秒后过期

PX: key在多少毫秒后过期

NX：当key不存在的时候，创建key，等同于SETNX

XX: 当key存在的时候，覆盖key

# 单机锁实战

需求：实现买票扣减库存的业务。

## 1.创建分布式锁项目redis_distributed_lock，修改pom

```xml
	<dependencies>
		<dependency>
			<groupId>com.dongguo</groupId>
			<artifactId>redis_core</artifactId>
			<version>0.0.1-SNAPSHOT</version>
		</dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <!--导入SpringBoot集成Open API 3.0（Swagger3.0）的坐标 -->
        <dependency>
            <groupId>org.springdoc</groupId>
            <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
        </dependency>
		<dependency>
			<groupId>org.projectlombok</groupId>
			<artifactId>lombok</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>log4j</groupId>
			<artifactId>log4j</artifactId>
		</dependency>
	</dependencies>
```

## 2.配置application.yml

```yaml
server:
  port: 8081
spring:
  application:
    name: redis_distributed_lock
  # ========================redis相关配置=====================
  data:
    redis:
      host: 192.168.122.131
      port: 6379
      password: root
# ========================swagger=====================
springdoc:
  swagger-ui:
    enabled: true
    path: /swagger-ui.html
```

## 3.代码实现

InventoryService：使用synchronized解决库存超卖问题。

```java
import jakarta.annotation.Resource;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;
import static com.dongguo.redis.utils.CacheKeyUtil.CACHE_INVENTORY_KEY;

/**
 * @Author: Administrator
 * @Date: 2024-03-12
 */
@Service
@Slf4j
public class InventoryService {
    @Value(value = "${server.port}")
    private Integer port;
    @Resource
    private RedisTemplate redisTemplate;

    public void initInventory() {
        //初始化库存100
        redisTemplate.opsForValue().set(CACHE_INVENTORY_KEY, 100);
    }

    public synchronized String saleTicket() {
        String message;
        Object obj = redisTemplate.opsForValue().get(CACHE_INVENTORY_KEY);
        if (null != obj) {
            Integer inventory = (Integer) obj;
            if (inventory > 0) {
                inventory -= 1;
                redisTemplate.opsForValue().set(CACHE_INVENTORY_KEY, inventory);
                log.info("端口号：{} 售出一张票，还剩下{}张票", port, inventory);
                message = "端口号：" + port + " 售出一张票，还剩下" + inventory + "张票";
                return message;
            }
        }
        return "端口号：" + port + " 售票失败，库存为0";
    }
}
```

InventoryController：

```java
import com.dongguo.redis.service.InventoryService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.annotation.Resource;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * @Author: Administrator
 * @Date: 2024-03-12
 */
@RestController
@RequestMapping("/inventory")
@Tag(
        name = "InventoryController",
        description = "库存控制器接口")
public class InventoryController {

    @Resource
    private InventoryService inventoryService;

    @Operation(
            summary = "initInventory",
            description = "初始化库存"
    )
    @PostMapping("/initInventory")
    public void initInventory() {
        inventoryService.initInventory();
    }

    @Operation(
            summary = "saleTicket",
            description = "售票"
    )
    @PostMapping("/saleTicket")
    public String saleTicket() {
        return inventoryService.saleTicket();
    }
}
```

# 分布式锁实战

## 1.初始化版本运行两个实例







Nginx配置负载均衡
