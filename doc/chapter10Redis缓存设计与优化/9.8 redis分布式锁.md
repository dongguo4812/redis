

单机锁：同一个JVM虚拟机内，使用synchronized或者Lock接口

分布式锁：多个不同JVM虚拟机，使用分布式锁

# 分布式锁需要具备的条件

- 独占性：      OnlyOne，任何时刻只能有且仅有一个线程持有

- 高可用：     若redis集群环境下，不能因为某一个节点挂了而出现获取锁和释放锁失败的情况。高并发场景，性能依然可以。

- 防死锁：     杜绝死锁，必须有超时控制机制或者解锁操作。

- 不乱抢：     防止张冠李戴，不能删除别人的锁，只能释放自己加的锁

- 重入性：     同一个节点的同一个线程如果获得锁之后，也可以再次获取这个锁。

# 分布式锁

## 1.SETNX key value

当key不存在的时候，创建key。

注：SETNX key value 和 EXPIRE key seconds两个操作并不是原子性的，这意味着在SETNX和EXPIRE 之间系统崩溃，可能导致key永久有效。

```shell
127.0.0.1:6379> SETNX k1 v1
(integer) 1
127.0.0.1:6379> EXPIRE k1 10
(integer) 1
```

为了确保这两个操作的原子性，可以使用SET key value [NX | XX]  [EX seconds | PX milliseconds] 

## 2.SET key value [NX | XX]  [EX seconds | PX milliseconds] 

EX: key在多少秒后过期

PX: key在多少毫秒后过期

NX：当key不存在的时候，创建key，等同于SETNX

XX: 当key存在的时候，覆盖key

# Redis实现分布式锁实战

需求：多个服务间保证同一时刻同一时间段内同一用户只能有一个请求（防止关键业务出现并发操作）

1.创建分布式锁项目redis_distributed_lock