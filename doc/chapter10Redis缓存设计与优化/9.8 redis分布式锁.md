

单机锁：同一个JVM虚拟机内，使用synchronized或者Lock接口

分布式锁：多个不同JVM虚拟机，使用分布式锁

# 分布式锁需要具备的条件

- 独占性：      OnlyOne，任何时刻只能有且仅有一个线程持有

- 高可用：     若redis集群环境下，不能因为某一个节点挂了而出现获取锁和释放锁失败的情况。高并发场景，性能依然可以。

- 防死锁：     杜绝死锁，必须有超时控制机制或者解锁操作。

- 不乱抢：     防止张冠李戴，不能删除别人的锁，只能释放自己加的锁

- 重入性：     同一个节点的同一个线程如果获得锁之后，也可以再次获取这个锁。

# 分布式锁

## 1.SETNX key value

当key不存在的时候，创建key。

注：SETNX key value 和 EXPIRE key seconds两个操作并不是原子性的，这意味着在SETNX和EXPIRE 之间系统崩溃，可能导致key永久有效。

```shell
127.0.0.1:6379> SETNX k1 v1
(integer) 1
127.0.0.1:6379> EXPIRE k1 10
(integer) 1
```

为了确保这两个操作的原子性，可以使用SET key value [NX | XX]  [EX seconds | PX milliseconds] 

## 2.SET key value [NX | XX]  [EX seconds | PX milliseconds] 

EX: key在多少秒后过期

PX: key在多少毫秒后过期

NX：当key不存在的时候，创建key，等同于SETNX

XX: 当key存在的时候，覆盖key

# 单机锁实战

需求：实现买票扣减库存的业务。

## 1.创建分布式锁项目redis_distributed_lock，修改pom

```xml
	<dependencies>
		<dependency>
			<groupId>com.dongguo</groupId>
			<artifactId>redis_core</artifactId>
			<version>0.0.1-SNAPSHOT</version>
		</dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <!--导入SpringBoot集成Open API 3.0（Swagger3.0）的坐标 -->
        <dependency>
            <groupId>org.springdoc</groupId>
            <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
        </dependency>
		<dependency>
			<groupId>org.projectlombok</groupId>
			<artifactId>lombok</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>log4j</groupId>
			<artifactId>log4j</artifactId>
		</dependency>
	</dependencies>
```

## 2.配置application.yml

```yaml
server:
  port: 8081
spring:
  application:
    name: redis_distributed_lock
  # ========================redis相关配置=====================
  data:
    redis:
      host: 192.168.122.131
      port: 6379
      password: root
# ========================swagger=====================
springdoc:
  swagger-ui:
    enabled: true
    path: /swagger-ui.html
```

## 3.代码实现

InventoryService：使用synchronized解决库存超卖问题。

```java
import jakarta.annotation.Resource;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;
import static com.dongguo.redis.utils.CacheKeyUtil.CACHE_INVENTORY_KEY;

/**
 * @Author: Administrator
 * @Date: 2024-03-12
 */
@Service
@Slf4j
public class InventoryService {
    @Value(value = "${server.port}")
    private Integer port;
    @Resource
    private RedisTemplate redisTemplate;

    public void initInventory() {
        //初始化库存100
        redisTemplate.opsForValue().set(CACHE_INVENTORY_KEY, 100);
    }

    public synchronized String saleTicket() {

        //查询库存信息
        Object obj = redisTemplate.opsForValue().get(CACHE_INVENTORY_KEY);
        if (null != obj) {
            int inventory = (Integer) obj;
            //判断库存是否足够
            if (inventory > 0) {
                //扣减库存，减1
                inventory -= 1;
                redisTemplate.opsForValue().set(CACHE_INVENTORY_KEY, inventory);
                log.info("端口号：{} 售出一张票，还剩下{}张票", port, inventory);
                return "端口号：" + port + " 售出一张票，还剩下" + inventory + "张票";
            }
        }
        return "端口号：" + port + " 售票失败，库存为0";
    }
}
```

InventoryController：

```java
import com.dongguo.redis.service.InventoryService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.annotation.Resource;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * @Author: Administrator
 * @Date: 2024-03-12
 */
@RestController
@RequestMapping("/inventory")
@Tag(
        name = "InventoryController",
        description = "库存控制器接口")
public class InventoryController {

    @Resource
    private InventoryService inventoryService;

    @Operation(
            summary = "initInventory",
            description = "初始化库存"
    )
    @PostMapping("/initInventory")
    public void initInventory() {
        inventoryService.initInventory();
    }

    @Operation(
            summary = "saleTicket",
            description = "售票"
    )
    @PostMapping("/saleTicket")
    public String saleTicket() {
        return inventoryService.saleTicket();
    }
}
```

如果是单体项目，使用synchronized是可以解决超卖问题的，但是如果是分布式项目，还是会出现超卖问题，那就需要使用分布式锁了。

# 分布式锁实战

架构：使用nginx实现反向代理、负载均衡，请求负载均衡落在两个实例上。



![image-20240312190952214](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403121910237.png)

## Nginx配置负载均衡

### windows启动nginx

nginx这里使用win版的，路径为E:\software\nginx\nginx-1.24.0-distributed-lock

启动nginx: `start nginx.exe`

查看是否能正常访问：localhost:80，

![image-20240312224805659](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403122248832.png)

访问不成功，请排查是否80端口冲突：`netstat -aon|findstr 80`

通过对应PID，查看冲突的应用是哪个，`tasklist|findstr PID`

4关闭nginx：`nginx -s stop`

重启nginx：	`nginx -s reload`

每次启动都是开启一个新的进程，查看开启了多少个nginx：`tasklist |findstr "nginx.exe"`

 强制杀死所有nginx进程：`taskkill /f /t /im "nginx.exe"`

#### 1.配置文件nginx.conf配置反向代理和负载均衡配置

配置反向代理和负载均衡，轮询访问两个实例。

```shell
    #负载均衡
   	upstream mynginx {
           server 127.0.0.1:8081 max_fails=5 fail_timeout=10s weight=1;
           server 127.0.0.1:8082 max_fails=5 fail_timeout=10s weight=1;
   	}
    server {
        listen       80;
        server_name  localhost;

        location / {
           # root   html;
			proxy_pass http://mynginx;
            index  index.html index.htm;
        }


        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
    }
```

#### 2.启动nginx

```shell
start nginx.exe
```

#### 启动两个实例8081/8082

只有一个项目怎么启动多个实例呢？

#### 1.设置项目允许运行多个实例

右键RedisDistributedLockApplication，点击Edit Configration

![image-20240312204426912](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403122044321.png)

也可以在工具栏中找到该项目点击Edit Configration*

![image-20240312204444490](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403122044578.png)

点击Modify options，选中allow multiple instances，项目允许运行多个实例

![image-20240312204452220](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403122044374.png)

#### 2.启动两个实例

然后继续选中addVM options，填入-Dserver.port=8081，点击运行就启动一个新的实例，填入-Dserver.port=8082，点击运行再启动一个新的实例了

![image-20240312204608263](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403122046201.png)

这样就启动了两个代码相同，端口不同的实例

![image-20240312204717627](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403122047452.png)

访问接口：http://localhost/inventory/saleTicket，多次请求。

8082实例：

![image-20240313071241154](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403130713438.png)

8081实例：

![image-20240313071258501](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403130713914.png)

### **linux启动nginx**

进入到nginx目录/opt/nginx-1.24.0/conf，相同的nginx.conf配置

启动nginx：`sbin/nginx -c conf/nginx.conf`

关闭nginx：`sbin/nginx -s stop`

访问http://192.168.122.131/inventory/saleTicket

![image-20240313081824315](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403130818536.png)

### 
