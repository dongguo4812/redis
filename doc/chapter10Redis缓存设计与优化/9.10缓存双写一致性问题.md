缓存双写一致性之更新策略



![image-20240315112652628](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403151127175.png)

## 写数据库后写缓存的策略

同步直写策略：

写数据库后就同步写reids缓存，缓存和数据库中的数据一致，对于一致性要求高的数据，使用同步直写策略。

异步缓写策略：

写数据库后异步写redis缓存，异常情况出现，借助消息队列实现重试机制，对于一致性要求不高的数据，比如仓库、物流系统，



异步实现可以基于MQ或者Canal来实现：

1）基于MQ的异步通知：



![image-20240315134704214](F:\note\image\image-20240315134704214.png)

解读：

- 商品服务完成对数据的修改后，只需要发送一条消息到MQ中。
- 缓存服务监听MQ消息，然后完成对缓存的更新

依然有少量的代码侵入。



2）基于Canal的通知

![image-20240315134723752](F:\note\image\image-20240315134723752.png)

解读：

- 商品服务完成商品修改后，业务直接结束，没有任何代码侵入
- Canal监听MySQL变化，当发现变化后，立即通知缓存服务
- 缓存服务接收到canal通知，更新缓存

代码零侵入



## 数据库和缓存一致性的更新策略

以mysql的数据为准，对缓存操作尽最大努力即可，保证数据库和缓存的最终一致性。

### 先更新数据库，再更新缓存

场景1：更新mysql的某商品的库存，当前商品的库存是100，先更新mysql修改为99，然后更新redis。mysql更新成功，更新redis时失败了，导致mysql中商品库存是99，而redis的缓存还是100.

数据库和缓存数据不一致，读到了redis脏数据。

场景2：A、B两个线程发起更新请求。

正常逻辑：

1、 A update mysql 99

2、 A update reids 99

3、B update mysql 80

4、B update redis 80

异常逻辑：

1、 A update mysql 99

2、B update mysql 80

3、B update redis80

4、A update reids 99

缓存数据被覆盖，导致数据库和缓存数据不一致

单线程的情况下可以考虑这个策略。

### 先更新缓存，再更新数据库

这种方式不太推荐，因为在业务上一般是以数据库数据为准，数据库时做兜底的，所以是不会先更新缓存的。

如果业务上以缓存为主，可以考虑先更新缓存，再更新数据库。

异常逻辑：

1、 A update reids 99

2、B update redis 80

3、B update mysql 80

4、A update mysql 99

数据被覆盖，导致数据库和缓存数据不一致

### 先删除缓存，再更新数据库

1.A线程先删除redis的数据（网络延迟中）

2.B线程读取缓存数据，缓存中没有，读取数据库，将数据库数据回写到redis中

3.A更新mysql。

redis中缓存的还是旧数据，导致数据库和缓存数据不一致



解决方案：延迟双删

删除缓存后，延迟一段时间再次进行删除。那么该延迟多久再进行删除呢？

1.==延迟的时间要大于回写缓存执行的时间。==在实际环境中进行多次测试和调整，以找到最适合当前系统的值。这种方式会导致吞吐量降低。我们可以使用异步线程进行延迟删除。 但是还是存在可能由于网络延迟的关系导致回写缓存时间超过了延迟的时间。

回写缓存的时间不好预估，延迟双删的等待时间就不好设置。

2.我们也可以启动一个后台线程，例如看门口 watch dog，实时调整延迟的时间。

### 先更新数据库，再删除缓存

1.线程A更新数据库（网络延迟）

2.线程B读取缓存中的旧值

3.线程A删除缓存

在更新数据库和删除缓存的间隙存在数据库和缓存不一致。



如果缓存删除失败呢？ 订阅binlog日志+消息队列重试

![在这里插入图片描述](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403151525351.png)

流程如下图所示:

(1)更新数据库数据

(2)数据库会将操作信息写入binlog日志当中

(3)订阅程序提取出所需要的数据以及key

(4)另起一段非业务代码,获得该信息

(5)尝试删除缓存操作,发现删除失败

(6)将这些信息发送至消息队列

(7)重新从消息队列中获得该数据,重试操作。

使用消息队列实现重试机制，如果重试超过一定次数后，那就要发送错误信息，通知运维人员了。





### 最终选择方案

通常使用先更新数据库，再删除缓存的方案。

不过这种情况很难做到实时一致性，只能保证最终一致性。

# Canal服务端

**Canal [kə'næl]**，译意为水道/管道/沟渠，canal是阿里巴巴旗下的一款开源项目，基于Java开发。基于数据库增量日志解析，提供增量数据订阅&消费。GitHub的地址：https://github.com/alibaba/canal

历史背景是早期阿里巴巴因为杭州和美国双机房部署,存在跨机房数据同步的业务需求,实现方式主要是基于业务trigger (触发器)获取增量变更。从2010年开始，阿里巴巴逐步尝试采用解析数据库日志获取增量变更进行同步，由此衍生出了canal项目；

基于日志增量订阅和消费的业务包括

- 数据库镜像

- 数据库实时备份

- 索引构建和实时维护(拆分异构索引、倒排索引等)

- 业务 cache 刷新

- 带业务逻辑的增量数据处理



Canal是基于mysql的主从同步来实现的，MySQL主从同步的原理如下：



![image-20240315154920124](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403151549276.png)

- 当master主服务器上的数据发生改变时,则将其改变写入二进制事件日志( binary log）文件中;
- salve从服务器会在一定时间间隔内对master主服务器上的二进制日志进行探测,探测其是否发生过改变,如果探测到master主服务器的二进制事件日志发生了改变,则开始一个I/O Thread请求master二进制事件日志;
- 同时master主服务器为每个I/O Thread启动一个dump Thread,用于向其发送二进制事件日志;
- slave从服务器将接收到的二进制事件日志保存至自己本地的中继日志文件(relay log)中;
- salve从服务器将启动SQL Thread从中继日志中读取二进制日志,在本地重放,使得其数据和主服务器保持一致;

而Canal就是把自己伪装成MySQL的一个slave节点，从而监听master的binary log变化。再把得到的变化信息通知给Canal的客户端，进而完成对其它数据库的同步。

![image-20240315154945973](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403151549025.png)

## MySQL配置

Canal是基于MySQL的主从同步功能，因此必须先开启MySQL的主从功能才可以。这里我是用的是mysql版的MySQL。

### 1.查看MySQL版本

查看到MySQL版本是8.0.27

![image-20240315160829253](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403151608699.png)

### 2.查看当前MySQL服务器的二进制日志



![image-20240315161048331](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403151610335.png)

### 3.查看MySQL服务器是否启用了binlog二进制日志

![image-20240315161440893](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403151614007.png)

如果没有开启，开启MySQL的binlog写入功能，找到mysql的安装目录：E:\software\mysql\mysql-8.0.27-winx64下的my.ini.

在修改之前最好进行备份，在mysqld下添加

```shell
log-bin=mysql-bin #开启 binlog
binlog-format=ROW #选择 ROW 模式
server_id=1    #配置MySQL replaction需要定义，不要和canal的 slaveId重复
```



![image-20240315162010723](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403151620882.png)

binlog写入模式：

ROW模式 除了记录sql语句之外，还会记录每个字段的变化情况，能够清楚的记录每行数据的变化历史，但会占用较多的空间。

STATEMENT模式只记录了sql语句，但是没有记录上下文信息，在进行数据恢复的时候可能会导致数据的丢失情况；

MIX模式比较灵活的记录，理论上说当遇到了表结构变更的时候，就会记录为statement模式。当遇到了数据更新或者删除情况下就会变为row模式；

### 4.修改配置重启MySQL，再次查看否启用了binlog二进制日志

### 5.设置用户权限，授权canal连接MySQL的账号

添加一个canal账户。允许用户连接到主服务器以进行复制操作的权限，当然你也可以使用GRANT ALL ON *.* TO 'canal'@'%';*.*授予所有权限。

```sql
drop user if exists 'canal'@'%';
create user canal@'%' IDENTIFIED by 'canal';
GRANT SELECT, REPLICATION SLAVE, REPLICATION CLIENT,SUPER ON *.* TO 'canal'@'%';
FLUSH PRIVILEGES;
```

查看mysql库的user用户表

![image-20240315163526698](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403151635838.png)

## 安装Canal

Canal只有linux版本的，所以要在centOS中安装canal，要先安装好Java环境。

如果防火墙开启记得放开3306端口。

```shell
[root@redis bin]# firewall-cmd --permanent --add-port=3306/tcp
success
[root@redis bin]# firewall-cmd --reload
success
```

### 1.下载

https://github.com/alibaba/canal/releases/tag/canal-1.1.7

**此为部署安装包，没有管理界面，可满足基础使用。**

![image-20240315164641497](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403151646936.png)

### 2解压

创建canal文件夹，解压到canal文件夹中

```shell
[root@redis opt]# tar -zxvf canal.deployer-1.1.7.tar.gz -C /opt/canal
```

### 3配置instance.properties

/opt/canal/conf/example目录下

指定mysql主机master的ip地址

```
# position info
canal.instance.master.address=192.168.1.3:3306
```

指定mysql新建的canal账户

```
# username/password
canal.instance.dbUsername=canal
canal.instance.dbPassword=canal
```

### 4.启动

/opt/canal/bin目录下

```shell
[root@redis opt]# cd canal/bin/
[root@redis bin]# ll
总用量 16
-rwxr-xr-x. 1 root root  226 11月 16 2022 restart.sh
-rwxr-xr-x. 1 root root 1244 11月 16 2022 startup.bat
-rwxr-xr-x. 1 root root 3805 10月  8 14:38 startup.sh
-rwxr-xr-x. 1 root root 1356 11月 16 2022 stop.sh
[root@redis bin]# ./startup.sh
```

### 5.查看

查看server日志 logs/canal 下  

cat canal.log

```shell
2024-03-15 19:15:48.014 [main] INFO  com.alibaba.otter.canal.deployer.CanalLauncher - ## set default uncaught exception handler
2024-03-15 19:15:48.019 [main] INFO  com.alibaba.otter.canal.deployer.CanalLauncher - ## load canal configurations
2024-03-15 19:15:48.062 [main] INFO  com.alibaba.otter.canal.deployer.CanalStarter - ## start the canal server.
2024-03-15 19:15:48.127 [main] INFO  com.alibaba.otter.canal.deployer.CanalController - ## start the canal server[127.0.0.1(127.0.0.1):11111]
2024-03-15 19:15:50.471 [main] INFO  com.alibaba.otter.canal.deployer.CanalStarter - ## the canal server is running now ......
```

查看logs/example  

cat example.log

```shell
2024-03-15 19:15:50.424 [main] INFO  c.a.otter.canal.instance.core.AbstractCanalInstance - start successful....
2024-03-15 19:15:50.562 [destination = example , address = /192.168.1.3:3306 , EventParser] WARN  c.a.o.c.p.inbound.mysql.rds.RdsBinlogEventParserProxy - ---> begin to find start position, it will be long time for reset or first position
2024-03-15 19:15:50.562 [destination = example , address = /192.168.1.3:3306 , EventParser] WARN  c.a.o.c.p.inbound.mysql.rds.RdsBinlogEventParserProxy - prepare to find start position just show master status
2024-03-15 19:15:52.421 [destination = example , address = /192.168.1.3:3306 , EventParser] WARN  c.a.o.c.p.inbound.mysql.rds.RdsBinlogEventParserProxy - ---> find start position successfully, EntryPosition[included=false,journalName=mysql-bin.000085,position=3711,serverId=1,gtid=,timestamp=1710214183000] cost : 1812ms , the next step is binlog dump
```

6.如果防火墙开启，需要开放1111端口

```shell
[root@redis bin]# firewall-cmd --permanent --add-port=11111/tcp
success
[root@redis bin]# firewall-cmd --reload
success
```



# Redis与Mysql数据双写一致性实战

Canal提供了各种语言的客户端，当Canal监听到binlog变化时，会通知Canal的客户端。

![image-20240315171737746](F:\note\image\image-20240315171737746.png)

我们可以利用Canal提供的Java客户端，监听Canal通知消息。当收到变化的消息时，完成对缓存的更新。





## 1.创建需要监控的表

```sql
CREATE TABLE `t_user` (
  `id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,
  `username` VARCHAR(50) NOT NULL DEFAULT '' COMMENT '用户名',
  `password` VARCHAR(50) NOT NULL DEFAULT '' COMMENT '密码',
  `sex` TINYINT(4) NOT NULL DEFAULT '0' COMMENT '性别 0=女 1=男 ',
  `deleted` TINYINT(4) UNSIGNED NOT NULL DEFAULT '0' COMMENT '删除标志，默认0不删除，1删除',
  `update_time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  `create_time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  PRIMARY KEY (`id`)
) ENGINE=INNODB AUTO_INCREMENT=1001 DEFAULT CHARSET=utf8 COMMENT='用户表';
 
SELECT * FROM t_user;
```

## 2.创建canal项目

redis_canal

## 3.pom引入canal依赖

```xml
    <dependencies>
        <dependency>
            <groupId>com.dongguo</groupId>
            <artifactId>redis_core</artifactId>
            <version>0.0.1-SNAPSHOT</version>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>com.alibaba.otter</groupId>
            <artifactId>canal.client</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
        </dependency>
        <!--SpringBoot集成druid连接池-->
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>druid-spring-boot-starter</artifactId>
        </dependency>
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>druid</artifactId>
        </dependency>
        <!--Mysql数据库驱动-->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
        </dependency>
    </dependencies>
```

## 4.配置application.yml

```yaml
server:
  port: 8088
spring:
  application:
    name: redis_canal
  # ========================alibaba.druid相关配置=====================
  datasource:
    type: com.alibaba.druid.pool.DruidDataSource
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/redis?useUnicode=true&characterEncoding=utf-8&useSSL=false
    username: root
    password: root
    druid:
      test-while-ide: false
```





```java
public static void main(String args[]) {
    // 创建链接
    CanalConnector connector = CanalConnectors.newSingleConnector(new InetSocketAddress(AddressUtils.getHostIp(),
                                                                                        11111), "example", "", "");
    int batchSize = 1000;
    int emptyCount = 0;
    try {
        connector.connect();
        connector.subscribe(".*\\..*");
        connector.rollback();
        int totalEmptyCount = 120;
        while (emptyCount < totalEmptyCount) {
            Message message = connector.getWithoutAck(batchSize); // 获取指定数量的数据
            long batchId = message.getId();
            int size = message.getEntries().size();
            if (batchId == -1 || size == 0) {
                emptyCount++;
                System.out.println("empty count : " + emptyCount);
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                }
            } else {
                emptyCount = 0;
                // System.out.printf("message[batchId=%s,size=%s] \n", batchId, size);
                printEntry(message.getEntries());
            }

            connector.ack(batchId); // 提交确认
            // connector.rollback(batchId); // 处理失败, 回滚数据
        }

        System.out.println("empty too many times, exit");
    } finally {
        connector.disconnect();
    }
}

private static void printEntry(List<Entry> entrys) {
    for (Entry entry : entrys) {
        if (entry.getEntryType() == EntryType.TRANSACTIONBEGIN || entry.getEntryType() == EntryType.TRANSACTIONEND) {
            continue;
        }

        RowChange rowChage = null;
        try {
            rowChage = RowChange.parseFrom(entry.getStoreValue());
        } catch (Exception e) {
            throw new RuntimeException("ERROR ## parser of eromanga-event has an error , data:" + entry.toString(),
                                       e);
        }

        EventType eventType = rowChage.getEventType();
        System.out.println(String.format("================&gt; binlog[%s:%s] , name[%s,%s] , eventType : %s",
                                         entry.getHeader().getLogfileName(), entry.getHeader().getLogfileOffset(),
                                         entry.getHeader().getSchemaName(), entry.getHeader().getTableName(),
                                         eventType));

        for (RowData rowData : rowChage.getRowDatasList()) {
            if (eventType == EventType.DELETE) {
                printColumn(rowData.getBeforeColumnsList());
            } else if (eventType == EventType.INSERT) {
                printColumn(rowData.getAfterColumnsList());
            } else {
                System.out.println("-------&gt; before");
                printColumn(rowData.getBeforeColumnsList());
                System.out.println("-------&gt; after");
                printColumn(rowData.getAfterColumnsList());
            }
        }
    }
}

private static void printColumn(List<Column> columns) {
    for (Column column : columns) {
        System.out.println(column.getName() + " : " + column.getValue() + "    update=" + column.getUpdated());
    }
}
```



不过这里我们会使用GitHub上的第三方开源的canal-starter客户端。地址：https://github.com/NormanGyllenhaal/canal-client

与SpringBoot完美整合，自动装配，比官方客户端要简单好用很多。

