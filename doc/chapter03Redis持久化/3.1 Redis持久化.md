Redis的高性能是由于其将所有数据都存储在了内存中，为了使 Redis在重启之后仍能保证数据不丢失，需要将数据从内存中同步到硬盘中，这一过程就是持久化。

Redis有两种持久化方案：

- RDB持久化   redis dataBase

  将Redis在指定的时间间隔

- AOF持久化   append only file

RDB持久化（默认开启）：在指定的时间间隔内将内存中的数据集快照写入磁盘

AOF持久化：以日志的形式记录服务器所处理的每一个写操作，在Redis服务器启动时会读取该文件来重新构建数据库，以保证启动后数据库中的数据是完整的，

redis可以同时使用RDB和AOF，我们也可以通过配置的方式禁用Redis服务器的持久化功能。

# RDB持久化

RDB全称Redis Database Backup file（Redis数据备份文件），也被叫做Redis数据快照。简单来说就是在指定的时间间隔，把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。快照文件称为RDB文件（dump.rdb），默认是保存在当前运行目录。

RDB保存快照时，执行的是全量快照。

![image-20240303171409046](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403031714004.png)

## 备份执行时机

手动触发

- 执行save命令
- 执行bgsave命令

自动触发

- 配置文件中默认的快照配置触发RDB条件时

  可以通过配置文件redis.conf中的`save`指令来设置自动触发RDB持久化的条件。例如，`save 900 1`表示在900秒内有至少1个key发生变化时，自动触发RDB快照的创建。


其他触发备份的情况

- shutdown命令并且没有开启AOP持久化
- flushall 也会产生dump.rdb文件，只不过是空文件
- Redis服务端正常退出时（systemctl stop redis，在Redis环境搭建时将Redis服务端注册成redis.service服务）  
- 主从复制时。主节点会主动触发

## 持久化

### 自动触发

在redis.conf配置文件中的 SNAPSHOTTING下配置 save参数，来触发Redis的 RDB持久化条件,比如“save m n”：表示每隔m秒检查数据集达到n次修改时，自动触发bgsave. 如果是save "" 则表示禁用RDB。

如果没有进行配置的情况下，默认情况下 Redis 会在以下情况下保存数据库：

* save 3600 1 ：每隔3600秒（一小时）检查数据集是否达到1个键
* save 300 100：每隔300秒（五分钟）检查数据集是否达到100个键
* save 60 10000：每隔60秒，检查数据集是否达到10000个键

**注意这里存在一个误区：不是seconds秒内操作changes次，是每seconds秒检查够不够changes次。save 60 100：60秒内，必须要达到100次操作才进行RDB持久化，而且每次的60秒都是要重新计算key更新的数量，即归零。这样的理解是错误的。**

**如果在第一个60秒的时间窗口内有95次操作，然后在下一个或后续的60秒时间窗口内又进行了95次或更多的操作，那么累积的操作次数将会超过100次，从而触发RDB快照的创建。**



#### 修改配置

1.设置:save 5 2 至少2个键发生了变化，在5秒内

2.修改dump文件保存路径:dir /dump,这个路径不能为空，需要提前创建好。

3.修改dump文件名称:dbfilename dump6379.rdb,在集群模式下需要通过修改dump文件名称进行区分。单机模式下可以不进行修改。





其他参数说明：

**stop-writer-on-bgsave-error   yes**

在bgsave执行失败时要不要停止写入，主进程停止接受写请求，保证数据一致性

默认为yes ，如果配置成no，表示不在乎数据不一致或有其他手段发现和控制数据不一致，那么在快照写入失败时，也能确保redis继续接受新的写请求

**rdbcompression yes**

用于控制是否启用 RDB 持久化文件的压缩。

当 `rdbcompression` 设置为 `yes` 时，意味着 Redis 在创建 RDB 快照文件时会使用压缩算法来压缩数据。压缩可以减少 RDB 文件的大小，从而节省磁盘空间。

**rdbchecksum  yes**

在存储快照后，还可以让redis使用CRC64算法来进行数据校验，这样做会增加大约10%的性能消耗，如果希望获取最大的性能提升，可以考虑关闭此功能

**rdb-del-sync-files  no**

在没有持久性的情况下是否删除复制中使用的RDB文件   默认为no  禁用

```shell
################################ SNAPSHOTTING  ################################

# Save the DB to disk.
#
# save <seconds> <changes>
#
# Redis will save the DB if both the given number of seconds and the given
# number of write operations against the DB occurred.
#
# Snapshotting can be completely disabled with a single empty string argument
# as in following example:
#
# save ""
#
# Unless specified otherwise, by default Redis will save the DB:
#   * After 3600 seconds (an hour) if at least 1 key changed
#   * After 300 seconds (5 minutes) if at least 100 keys changed
#   * After 60 seconds if at least 10000 keys changed
#
# You can set these explicitly by uncommenting the three following lines.
#
# save 3600 1
# save 300 100
# save 60 10000
save 5 2
# By default Redis will stop accepting writes if RDB snapshots are enabled
# (at least one save point) and the latest background save failed.
# This will make the user aware (in a hard way) that data is not persisting
# on disk properly, otherwise chances are that no one will notice and some
# disaster will happen.
#
# If the background saving process will start working again Redis will
# automatically allow writes again.
#
# However if you have setup your proper monitoring of the Redis server
# and persistence, you may want to disable this feature so that Redis will
# continue to work as usual even if there are problems with disk,
# permissions, and so forth.
stop-writes-on-bgsave-error yes

# Compress string objects using LZF when dump .rdb databases?
# By default compression is enabled as it's almost always a win.
# If you want to save some CPU in the saving child set it to 'no' but
# the dataset will likely be bigger if you have compressible values or keys.
rdbcompression yes

# Since version 5 of RDB a CRC64 checksum is placed at the end of the file.
# This makes the format more resistant to corruption but there is a performance
# hit to pay (around 10%) when saving and loading RDB files, so you can disable it
# for maximum performances.
#
# RDB files created with checksum disabled have a checksum of zero that will
# tell the loading code to skip the check.
rdbchecksum yes

# Enables or disables full sanitation checks for ziplist and listpack etc when
# loading an RDB or RESTORE payload. This reduces the chances of a assertion or
# crash later on while processing commands.
# Options:
#   no         - Never perform full sanitation
#   yes        - Always perform full sanitation
#   clients    - Perform full sanitation only for user connections.
#                Excludes: RDB files, RESTORE commands received from the master
#                connection, and client connections which have the
#                skip-sanitize-payload ACL flag.
# The default should be 'clients' but since it currently affects cluster
# resharding via MIGRATE, it is temporarily set to 'no' by default.
#
# sanitize-dump-payload no

# The filename where to dump the DB
dbfilename dump6379.rdb

# Remove RDB files used by replication in instances without persistence
# enabled. By default this option is disabled, however there are environments
# where for regulations or other security concerns, RDB files persisted on
# disk by masters in order to feed replicas, or stored on disk by replicas
# in order to load them for the initial synchronization, should be deleted
# ASAP. Note that this option ONLY WORKS in instances that have both AOF
# and RDB persistence disabled, otherwise is completely ignored.
#
# An alternative (and sometimes better) way to obtain the same effect is
# to use diskless replication on both master and replicas instances. However
# in the case of replicas, diskless is not always an option.
rdb-del-sync-files no

# The working directory.
#
# The DB will be written inside this directory, with the filename specified
# above using the 'dbfilename' configuration directive.
#
# The Append Only File will also be created inside this directory.
#
# Note that you must specify a directory here, not a file name.
dir /dump
```

修改完配置重启redis

```shell
127.0.0.1:6379> shutdown
not connected> quit
[root@redis ~]# redis-server redis.conf
2765:C 03 Mar 2024 08:49:51.570 # Fatal error, can't open config file '/root/redis.conf': No such file or directory
[root@redis ~]# redis-server /opt/redis-6.2.6/redis.conf
[root@redis ~]# redis-cli -a root
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.
127.0.0.1:6379> 
```

redis支持使用CONFIG GET的命令获取相关参数信息

```shell
127.0.0.1:6379> config get dir
1) "dir"
2) "/dump"
127.0.0.1:6379> config get save
1) "save"
2) "5 2"
127.0.0.1:6379> config get dbfilename
1) "dbfilename"
2) "dump6379.rdb"
```

#### 触发备份

五秒内两个key发生变化

```shell
127.0.0.1:6379> set k1 v1
OK
127.0.0.1:6379> set k2 v2
OK
```

/dump文件夹中生成了dump6379.rdb备份文件

```shell
[root@redis dump]# ll
总用量 8
-rw-r--r--. 1 root root 111 3月   3 09:16 dump6379.rdb
```

五秒以上两个key发生变化

```shell
127.0.0.1:6379> set k3 v3
OK
127.0.0.1:6379> set k4 v4
OK
```

/dump文件夹中的dump6379.rdb重新生成

```shell
[root@redis dump]# ll
总用量 8
-rw-r--r--. 1 root root  125 3月   3 09:48 dump6379.rdb
```

当五秒内超过两个key发生变化时，Redis会自动触发RDB快照的创建，生成dump文件。

当五秒内少于两个key发生变化，Redis不会触发RDB快照的创建。

而五秒以上超过两个key发生变化，Redis也会触发RDB快照的创建。只不过是触发的时间点不同。

#### 恢复备份

先将备份文件dump6379.rdb修改为dump.rdb，因为执行下面的flushdb和shutdown命令都会重新生成dump6379.rdb文件

```shell
[root@redis dump]# mv dump6379.rdb dump6379.rdb.bak
[root@redis dump]# ll
总用量 8
-rw-r--r--. 1 root root  125 3月   3 09:48 dump6379.rdb.bak
```

使用shutdown命令关闭redis服务端

```shell
127.0.0.1:6379> shutdown
not connected> quit
```

查看dump文件夹，使用shutdown命令关闭redis服务端时，又自动生成了一个dump6379.rdb文件

```shell
[root@redis dump]# ll
总用量 12
-rw-r--r--. 1 root root  125 3月   3 09:55 dump6379.rdb
-rw-r--r--. 1 root root  125 3月   3 09:48 dump6379.rdb.bak
```

将dump6379.rdb文件删除，然后再次启动redis服务端连接redis，连接reids客户端

```shell
[root@redis dump]# rm -f dump6379.rdb
[root@redis dump]# redis-server /opt/redis-6.2.6/redis.conf
[root@redis dump]# redis-cli -a root
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.
```

然后客户端使用flushall清空redis

```shell
127.0.0.1:6379> flushall
OK
127.0.0.1:6379> keys *
(empty array)
```

查看dump文件夹，使用flushall命令时，又自动生成了一个dump6379.rdb文件，只不过这个dump文件是个空文件

```shell
[root@redis dump]# ll
总用量 12
-rw-r--r--. 1 root root   92 3月   3 09:51 dump6379.rdb
-rw-r--r--. 1 root root  125 3月   3 09:48 dump6379.rdb.bak
```

关闭redis服务端

```shell
127.0.0.1:6379> shutdown
not connected> quit
```

再次将dump6379.rdb删除，将dump6379.rdb.bak修改为dump6379.rdb

```shell
[root@redis dump]# rm -f dump6379.rdb
[root@redis dump]# mv dump6379.rdb.bak dump6379.rdb
```

此时redis服务端的状态是数据已经被清空，启动redis服务端，连接redis客户端，数据自动恢复了。

```shell
[root@redis dump]# redis-server /opt/redis-6.2.6/redis.conf
[root@redis dump]# redis-cli -a root
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.
127.0.0.1:6379> keys *
1) "k1"
2) "k2"
3) "k4"
4) "k3"
```

**备注：生产上不可以把备份文件dump.rdb和生产redis服务器放在同一台机器，必须分开各自存储，以防生产机物理损坏后备份文件也丢失了。**

### 手动触发

Redis提供了两个命令来生成RDB文件，分别是save和bgsave.

#### save

在主程序中执行 会阻塞当前redis服务器，，直到持久化工作完成，在执行save命令期间，redis不能处理其他命令，线上禁止使用。

![image-20240303204344797](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403032043555.png)

save命令会导致主进程执行RDB，这个过程中其它所有命令都会被阻塞。

删除/dump文件夹中的dump6379.rdb文件，执行save命令

```shell
127.0.0.1:6379> save
OK
```

/dump文件夹生成了dump6379.rdb文件

```shell
[root@redis dump]# ll
总用量 12
-rw-r--r--. 1 root root  125 3月   3 10:30 dump6379.rdb
```



#### bgsave

fork一个子进程由子进程执行持久化过程，对当前内存中的所有数据做快照。这个操作是子进程在后台完成，这就允许主进程同时可以处理其他命令。

![image-20240303204801157](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403032048050.png)

删除/dump文件夹中的dump6379.rdb文件，执行bgsave命令

```shell
127.0.0.1:6379> bgsave
Background saving started
```

/dump文件夹生成了dump6379.rdb文件

```shell
[root@redis dump]# ll
总用量 12
-rw-r--r--. 1 root root  125 3月   3 10:34 dump6379.rdb
```



我们可以通过LASTSAVE命令获取最后一次成功执行快照的时间

```shell
127.0.0.1:6379> lastsave
(integer) 1709433242
```

最后一次成功执行快照的时间戳是1709433242

转换成时间：

```shell
[root@redis dump]# date -d @1709433242
2024年 03月 03日 星期日 10:34:02 CST
```

## 优势

- 适合大规模的数据恢复
- 可按照业务定时备份
- RDB文件在内存中的加载速度要比AOF快的多

## 劣势

- 每隔一定时间做一次备份，所以如果redis宕机，就会丢失从当前至最近一次快照期间的数据，快照之间的数据会丢失。

- 内存数据的全量同步，如果数据量太大，那么所需的I/O操作也会相应增加，从而影响到服务器性能。

- RDB依赖于主进程的fork，这个子进程被称为主进程的副本，它会继承父进程（即Redis主进程）的所有内存映射。在这个过程中，内存的使用量会暂时增加，因为子进程拥有一份与父进程相同的内存数据。

​		在“copy on write”机制下，子进程在fork后并不立即复制父进程的内存数据，而是共享同一块内存区域。当主进程需要修改数据时，它首先会检查该数据是否已经被子进程使用过（即是否被写入到RDB文件中）。如果没有被使用过，主进程会直接修改该数据；如果已经被使用过，主进程会复制该数据的一个副本，然后修改这个副本。这样，只有在数据真正被修改时才会发生复制操作，从而减少了不必要的内存复制。

因此，虽然子进程在fork后会增加内存使用量，但由于“copy on write”机制的存在，实际的内存使用量并不会达到两倍。只有当数据被修改并且被子进程使用时，才会发生内存复制。这样，Redis可以在保证数据一致性的同时，减少了内存的使

### 数据丢失案例

录入k1、k2

```
127.0.0.1:6379> set k1 v1
OK
127.0.0.1:6379> set k2 v2
OK
```

触发了RDB备份

```shell
[root@redis dump]# ll
总用量 20
-rw-r--r--. 1 root root   111 3月   3 15:37 dump6379.rdb
```

再录入k3

```shell
127.0.0.1:6379> set k3 v3
OK
127.0.0.1:6379> keys *
1) "k1"
2) "k2"
3) "k3"
```

没有触发RDB备份，最新的备份还是在执行k2时生成的

```shell
[root@redis dump]# ll
总用量 20
-rw-r--r--. 1 root root   111 3月   3 15:37 dump6379.rdb
-rw-r--r--. 1 root root 13687 3月   3 15:37 redis.log
```

reids服务意外宕机，这里杀掉redis进程

```shell
[root@redis dump]# ps -ef | grep redis
root       3316      1  0 15:32 ?        00:00:00 /usr/local/bin/redis-server 0.0.0.0:6379
root       3322   3211  0 15:37 pts/0    00:00:00 redis-cli -a root
root       3348   3328  0 15:39 pts/1    00:00:00 grep --color=auto redis
[root@redis dump]# kill -9 3316
```

杀掉redis进程，也没有触发RDB备份

```
[root@redis dump]# ll
总用量 20
-rw-r--r--. 1 root root   111 3月   3 15:37 dump6379.rdb
```

重启redis服务器，重新连接reids客户端，发现k3数据丢失。

```shell
[root@redis ~]# redis-server /opt/redis-6.2.6/redis.conf
[root@redis ~]# redis-cli -a root
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.
127.0.0.1:6379> get k3
(nil)
127.0.0.1:6379> get k2
"v2"
127.0.0.1:6379> get k1
"v1"
```

## 如何检查并修复损坏RDB文件

Redis的RDB文件在文件迁移或写入可能出现文件破损的情况。

以下是可能导致RDB文件损坏的一些情况：

1. **磁盘错误**：磁盘故障或错误可能会导致在RDB文件写入过程中数据损坏。如果磁盘出现问题，可能会导致写入的数据不完整或文件结构破坏。
2. **文件系统限制**：某些文件系统或存储解决方案可能对文件大小或操作有限制。如果Redis试图写入一个超出文件系统限制的RDB文件，文件可能会变得不可用。
3. **Redis进程异常终止**：如果Redis进程在生成RDB文件的过程中异常终止（例如由于内存不足、进程被杀死等原因），那么生成的RDB文件可能会是不完整的。
4. **网络问题**：如果Redis配置了将数据持久化到远程位置（例如通过网络文件系统NFS、Amazon S3等），网络中断或不稳定可能导致RDB文件在传输过程中损坏。
5. **错误的文件操作**：手动干预或错误的脚本操作可能会导致RDB文件损坏。例如，在RDB文件写入过程中移动或删除文件，或者在文件写入完成前停止Redis服务等。

需要使用专业的数据恢复工具或服务来尝试修复损坏的RDB文件。在/usr/lcoal/bin目录下存在redis-check-rdb文件，我们可以使用redis-check-rdb命令尝试恢复损坏的RDB文件。

关闭reids服务端

```shell
127.0.0.1:6379> shutdown
not connected> quit
```

先对dump6379.rdb文件进行备份，以防修复失败

```shell
[root@redis dump]# cp dump6379.rdb dump6379.rdb.bak
[root@redis dump]# vim dump6379.rdb
```

dump6379.rdb文件内容

![image-20240304135721250](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403041357863.png)

RDB 文件是二进制格式，尝试分析下:

1. **REDIS0009?** - 这是 RDB 文件的魔数（magic number），用于标识这是一个 Redis RDB 文件。这个部分不应该被修改。
2. **redis-ver 6.2.6?** - 这表明 Redis 的版本号。在正常情况下，您不应该需要修改这部分内容。
3. **redis-bits** - 这表示 Redis 是用多少位来存储数字的。这通常是 64，意味着 Redis 使用 64 位整数。这通常也不应该被修改。
4. **ctime** - 这可能是创建时间或检查点的时间戳。这通常是自动生成的，不应该手动修改。
5. **used-mem** - 这表示当前使用的内存量。这个值是由 Redis 自动计算的，并且不应该手动修改。
6. **aof-preamble** - 这与 AOF（Append Only File）持久化相关，如果 RDB 文件是从一个同时启用了 AOF 和 RDB 的 Redis 实例中生成的，那么这部分可能包含有关 AOF 的信息。通常，这部分内容也不应该被修改。
7. **k1 v1 k2 v2 ...** - 这些是键值对（key-value pairs），表示 Redis 数据库中的实际数据。您可以修改这些键值对来更改 Redis 数据库的内容。但是，请注意，直接编辑 RDB 文件来修改数据并不是一个推荐的做法，因为这可能会导致数据损坏或格式错误。修改 Redis 数据的最正确方式是使用 Redis 命令行接口或任何兼容的 Redis 客户端。

修改dump6379.rdb一些内容

![image-20240304135910779](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403041359413.png)

使用redis-check-rdb命令尝试恢复损坏的RDB文件

```shell
[root@redis redis-6.2.6]# cd /usr/local/bin
[root@redis bin]# ll
总用量 18908
-rw-r--r--. 1 root root      92 2月  29 13:14 dump.rdb
-rwxr-xr-x. 1 root root 4829472 2月  29 13:08 redis-benchmark
lrwxrwxrwx. 1 root root      12 2月  29 13:08 redis-check-aof -> redis-server
lrwxrwxrwx. 1 root root      12 2月  29 13:08 redis-check-rdb -> redis-server
-rwxr-xr-x. 1 root root 5003752 2月  29 13:08 redis-cli
lrwxrwxrwx. 1 root root      12 2月  29 13:08 redis-sentinel -> redis-server
-rwxr-xr-x. 1 root root 9518888 2月  29 13:08 redis-server
[root@redis bin]# redis-check-aof /dump/dump6379.rdb
The AOF appears to start with an RDB preamble.
Checking the RDB preamble to start:
[offset 0] Checking RDB file /dump/dump6379.rdb
--- RDB ERROR DETECTED ---
[offset 10] Invalid object type: 63
[additional info] While doing: read-type
[additional info] Reading type 0 (string)
[info] 0 keys read
[info] 0 expires
[info] 0 already expired
RDB preamble of AOF file is not sane, aborting.
```

启动reids服务端，查看数据是否正常

```shell
[root@redis ~]# redis-server /opt/redis-6.2.6/redis.conf
[root@redis ~]# redis-cli -a root
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.
127.0.0.1:6379> keys *
1) "k1"
2) "k2"
127.0.0.1:6379> 
[root@redis ~]# redis-cli -a root
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.
127.0.0.1:6379> get k1
"v1"
127.0.0.1:6379> get k2
"v2"
```



## 禁用RDB自动触发快照

可以使用命令

```shell
redis-cli config set save ""
```

或者在redis.conf中配置save ""





注：save ""配置只是进制了自动触发快照，其他触发RDB快照的情况还是会生成RDB快照的。

# AOF持久化

AOF全称为Append Only File。以日志的形式来记录每个写操作,将Redis执行过的所有写指令记录下来(读操作不记录), 只许追加文件但不可以改写文件, redis启动之初会读取该文件重新构建数据,换言之, redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作

Redis处理的每一个写命令都会记录在AOF文件，可以看做是命令日志文件。

默认情况下，redis的AOF功能没有开启，开启AOF功能需要设置: cc

![image-20240304141505961](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403041415020.png)

将appendonly设置为yes，开启AOF持久化，AOF文件的名称 默认为appendonly.aof 。AOF保存文件的位置和RDB保存文件的位置一样,都是通过redis.conf配置文件的dir配置

## AOF持久化流程

![image-20240304141701211](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403041417873.png)

1.Client作为命令的来源，会有多个源头以及源源不断的请求命令。（增删改）

2.在这些命令到达Redis Server以后并不是直接写入AOF文件,会将其这些命令先放入AOF缓存中进行保存,这里的AOF缓冲区实际上是内存中的一片区域,存在的目的是当这些命令达到一定量以后再写入磁盘,避免频繁的磁盘IO操作。

3.AOF缓冲会根据AOF缓冲区同步文件的三种写回策略将命令写入磁盘上的AOF文件。

4.随着写入AOF内容的增加为了避免文件膨胀，会根据规则进行命令的合并(又称AOF重写)，从而起到AOF文件压缩的目的。

5.当Redis Server 服务器重启的时候会从AOF文件载入数据。

### AOF有三种写回策略

AOF的命令记录的频率也可以通过redis.conf文件来配：

![image-20240304142631416](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403041426195.png)

```yaml
# 同步回写，表示每执行一次写命令，立即记录到AOF文件
appendfsync always 
# 写命令执行完先放入AOF缓冲区，然后表示每隔1秒将缓冲区数据写到AOF文件，是默认方案
appendfsync everysec 
# 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘
appendfsync no
```

三种写回策略对比

![image-20240304142851433](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403041428952.png)

## 持久化

### 正常恢复

清空redis缓存后，重启redis服务端

```shell
127.0.0.1:6379> flushdb
OK
127.0.0.1:6379> shutdown
not connected> quit
[root@redis ~]# redis-server /opt/redis-6.2.6/redis.conf
```

查看到生成了appendonly.aof文件

```shell
[root@redis bin]# cd /dump/
[root@redis dump]# ll
总用量 24
-rw-r--r--. 1 root root     0 3月   3 18:01 appendonly.aof
-rw-r--r--. 1 root root    92 3月   3 18:01 dump6379.rdb
-rw-r--r--. 1 root root 18596 3月   3 18:01 redis.log
```

连接redis客户端，写入数据

```shell
[root@redis ~]# redis-cli -a root
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.
127.0.0.1:6379> set k1 v1
OK
127.0.0.1:6379> set k2 v2
OK
127.0.0.1:6379> set k3 v3
OK
```

查看到appendonly.aof已经更新至最新

```shell
[root@redis dump]# ll
总用量 28
-rw-r--r--. 1 root root   110 3月   3 18:03 appendonly.aof
-rw-r--r--. 1 root root    92 3月   3 18:01 dump6379.rdb
-rw-r--r--. 1 root root 18596 3月   3 18:01 redis.log
```

对appendonly.aof文件进行备份

```shell
[root@redis dump]# cp appendonly.aof appendonly.aof.bak
[root@redis dump]# ll
总用量 32
-rw-r--r--. 1 root root   110 3月   3 18:03 appendonly.aof
-rw-r--r--. 1 root root   110 3月   3 18:11 appendonly.aof.bak
-rw-r--r--. 1 root root    92 3月   3 18:01 dump6379.rdb
-rw-r--r--. 1 root root 18596 3月   3 18:01 redis.log
```

reids客户端清空数据库，并关闭redis服务端

```shell
127.0.0.1:6379> flushdb
OK
127.0.0.1:6379> shutdown
not connected> quit
```

这里为了排除rdb的干扰，将dump6379.rdb进行删除

```shell
[root@redis dump]# rm -f dump6379.rdb
[root@redis dump]# ll
总用量 28
-rw-r--r--. 1 root root   127 3月   3 18:13 appendonly.aof
-rw-r--r--. 1 root root   110 3月   3 18:11 appendonly.aof.bak
-rw-r--r--. 1 root root 18854 3月   3 18:13 redis.log
```

重新启动redis服务端，连接redis客户端后，发现数据依然为空。

```shell
[root@redis ~]# redis-server /opt/redis-6.2.6/redis.conf
[root@redis ~]# redis-cli -a root
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.
127.0.0.1:6379> keys *
(empty array)
```

这是因为我们执行flushdb命令时，appendonly.aof文件也将flushdb命令写入了。为了验证我们将appendonly.aof删除，将appendonly.aof.bak文件修改为appendonly.aof

```shell
[root@redis dump]# rm -f appendonly.aof
[root@redis dump]# mv appendonly.aof.bak appendonly.aof
[root@redis dump]# ll
总用量 24
-rw-r--r--. 1 root root   110 3月   3 18:11 appendonly.aof
-rw-r--r--. 1 root root 20008 3月   3 18:15 redis.log
```

再次重启redis，关闭redis服务端

```shell
127.0.0.1:6379> shutdown
not connected> quit
```

这里再次确认下是否存在dump6379.rdb文件，存在则删除。

启动reids服务端，连接reids客户端，发现数据已经恢复了。

```shell
[root@redis ~]# redis-server /opt/redis-6.2.6/redis.conf
[root@redis ~]# redis-cli -a root
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.
127.0.0.1:6379> keys *
1) "k3"
2) "k2"
3) "k1"
```

### 异常恢复

故意乱写appendonly.aof文件，模拟网络闪断导致aof文件损坏。

![image-20240304162957666](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403041630999.png)

重启redis服务端，连接客户端时报错Connection refused

```shell
127.0.0.1:6379> shutdown
not connected> quit
[root@redis ~]# redis-server /opt/redis-6.2.6/redis.conf
[root@redis ~]# redis-cli -a root
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.
Could not connect to Redis at 127.0.0.1:6379: Connection refused
not connected> quit
```

使用异常修复命令 redis-check-aof --fix  清空不符合语法规则的命令，尝试修复。

```shell
[root@redis ~]# cd /usr/local/bin
[root@redis bin]# ll
总用量 18908
-rw-r--r--. 1 root root      92 2月  29 13:14 dump.rdb
-rwxr-xr-x. 1 root root 4829472 2月  29 13:08 redis-benchmark
lrwxrwxrwx. 1 root root      12 2月  29 13:08 redis-check-aof -> redis-server
lrwxrwxrwx. 1 root root      12 2月  29 13:08 redis-check-rdb -> redis-server
-rwxr-xr-x. 1 root root 5003752 2月  29 13:08 redis-cli
lrwxrwxrwx. 1 root root      12 2月  29 13:08 redis-sentinel -> redis-server
-rwxr-xr-x. 1 root root 9518888 2月  29 13:08 redis-server
[root@redis bin]# redis-check-aof --fix /dump/appendonly.aof 
0x              6e: Expected prefix '*', got: 's'
AOF analyzed: size=125, ok_up_to=110, ok_up_to_line=27, diff=15
This will shrink the AOF from 125 bytes, with 15 bytes, to 110 bytes
Continue? [y/N]: y
Successfully truncated AOF
```

重新启动redis服务端，查看redis客户端是否连接成功。

```shell
[root@redis bin]# redis-server /opt/redis-6.2.6/redis.conf
[root@redis bin]# redis-cli -a root
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.
127.0.0.1:6379> keys *
1) "k3"
2) "k2"
3) "k1"
```

## 优势

更好的保护数据不丢失（最多会丢失一秒内的数据）、性能高、可做紧急恢复

## 劣势

- 相同数据集的数据而言aof文件要远大于rdb文件，恢复速度慢于rdb
- aof运行效率要慢于rdb,每秒同步策略效率较好，不同步效率和rdb相同

## AOF重写机制

由于AOF持久化是Redis不断将写命令记录到AOF文件中,随着Redis不断的进行, AOF的文件会越来越大,文件越大,占用服务器内存越大以及AOF恢复要求时间越长。

为了解决这个问题, Redis新增了重写机制,当AOF文件的大小超过所设定的峰值时, Redis就会自动启动AOF文件的内容压缩,只保留可以恢复数据的最小指令集。

因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但只有最后一次写操作才有意义。我们也可以通过执行bgrewriteaof命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。



![image-20240304172522156](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403041725742.png)

如图，AOF原本有三个命令，但是set num 123 和 set num 666都是对num的操作，第二次会覆盖第一次的值，因此第一个命令记录下来没有意义。

所以重写命令后，AOF文件内容就是：mset name jack num 666



Redis会在触发阈值时自动去重写AOF文件。阈值也可以在redis.conf中配置：

```shell
# AOF文件比上次文件 增长超过多少百分比则触发重写
auto-aof-rewrite-percentage 100
# AOF文件体积最小多大以上才触发重写 
auto-aof-rewrite-min-size 64mb 
```

注意，同时满足，且的关系才会触发

1根据上次重写后的aof大小,判断当前aof大小是不是增长了1倍

2 重写时满足的文件大小

redis.conf中AOF相关配置参数：

```yaml

############################## APPEND ONLY MODE ###############################

# By default Redis asynchronously dumps the dataset on disk. This mode is
# good enough in many applications, but an issue with the Redis process or
# a power outage may result into a few minutes of writes lost (depending on
# the configured save points).
#
# The Append Only File is an alternative persistence mode that provides
# much better durability. For instance using the default data fsync policy
# (see later in the config file) Redis can lose just one second of writes in a
# dramatic event like a server power outage, or a single write if something
# wrong with the Redis process itself happens, but the operating system is
# still running correctly.
#
# AOF and RDB persistence can be enabled at the same time without problems.
# If the AOF is enabled on startup Redis will load the AOF, that is the file
# with the better durability guarantees.
#
# Please check https://redis.io/topics/persistence for more information.

appendonly no

# The name of the append only file (default: "appendonly.aof")

appendfilename "appendonly.aof"

# The fsync() call tells the Operating System to actually write data on disk
# instead of waiting for more data in the output buffer. Some OS will really flush
# data on disk, some other OS will just try to do it ASAP.
#
# Redis supports three different modes:
#
# no: don't fsync, just let the OS flush the data when it wants. Faster.
# always: fsync after every write to the append only log. Slow, Safest.
# everysec: fsync only one time every second. Compromise.
#
# The default is "everysec", as that's usually the right compromise between
# speed and data safety. It's up to you to understand if you can relax this to
# "no" that will let the operating system flush the output buffer when
# it wants, for better performances (but if you can live with the idea of
# some data loss consider the default persistence mode that's snapshotting),
# or on the contrary, use "always" that's very slow but a bit safer than
# everysec.
#
# More details please check the following article:
# http://antirez.com/post/redis-persistence-demystified.html
#
# If unsure, use "everysec".

# appendfsync always
appendfsync everysec
# appendfsync no

# When the AOF fsync policy is set to always or everysec, and a background
# saving process (a background save or AOF log background rewriting) is
# performing a lot of I/O against the disk, in some Linux configurations
# Redis may block too long on the fsync() call. Note that there is no fix for
# this currently, as even performing fsync in a different thread will block
# our synchronous write(2) call.
#
# In order to mitigate this problem it's possible to use the following option
# that will prevent fsync() from being called in the main process while a
# BGSAVE or BGREWRITEAOF is in progress.
#
# This means that while another child is saving, the durability of Redis is
# the same as "appendfsync none". In practical terms, this means that it is
# possible to lose up to 30 seconds of log in the worst scenario (with the
# default Linux settings).
#
# If you have latency problems turn this to "yes". Otherwise leave it as
# "no" that is the safest pick from the point of view of durability.

no-appendfsync-on-rewrite no

# Automatic rewrite of the append only file.
# Redis is able to automatically rewrite the log file implicitly calling
# BGREWRITEAOF when the AOF log size grows by the specified percentage.
#
# This is how it works: Redis remembers the size of the AOF file after the
# latest rewrite (if no rewrite has happened since the restart, the size of
# the AOF at startup is used).
#
# This base size is compared to the current size. If the current size is
# bigger than the specified percentage, the rewrite is triggered. Also
# you need to specify a minimal size for the AOF file to be rewritten, this
# is useful to avoid rewriting the AOF file even if the percentage increase
# is reached but it is still pretty small.
#
# Specify a percentage of zero in order to disable the automatic AOF
# rewrite feature.

auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb

# An AOF file may be found to be truncated at the end during the Redis
# startup process, when the AOF data gets loaded back into memory.
# This may happen when the system where Redis is running
# crashes, especially when an ext4 filesystem is mounted without the
# data=ordered option (however this can't happen when Redis itself
# crashes or aborts but the operating system still works correctly).
#
# Redis can either exit with an error when this happens, or load as much
# data as possible (the default now) and start if the AOF file is found
# to be truncated at the end. The following option controls this behavior.
#
# If aof-load-truncated is set to yes, a truncated AOF file is loaded and
# the Redis server starts emitting a log to inform the user of the event.
# Otherwise if the option is set to no, the server aborts with an error
# and refuses to start. When the option is set to no, the user requires
# to fix the AOF file using the "redis-check-aof" utility before to restart
# the server.
#
# Note that if the AOF file will be found to be corrupted in the middle
# the server will still exit with an error. This option only applies when
# Redis will try to read more data from the AOF file but not enough bytes
# will be found.
aof-load-truncated yes

# When rewriting the AOF file, Redis is able to use an RDB preamble in the
# AOF file for faster rewrites and recoveries. When this option is turned
# on the rewritten AOF file is composed of two different stanzas:
#
#   [RDB file][AOF tail]
#
# When loading, Redis recognizes that the AOF file starts with the "REDIS"
# string and loads the prefixed RDB file, then continues loading the AOF
# tail.
aof-use-rdb-preamble yes
```



### 前期配置准备

1.开启AOF: appendonly yes

2.为了触发重写机制，AOF文件体积峰值修改为1k: auto-aof-rewrite-min-size 1k

3.关闭混合持久化：aof-use-rdb-preamble no 

4.删除之前生成的rdb、aof文件，清除干扰项



修改配置后重启redis服务端，当前aof文件是个空文件

```shell
[root@redis dump]# ll
总用量 28
-rw-r--r--. 1 root root     0 3月   3 20:50 appendonly.aof
```

### 自动触发

执行set k1 v1 

```shell
127.0.0.1:6379> set k1 v1
OK
```

查看aof文件

```shell
[root@redis dump]# ll
总用量 32
-rw-r--r--. 1 root root    52 3月   3 20:53 appendonly.aof
```

多次修改k1值，直到aof文件即将达到1kb

```shell
127.0.0.1:6379> set k1 11111111111111111111111111
OK
127.0.0.1:6379> set k1 11111111111111111111111111
OK
127.0.0.1:6379> set k1 11111111111111111111111111
OK
127.0.0.1:6379> set k1 11111111111111111111111111
OK
127.0.0.1:6379> set k1 11111111111111111111111111
OK
127.0.0.1:6379> set k1 11111111111111111111111111
```

一遍修改k1的值，一边查看aof文件

```shell
[root@redis dump]# ll
总用量 32
-rw-r--r--. 1 root root   309 3月   3 20:56 appendonly.aof
-rw-r--r--. 1 root root 25330 3月   3 20:50 redis.log
[root@redis dump]# ll
总用量 32
-rw-r--r--. 1 root root   417 3月   3 20:56 appendonly.aof
-rw-r--r--. 1 root root 25330 3月   3 20:50 redis.log
[root@redis dump]# ll
总用量 32
-rw-r--r--. 1 root root   795 3月   3 20:56 appendonly.aof
-rw-r--r--. 1 root root 25330 3月   3 20:50 redis.log
[root@redis dump]# ll
总用量 32
-rw-r--r--. 1 root root   154 3月   3 20:57 appendonly.aof
-rw-r--r--. 1 root root 26194 3月   3 20:57 redis.log
```

发现当aof文件到达1kb时，触发了重写机制，文件大小变成了154b



1：在重写开始前，redis会创建一个“重写子进程”，这个子进程会读取现有的AOF文件，并将其包含的指令进行分析压缩并写入到一个临时文件中。

2：与此同时，主进程会将新接收到的写指令一边累积到内存缓冲区中，一边继续写入到原有的AOF文件中，这样做是保证原有的AOF文件的可用性，避免在重写过程中出现意外。

3：当“重写子进程”完成重写工作后，它会给父进程发一个信号，父进程收到信号后就会将内存中缓存的写指令追加到新AOF文件中

4：当追加结束后，redis就会用新AOF文件来代替旧AOF文件，之后再有新的写指令，就都会追加到新的AOF文件中

### 主动触发

多次修改k1的值

```shell
127.0.0.1:6379> set k1 11111111111111111111111111
OK
127.0.0.1:6379> set k1 11111111111111111111111111
OK
127.0.0.1:6379> set k1 11111111111111111111111111
OK
127.0.0.1:6379> set k1 11111111111111111111111111
OK
```

查看aof文件的大小

```shell
[root@redis dump]# ll
总用量 32
-rw-r--r--. 1 root root   370 3月   3 21:07 appendonly.aof
-rw-r--r--. 1 root root 26194 3月   3 20:57 redis.log
```

手动触发重写机制

```shell
127.0.0.1:6379> bgrewriteaof
Background append only file rewriting started
```

查看aof文件的大小，变成了77b

```shell
[root@redis dump]# ll
总用量 32
-rw-r--r--. 1 root root    77 3月   3 21:08 appendonly.aof
-rw-r--r--. 1 root root 26970 3月   3 21:08 redis.log
```

# RDB-AOF混合持久化

## 数据恢复顺序和加载流程

同时开启RDB 和AOF持久化时，重启时优先加载aof文件，不会加载rdb文件

![image-20240304200004624](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403042000419.png)

## 同时开启两种持久化方式

当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整

同时使用两者时服务器重启只会找AOF文件。那要不要只使用AOF呢？

作者建议不要，因为RDB更适合用于备份数据库（AOF在不断变化不好备份），留着rdb作为一个备用的手段。

同时开启两种持久化方式，RDB+AOF既能快速加载又能避免丢失过多的数据

### 开启混合方式设置

设置aof-use-rdb-preamble的值为yes；yes表示开启混合方式，设置为no表示禁用

混合持久化结合了 AOF（Append Only File）日志和 RDB（Redis DataBase）快照两种持久化方式的特点。



先使用RDB进行快照存储，然后使用AOF持久化记录所有的写操作，当重写策略满足或手动触发AOF重写的时候，fork 出来的重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件。随后，主线程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件。当写入完成后，会通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的 AOF 文件。

RDB+AOF的混合方式，RDB做全量持久化，AOF做增量持久化。保证了数据完整性，又提高了恢复数据的性能。

![image-20240304210230595](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403042102382.png)

# 纯缓存模式

同时关闭RDB+AOF，只做缓存

1.禁用RDB

save "" :禁用RDB持久化，仍然可以使用命令save、bgsave生成rdb文件

2.禁用AOF

appendonly on：禁用AOF持久化，仍然可以使用命令gbrewriteaof生成aof文件
