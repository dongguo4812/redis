Redis的高性能是由于其将所有数据都存储在了内存中，为了使 Redis在重启之后仍能保证数据不丢失，需要将数据从内存中同步到硬盘中，这一过程就是持久化。

Redis有两种持久化方案：

- RDB持久化   redis dataBase

  将Redis在指定的时间间隔

- AOF持久化   append only file

RDB持久化（默认开启）：在指定的时间间隔内将内存中的数据集快照写入磁盘

AOF持久化：以日志的形式记录服务器所处理的每一个写操作，在Redis服务器启动时会读取该文件来重新构建数据库，以保证启动后数据库中的数据是完整的，

redis可以同时使用RDB和AOF，我们也可以通过配置的方式禁用Redis服务器的持久化功能。

# RDB持久化

RDB全称Redis Database Backup file（Redis数据备份文件），也被叫做Redis数据快照。简单来说就是在指定的时间间隔，把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。快照文件称为RDB文件（dump.rdb），默认是保存在当前运行目录。

RDB保存快照时，执行的是全量快照。

![image-20240303171409046](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403031714004.png)

## 备份执行时机

手动触发

- 执行save命令
- 执行bgsave命令
- shutdown命令并且没有开启AOP持久化
- flushall 也会产生dump.rdb文件，只不过是空文件

自动触发

- Redis停机时 

- 主从复制时。主节点会主动触发

- 触发RDB条件时

  可以通过配置文件redis.conf中的`save`指令来设置自动触发RDB持久化的条件。例如，`save 900 1`表示在900秒内有至少1个key发生变化时，自动触发RDB快照的创建。

  

## 持久化

### 自动触发

在redis.conf配置文件中的 SNAPSHOTTING下配置 save参数，来触发Redis的 RDB持久化条件,比如“save m n”：表示每隔m秒检查数据集达到n次修改时，自动触发bgsave. 如果是save "" 则表示禁用RDB。

如果没有进行配置的情况下，默认情况下 Redis 会在以下情况下保存数据库：

* save 3600 1 ：每隔3600秒（一小时）检查数据集是否达到1个键
* save 300 100：每隔300秒（五分钟）检查数据集是否达到100个键
* save 60 10000：每隔60秒，检查数据集是否达到10000个键

注意这里存在一个误区：**不是seconds秒内操作changes次，是每seconds秒检查够不够changes次**。save 60 100：**60秒内，必须要达到100次操作才进行RDB持久化**，而且每次的60秒都是要重新计算key更新的数量，即**归零**。这样的理解是错误的。

如果在第一个60秒的时间窗口内有95次操作，然后在下一个或后续的60秒时间窗口内又进行了95次或更多的操作，那么累积的操作次数将会超过100次，从而触发RDB快照的创建。



**stop-writer-on-bgsave-error   yes**

在bgsave执行失败时要不要停止写入，主进程停止接受写请求，保证数据一致性

默认为yes ，如果配置成no，表示不在乎数据不一致或有其他手段发现和控制数据不一致，那么在快照写入失败时，也能确保redis继续接受新的写请求

**rdbchecksum  yes**

在存储快照后，还可以让redis使用CRC64算法来进行数据校验，这样做会增加大约10%的性能消耗，如果希望获取最大的性能提升，可以考虑关闭此功能

**rdb-del-sync-files  no**

在没有持久性的情况下是否删除复制中使用的RDB文件   默认为no  

#### 修改配置

1.设置:save 5 2 至少2个键发生了变化，在5秒内

2.修改dump文件保存路径:dir /dump,这个路径不能为空，需要提前创建好。

3.修改dump文件名称:dbfilename dump6379.rdb,在集群模式下需要通过修改dump文件名称进行区分。单机模式下可以不进行修改。

```shell
################################ SNAPSHOTTING  ################################

# Save the DB to disk.
#
# save <seconds> <changes>
#
# Redis will save the DB if both the given number of seconds and the given
# number of write operations against the DB occurred.
#
# Snapshotting can be completely disabled with a single empty string argument
# as in following example:
#
# save ""
#
# Unless specified otherwise, by default Redis will save the DB:
#   * After 3600 seconds (an hour) if at least 1 key changed
#   * After 300 seconds (5 minutes) if at least 100 keys changed
#   * After 60 seconds if at least 10000 keys changed
#
# You can set these explicitly by uncommenting the three following lines.
#
# save 3600 1
# save 300 100
# save 60 10000
save 5 2
# By default Redis will stop accepting writes if RDB snapshots are enabled
# (at least one save point) and the latest background save failed.
# This will make the user aware (in a hard way) that data is not persisting
# on disk properly, otherwise chances are that no one will notice and some
# disaster will happen.
#
# If the background saving process will start working again Redis will
# automatically allow writes again.
#
# However if you have setup your proper monitoring of the Redis server
# and persistence, you may want to disable this feature so that Redis will
# continue to work as usual even if there are problems with disk,
# permissions, and so forth.
stop-writes-on-bgsave-error yes

# Compress string objects using LZF when dump .rdb databases?
# By default compression is enabled as it's almost always a win.
# If you want to save some CPU in the saving child set it to 'no' but
# the dataset will likely be bigger if you have compressible values or keys.
rdbcompression yes

# Since version 5 of RDB a CRC64 checksum is placed at the end of the file.
# This makes the format more resistant to corruption but there is a performance
# hit to pay (around 10%) when saving and loading RDB files, so you can disable it
# for maximum performances.
#
# RDB files created with checksum disabled have a checksum of zero that will
# tell the loading code to skip the check.
rdbchecksum yes

# Enables or disables full sanitation checks for ziplist and listpack etc when
# loading an RDB or RESTORE payload. This reduces the chances of a assertion or
# crash later on while processing commands.
# Options:
#   no         - Never perform full sanitation
#   yes        - Always perform full sanitation
#   clients    - Perform full sanitation only for user connections.
#                Excludes: RDB files, RESTORE commands received from the master
#                connection, and client connections which have the
#                skip-sanitize-payload ACL flag.
# The default should be 'clients' but since it currently affects cluster
# resharding via MIGRATE, it is temporarily set to 'no' by default.
#
# sanitize-dump-payload no

# The filename where to dump the DB
dbfilename dump6379.rdb

# Remove RDB files used by replication in instances without persistence
# enabled. By default this option is disabled, however there are environments
# where for regulations or other security concerns, RDB files persisted on
# disk by masters in order to feed replicas, or stored on disk by replicas
# in order to load them for the initial synchronization, should be deleted
# ASAP. Note that this option ONLY WORKS in instances that have both AOF
# and RDB persistence disabled, otherwise is completely ignored.
#
# An alternative (and sometimes better) way to obtain the same effect is
# to use diskless replication on both master and replicas instances. However
# in the case of replicas, diskless is not always an option.
rdb-del-sync-files no

# The working directory.
#
# The DB will be written inside this directory, with the filename specified
# above using the 'dbfilename' configuration directive.
#
# The Append Only File will also be created inside this directory.
#
# Note that you must specify a directory here, not a file name.
dir /dump
```

修改完配置重启redis

```shell
127.0.0.1:6379> shutdown
not connected> quit
[root@redis ~]# redis-server redis.conf
2765:C 03 Mar 2024 08:49:51.570 # Fatal error, can't open config file '/root/redis.conf': No such file or directory
[root@redis ~]# redis-server /opt/redis-6.2.6/redis.conf
[root@redis ~]# redis-cli -a root
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.
127.0.0.1:6379> 
```

redis支持使用CONFIG GET的命令获取相关参数信息

```shell
127.0.0.1:6379> config get dir
1) "dir"
2) "/dump"
127.0.0.1:6379> config get save
1) "save"
2) "5 2"
127.0.0.1:6379> config get dbfilename
1) "dbfilename"
2) "dump6379.rdb"
```

#### 触发备份

五秒内两个key发生变化

```shell
127.0.0.1:6379> set k1 v1
OK
127.0.0.1:6379> set k2 v2
OK
```

/dump文件夹中生成了dump6379.rdb备份文件

```shell
[root@redis dump]# ll
总用量 8
-rw-r--r--. 1 root root 111 3月   3 09:16 dump6379.rdb
```

五秒以上两个key发生变化

```shell
127.0.0.1:6379> set k3 v3
OK
127.0.0.1:6379> set k4 v4
OK
```

/dump文件夹中的dump6379.rdb重新生成

```shell
[root@redis dump]# ll
总用量 8
-rw-r--r--. 1 root root  125 3月   3 09:48 dump6379.rdb
```

当五秒内超过两个key发生变化时，Redis会自动触发RDB快照的创建，生成dump文件。

当五秒内少于两个key发生变化，Redis不会触发RDB快照的创建。

而五秒以上超过两个key发生变化，Redis也会触发RDB快照的创建。只不过是触发的时间点不同。

#### 恢复备份

先将备份文件dump6379.rdb修改为dump.rdb，因为执行下面的flushdb和shutdown命令都会重新生成dump6379.rdb文件

```shell
[root@redis dump]# mv dump6379.rdb dump6379.rdb.bak
[root@redis dump]# ll
总用量 8
-rw-r--r--. 1 root root  125 3月   3 09:48 dump6379.rdb.bak
```

使用shutdown命令关闭redis服务端

```shell
127.0.0.1:6379> shutdown
not connected> quit
```

查看dump文件夹，使用shutdown命令关闭redis服务端时，又自动生成了一个dump6379.rdb文件

```shell
[root@redis dump]# ll
总用量 12
-rw-r--r--. 1 root root  125 3月   3 09:55 dump6379.rdb
-rw-r--r--. 1 root root  125 3月   3 09:48 dump6379.rdb.bak
```

将dump6379.rdb文件删除，然后再次启动redis服务端连接redis，连接reids客户端

```shell
[root@redis dump]# rm -f dump6379.rdb
[root@redis dump]# redis-server /opt/redis-6.2.6/redis.conf
[root@redis dump]# redis-cli -a root
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.
```

然后客户端使用flushall清空redis

```shell
127.0.0.1:6379> flushall
OK
127.0.0.1:6379> keys *
(empty array)
```

查看dump文件夹，使用flushall命令时，又自动生成了一个dump6379.rdb文件，只不过这个dump文件是个空文件

```shell
[root@redis dump]# ll
总用量 12
-rw-r--r--. 1 root root   92 3月   3 09:51 dump6379.rdb
-rw-r--r--. 1 root root  125 3月   3 09:48 dump6379.rdb.bak
```

关闭redis服务端

```shell
127.0.0.1:6379> shutdown
not connected> quit
```

再次将dump6379.rdb删除，将dump6379.rdb.bak修改为dump6379.rdb

```shell
[root@redis dump]# rm -f dump6379.rdb
[root@redis dump]# mv dump6379.rdb.bak dump6379.rdb
```

此时redis服务端的状态是数据已经被清空，启动redis服务端，连接redis客户端，数据自动恢复了。

```shell
[root@redis dump]# redis-server /opt/redis-6.2.6/redis.conf
[root@redis dump]# redis-cli -a root
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.
127.0.0.1:6379> keys *
1) "k1"
2) "k2"
3) "k4"
4) "k3"
```

**备注：生产上不可以把备份文件dump.rdb和生产redis服务器放在同一台机器，必须分开各自存储，以防生产机物理损坏后备份文件也丢失了。**

### 手动触发

Redis提供了两个命令来生成RDB文件，分别是save和bgsave.

#### save

在主程序中执行 会阻塞当前redis服务器，，直到持久化工作完成，在执行save命令期间，redis不能处理其他命令，线上禁止使用。

![image-20240303204344797](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403032043555.png)

save命令会导致主进程执行RDB，这个过程中其它所有命令都会被阻塞。

删除/dump文件夹中的dump6379.rdb文件，执行save命令

```shell
127.0.0.1:6379> save
OK
```

/dump文件夹生成了dump6379.rdb文件

```shell
[root@redis dump]# ll
总用量 12
-rw-r--r--. 1 root root  125 3月   3 10:30 dump6379.rdb
```



#### bgsave

fork一个子进程由子进程执行持久化过程，对当前内存中的所有数据做快照。这个操作是子进程在后台完成，这就允许主进程同时可以处理其他命令。

![image-20240303204801157](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403032048050.png)

删除/dump文件夹中的dump6379.rdb文件，执行bgsave命令

```shell
127.0.0.1:6379> bgsave
Background saving started
```

/dump文件夹生成了dump6379.rdb文件

```shell
[root@redis dump]# ll
总用量 12
-rw-r--r--. 1 root root  125 3月   3 10:34 dump6379.rdb
```



我们可以通过LASTSAVE命令获取最后一次成功执行快照的时间

```shell
127.0.0.1:6379> lastsave
(integer) 1709433242
```

最后一次成功执行快照的时间戳是1709433242

转换成时间：

```shell
[root@redis dump]# date -d @1709433242
2024年 03月 03日 星期日 10:34:02 CST
```

## 优势

- 适合大规模的数据恢复
- 可按照业务定时备份
- 对数据完整性和一致性要求不高
- RDB文件在内存中的加载速度要比AOF快的多

## 劣势