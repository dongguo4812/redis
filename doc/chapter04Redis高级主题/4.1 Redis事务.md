# Redis事务

Redis作为NoSQL数据库也同样提供了事务机制。

Redis事务是一组命令的集合，这些命令会被序列化并一次性、顺序性、排他性地执行。在Redis事务执行过程中，其他客户端提交的命令请求不会插入到事务执行命令序列中，从而保证了事务的原子性和隔离性。

Redis事务的实现需要用到MULTI和EXEC两个命令。

需要注意的是，Redis事务并不支持回滚机制，如果事务中的某个命令执行失败，其余的命令仍会被执行。此外，Redis事务没有隔离级别，事务中的命令在发送EXEC命令前被放入队列缓存，并不会被实际执行，因此不存在事务内的查询要看到事务里的更新，事务外查询不能看到的情况。

# Redis事务特性

![image-20240304213920100](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403042139377.png)

# Redis事务命令

- MULTI：标记一个事务块的开始。

- EXEC：执行所有事务块内的命令。

- DISCARD：取消事务，放弃执行事务块内的所有命令。

- WATCH key [key …]：监视一个（或多个）key，如果在事务执行之前这个（或这些）key被其他命令所改动，那么事务将被打断。

- UNWATCH：取消WATCH命令对所有key的监视。

## 正常执行事务MULTI EXEC

一下是一个简单事务 的例子，先使用MULTI 命令开始一个事务，然后将多个命令入队到事务中，最后由EXEC命令触发事务，执行事务块内的所有命令。执行命令后返回的是多个命令的结果。

```shell
127.0.0.1:6379> multi
OK
127.0.0.1:6379(TX)> set k1 v1
QUEUED
127.0.0.1:6379(TX)> set k2 v2
QUEUED
127.0.0.1:6379(TX)> set k3 v3
QUEUED
127.0.0.1:6379(TX)> incr count
QUEUED
127.0.0.1:6379(TX)> exec
1) OK
2) OK
3) OK
4) (integer) 1
127.0.0.1:6379> keys *
1) "count"
2) "k1"
3) "k2"
4) "k3"
```

## 放弃执行事务MULTI  DISCARD

我们可以使用DISCARD命令来取消一个事务。在调用DISCARD命令后会清空事务的命令队列。

```shell
127.0.0.1:6379> multi
OK
127.0.0.1:6379(TX)> set k1 v11
QUEUED
127.0.0.1:6379(TX)> incr count
QUEUED
127.0.0.1:6379(TX)> discard
OK
127.0.0.1:6379> get k1
"v1"
127.0.0.1:6379> get count
"1"
```

## 失败情况1：语法错误，全体连坐事务回滚

```shell
127.0.0.1:6379(TX)> set k1 v11
QUEUED
127.0.0.1:6379(TX)> set k2
(error) ERR wrong number of arguments for 'set' command
127.0.0.1:6379(TX)> exec
(error) EXECABORT Transaction discarded because of previous errors.
```

语法命令输入错误   ， error: 事务已经被抛弃

## 失败情况2 运行后出现异常， 异常的命令不执行，其他命令执行

```shell
127.0.0.1:6379> get k1
"v1"
127.0.0.1:6379> get count
"1"
127.0.0.1:6379> multi
OK
127.0.0.1:6379(TX)> incr count
QUEUED
127.0.0.1:6379(TX)> incr k1
QUEUED
127.0.0.1:6379(TX)> exec
1) (integer) 2
2) (error) ERR value is not an integer or out of range
127.0.0.1:6379> get k1
"v1"
127.0.0.1:6379> get count
"2"
```

redis检测没有报错，提交事务后， 第一个执行成功，第二个执行失败



运行后出现异常，Redis事务不提供事务回滚的功能，开发者必须在事务执行出错后，自行恢复数据库状态。

## WATCH监控

Redis使用watch来提供乐观锁控制复杂事务，类似于cas

乐观锁工作机制: watch命令会监视Redis给定的每一个key,当执行exec命令时如果监视的任何一个key自从调用watch命令后发生过变化,则整个事务会回滚,不执行任何动作。

乐观锁的视线必须基于WATCH命令，然后利用Redis的事务。

### 正常情况：

```shell
127.0.0.1:6379> set k1 abc
OK
127.0.0.1:6379> set balance 100
OK
127.0.0.1:6379> watch balance
OK
127.0.0.1:6379> multi
OK
127.0.0.1:6379(TX)> set k1 111
QUEUED
127.0.0.1:6379(TX)> set balance 110
QUEUED
127.0.0.1:6379(TX)> exec
1) OK
2) OK
127.0.0.1:6379> get k1
"111"
127.0.0.1:6379> get balance
"110"
```



### 异常情况：

watch命令是一种乐观锁的实现，Redis在修改的时候会检测数据是否被更改，如果更改了，则执行失败返回nil

客户端1执行

```shell
127.0.0.1:6379> get balance
"110"
127.0.0.1:6379> watch balance
OK
127.0.0.1:6379> multi
OK
127.0.0.1:6379(TX)> set k1 v1
QUEUED
```

此时，客户端2执行

```shell
127.0.0.1:6379> set balance 120
OK
127.0.0.1:6379> get balance
"120"
```

客户端1继续执行

```shell
127.0.0.1:6379(TX)> set balance 150
QUEUED
127.0.0.1:6379(TX)> exec
(nil)
```



## UNWATCH取消监控

一旦执行了exec,之前加的监控锁都会被取消掉了

当客户端连接丢失的时候(比如退出连接)，所有东西都会被取消监视



客户端1执行事务前取消对key的监控

```shell
127.0.0.1:6379> watch balance
OK
127.0.0.1:6379> get balance
"120"
127.0.0.1:6379> unwatch
OK
127.0.0.1:6379> multi
OK
```

客户端2执行

```shell
127.0.0.1:6379> set balance 150
OK
127.0.0.1:6379> get balance
"150"
```

客户端1继续执行

```shell
127.0.0.1:6379(TX)> set balance 200
QUEUED
127.0.0.1:6379(TX)> exec
1) OK
127.0.0.1:6379> get balance
"200"
```

取消对balance的监控，Redis在修改的时候就不会检测数据是否被更改。