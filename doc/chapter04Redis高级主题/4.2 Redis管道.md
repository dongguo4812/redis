# 如何优化频繁命令往返造成的性能瓶颈

Redis是一种基于客户端-服务端模型以及请求/响应协议的TCP服务。一个请求会遵循以下步骤：

1客户端向服务端发送命令分四步(发送命令→命令排队→命令执行→返回结果)，并监听Socket返回，通常以阻塞模式等待服务端响应。

2服务端处理命令，并将结果返回给客户端。

上述两步称为： Round Trip Time(简称RTT,数据包往返于两端的时间)。

![image-20240305090104035](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403050903306.png)

如果同时需要执行大量的命令,那么就要等待上一条命令应答后再执行,这中间不仅仅多了RTT (Round Time Trip) ,而且还频繁调用系统IO,发送网络请求,同时需要redis调用多次read()和write()系统方法,系统方法会将数据从用户态转移到内核态,这样就会对进程上下文有比较大的影响，性能不太好。

## 解决思路

引出管道这个概念。

# Pipeline管道



管道（pipeline）可以一次性发送多条命令给服务端，服务端依次处理完完毕后，通过一条响应一次性将结果返回，通过减少客户端与redis的通信次数来实现降低往返延时时间。pipeline实现的原理是队列,遵循先进先出特性就保证数据的顺序性。



![image-20240305090608108](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403050906405.png)



Pipeline将命令打包一次性发送，降低了RTT往返时间，是批处理命令变种优化措施。类似redis的原生批处理命令（mget 和 mset ）。Pipeline可以批处理不同类型的命令



## 示例

1.创建pipline.txt文件

```shell
[root@redis dump]# vim pipline.txt
```

2.将需要执行的命令写入到该文件

```shell
set k1 v1
set k2 v2
hset k3 name zhangsan
hset k3 age 18
lpush list 1 2 3 4
```

查看

```shell
[root@redis dump]# cat pipline.txt
set k1 v1
set k2 v2
hset k3 name zhangsan
hset k3 age 18
lpush list 1 2 3 4
```

3.将pipline.txt作为参数，使用`redis-cli`通过管道（pipe）向Redis服务器发送命令

```shell
[root@redis dump]# cat pipline.txt | redis-cli -a root --pipe
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.
All data transferred. Waiting for the last reply...
Last reply received from server.
errors: 0, replies: 5
```

4.查看结果

```shell
[root@redis dump]# redis-cli -a root
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.
127.0.0.1:6379> get k1
"v1"
127.0.0.1:6379> get k2
"v2"
127.0.0.1:6379> hget k3 name
"zhangsan"
127.0.0.1:6379> hget k3 age
"18"
127.0.0.1:6379> lrange list 0 -1
1) "4"
2) "3"
3) "2"
4) "1"
```

# 总结

## Pipline与原生批量命令对比

- 原生批量命令是原子性(例如:mset, mget), pipeline是非原子性
- 原生批量命令一次只能执行一种命令，pipeline支持批量执行不同命令
- 原生批命令是服务端实现，而pipeline需要服务端与客户端共同完成

## Pipeline与事务对比

- 事务具有原子性，管道不具有原子性

- 管道一次性将多条命令发送到服务器，事务是一条一条的发，事务只有在接收到exec命令后才会执行，管道不会

- 执行事务时会阻塞其他命令的执行，而执行管道中的命令时不会

## Pipeline注意事项

- pipeline缓冲的指令只是会依次执行,不保证原子性,如果执行中指令发生异常,将会继续执行后续的指令

- 使用pipeline组装的命令个数不能太多,不然数据量过大客户端阻塞的时间可能过久,同时服务端此时也被迫回复一个队列答复,占用很多内存
