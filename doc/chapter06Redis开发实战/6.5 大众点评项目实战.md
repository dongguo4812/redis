# 项目架构

![image-20240319171124630](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403191712307.png)

## 1.创建项目redis_dianping

后端项目redis_dianping

前端就不整了，使用swagger测试接口即可

## 2.引入依赖

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-redis</artifactId>
        <exclusions>
            <exclusion>
                <artifactId>spring-data-redis</artifactId>
                <groupId>org.springframework.data</groupId>
            </exclusion>
            <exclusion>
                <artifactId>lettuce-core</artifactId>
                <groupId>io.lettuce</groupId>
            </exclusion>
        </exclusions>
    </dependency>
    <dependency>
        <groupId>org.springframework.data</groupId>
        <artifactId>spring-data-redis</artifactId>
    </dependency>
    <dependency>
        <groupId>io.lettuce</groupId>
        <artifactId>lettuce-core</artifactId>
    </dependency>
    <dependency>
        <groupId>org.apache.commons</groupId>
        <artifactId>commons-pool2</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
        <scope>runtime</scope>
    </dependency>
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>com.baomidou</groupId>
        <artifactId>mybatis-plus-boot-starter</artifactId>
    </dependency>
    <!--hutool-->
    <dependency>
        <groupId>cn.hutool</groupId>
        <artifactId>hutool-all</artifactId>
    </dependency>
    <dependency>
        <groupId>org.apache.commons</groupId>
        <artifactId>commons-lang3</artifactId>
    </dependency>
    <dependency>
        <groupId>com.alibaba</groupId>
        <artifactId>fastjson</artifactId>
    </dependency>
    <dependency>
        <groupId>org.aspectj</groupId>
        <artifactId>aspectjweaver</artifactId>
    </dependency>
    <dependency>
        <groupId>org.redisson</groupId>
        <artifactId>redisson</artifactId>
    </dependency>
</dependencies>
```



## 3.application.yml配置

```yaml
server:
  port: 8081
spring:
  application:
    name: redis_dianping
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://127.0.0.1:3306/redis?useSSL=false&serverTimezone=UTC
    username: root
    password: root
  data:
    redis:
      host: 192.168.122.131
      port: 6379
      password: root
    lettuce:
      pool:
        max-active: 10
        max-idle: 10
        min-idle: 1
        time-between-eviction-runs: 10s
  jackson:
    default-property-inclusion: non_null # JSON处理时忽略非空字段
mybatis-plus:
  type-aliases-package: com.dongguo.redis.entity # 别名扫描包
logging:
  level:
    com.dongguo.redis: debug

```

## 4.配置类

MybatisConfig   MyBatis Plus分页插件

```java
import com.baomidou.mybatisplus.annotation.DbType;
import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;
import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class MybatisConfig {
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() {
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));
        return interceptor;
    }
}

```

RegexUtils正则校验工具类

```java
import cn.hutool.core.util.StrUtil;

/**
 * true 为无效  false为有效
 */
public class RegexUtils {
    /**
     * 手机号正则
     */
    public static final String PHONE_REGEX = "^1([38][0-9]|4[579]|5[0-3,5-9]|6[6]|7[0135678]|9[89])\\d{8}$";
    /**
     * 邮箱正则
     */
    public static final String EMAIL_REGEX = "^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\\.[a-zA-Z0-9_-]+)+$";
    /**
     * 密码正则。4~32位的字母、数字、下划线
     */
    public static final String PASSWORD_REGEX = "^\\w{4,32}$";
    /**
     * 验证码正则, 6位数字或字母
     */
    public static final String VERIFY_CODE_REGEX = "^[a-zA-Z\\d]{6}$";
    /**
     * 是否是无效手机格式
     * @param phone 要校验的手机号
     * @return true:符合，false：不符合
     */
    public static boolean isPhoneInvalid(String phone){
        return mismatch(phone, PHONE_REGEX);
    }
    /**
     * 是否是无效邮箱格式
     * @param email 要校验的邮箱
     * @return true:符合，false：不符合
     */
    public static boolean isEmailInvalid(String email){
        return mismatch(email, EMAIL_REGEX);
    }

    /**
     * 是否是无效验证码格式
     * @param code 要校验的验证码
     * @return true:符合，false：不符合
     */
    public static boolean isCodeInvalid(String code){
        return mismatch(code, VERIFY_CODE_REGEX);
    }

    // 校验是否不符合正则格式
    private static boolean mismatch(String str, String regex){
        if (StrUtil.isBlank(str)) {
            return true;
        }
        return !str.matches(regex);
    }
}

```



# 短信登录实战短信登录实战

## 基于Session实现登录流程

先不考虑使用redis实现，基于Session实现登录流程

**发送验证码：**

用户在提交手机号后，会校验手机号是否合法，如果不合法，则要求用户重新输入手机号

如果手机号合法，后台此时生成对应的验证码，同时将验证码进行保存到session，然后再通过短信的方式将验证码发送给用户

**短信验证码登录、注册：**

用户将验证码和手机号进行输入，后台从session中拿到当前验证码，然后和用户输入的验证码进行校验，如果不一致，则无法通过校验，如果一致，则后台根据手机号查询用户，如果用户不存在，则为用户创建账号信息，保存到数据库，存在则登录，无论是否存在，都会将用户信息保存到session中，方便后续获得当前登录信息

**校验登录状态:**

用户在请求时候，会从cookie中携带者JsessionId到后台，后台通过JsessionId从session中拿到用户信息，如果没有session信息，则进行拦截，如果有session信息，则将用户信息保存到threadLocal中，并且放行



![image-20240319171441782](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403191714868.png)

实现发送短信验证码功能

![image-20240319171506381](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403191715065.png)

点击登录，输入手机号，点击发送验证码

### 发送短信验证码功能

UserServiceImpl：

```java
        @Override
        public Result sendCode(String phone, HttpSession session) {
            //1校验手机号是否符合规定
            if (StringUtils.isBlank(phone)) {
                return Result.fail("手机号不能为空");
            }
            if (phone.length() != 11) {
                return Result.fail("手机号" + phone + "不符合要求");
            }
            boolean isMatch = RegexUtils.isPhoneInvalid(phone);
            if (isMatch) {
                return Result.fail("手机号" + phone + "不符合要求");
            }
            //2生成验证码
            String code = RandomUtil.randomNumbers(6);
            //3保存到session中
            session.setAttribute("code", code);
            log.debug("验证码发送成功:{}", code);
            return Result.ok("验证码发送成功:" + code);
        }
```

UserController：

```java
    @Operation(
            summary = "sendCode",
            description = "发送手机验证码"
    )
    @PostMapping("/sendCode")
    public Result sendCode(@RequestParam(value = "phone") String phone, HttpSession session) {
        return userService.sendCode(phone, session);
    }
```



### 短信验证码登录功能

UserServiceImpl

```java
    @Override
    public Result login(LoginFormBO loginForm, HttpSession session) {
        if (ObjectUtil.isEmpty(loginForm)) {
            return Result.fail("数据为空");
        }
        if (StringUtils.isBlank(loginForm.getPhone()) || StringUtils.isBlank(loginForm.getCode())) {
            return Result.fail("手机号或者验证码不能为空");
        }
        boolean isMatch = RegexUtils.isPhoneInvalid(loginForm.getPhone());
        if (isMatch) {
            return Result.fail("手机号" + loginForm.getPhone() + "不符合要求");
        }
        String code = session.getAttribute("code").toString();
        if (!loginForm.getCode().equals(code)) {
            return Result.fail("验证码错误");
        }

        LambdaUpdateWrapper<User> wrapper = new LambdaUpdateWrapper<>();
        wrapper.eq(User::getPhone, loginForm.getPhone());
        User user = userMapper.selectOne(wrapper);
        if (ObjectUtil.isEmpty(user)) {
            //注册新用户
            User newUser = new User()
                    .setPhone(loginForm.getPhone())
                    .setNickName(SystemConstants.USER_NICK_NAME_PREFIX + RandomUtil.randomString(SystemConstants.MAX_PAGE_SIZE));
            userMapper.insert(newUser);
        }
        //登录
        String token = UUID.randomUUID().toString(true);
        UserDTO userDTO = new UserDTO();
        BeanUtil.copyProperties(user, userDTO);
        session.setAttribute("user",userDTO);
        return Result.ok(token);
    }
```

UserController

```java
    /**
     * 登录功能  目前只实现手机+验证码登录即可
     *
     * @param loginForm 登录参数，包含手机号、验证码；或者手机号、密码
     */
    @PostMapping("/login")
    public Result login(@RequestBody LoginFormBO loginForm, HttpSession session) {
        return userService.login(loginForm,session);
    }
```

### 实现登录拦截功能

当用户发起请求时，会访问我们向tomcat注册的端口，任何程序想要运行，都需要有一个线程对当前端口号进行监听，tomcat也不例外，当监听线程知道用户想要和tomcat连接连接时，那会由监听线程创建socket连接，socket都是成对出现的，用户通过socket像互相传递数据，当tomcat端的socket接受到数据后，此时监听线程会从tomcat的线程池中取出一个线程执行用户请求，在我们的服务部署到tomcat后，线程会找到用户想要访问的工程，然后用这个线程转发到工程中的controller，service，dao中，并且访问对应的DB，在用户执行完请求后，再统一返回，再找到tomcat端的socket，再将数据写回到用户端的socket，完成请求和响应

![image-20240320094027340](F:\note\image\image-20240320094027340.png)

通过以上讲解，我们可以得知 每个用户其实对应都是去找tomcat线程池中的一个线程来完成工作的， 使用完成后再进行回收，既然每个请求都是独立的，所以在每个用户去访问我们的工程时，我们可以使用threadlocal来做到线程隔离，每个线程操作自己的一份数据

![image-20240320094215135](F:\note\image\image-20240320094215135.png)

拦截器LoginInterceptor

```java
import com.dongguo.redis.entity.DTO.UserDTO;
import com.dongguo.redis.support.threadlocal.UserThreadLocalCache;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;
import org.springframework.web.servlet.HandlerInterceptor;


/**
 * 登录拦截器
 */
public class LoginInterceptor implements HandlerInterceptor {

    /**
     * 在控制器方法（即处理请求的@RequestMapping注解的方法）之前调用
     * @param request
     * @param response
     * @param handler
     * @return
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
        //获取session
        HttpSession session = request.getSession();
        //获取session中用户信息
        Object user = session.getAttribute("user");
        if (user == null){
            //不存在，即未进行登录，进行拦截
            return false;
        }
        //存在，保存用户信息到threadLocal
        UserThreadLocalCache.setUser((UserDTO)user);
        //放行
        return true;
    }

    /**
     * 在整个请求处理完成之后调用
     * @param request
     * @param response
     * @param handler
     * @param ex
     * @throws Exception
     */
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        // 移除ThreadLocal用户信息
        UserThreadLocalCache.removeUser();
    }
}
```

MvcConfig：

在 Spring MVC 的配置中注册这个拦截器，让拦截器生效

```java
import com.dongguo.redis.support.interceptor.LoginInterceptor;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;


@Configuration
public class MvcConfig implements WebMvcConfigurer {


    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        //登录拦截器
        registry.addInterceptor(new LoginInterceptor())
                //排除不需要拦截的路径，视情况添加
                .excludePathPatterns(
                        "/v3/**",  //swagger也需要排除
                        "/swagger-ui/**",
                        "/swagger-ui.html",

                        "/shop/**", //店铺信息
                        "/voucher/**",  //优惠券信息
                        "/shop-type/**",    //店铺类型信息
                        "/blog/hot",    //查询热门博客
                        "/user/sendCode",  //发送短信验证码
                        "/user/login"  //登录
                ).order(1);
    }
}

```



### 获取用户信息

测试拦截器功能，必须登录后才能获取用户信息

![image-20240320101747433](F:\note\image\image-20240320101747433.png)

这个接口用户信息中的一些敏感信息是不需要返回的，所以直接返回UserDto对象就足够了。

并且拦截器会将session中的用户信息放入到ThreadLocal中，所以直接从ThreadLocal中获取user信息即可。

UserController：

```java
    /**
     * 请求接口时，拦截器会将session中的用户信息放入到ThreadLocal中
     * 所以直接从ThreadLocal中获取user信息即可。
     * @return
     */
    @GetMapping("/me")
    public Result me() {
        UserDTO user = UserThreadLocalCache.getUser();
        return Result.ok(user);
    }
```

### session共享问题

集群中，每个tomcat中都有一份属于自己的session,假设用户第一次访问第一台tomcat，并且把自己的信息存放到第一台服务器的session中，但是第二次这个用户访问到了第二台tomcat，那么在第二台服务器上，肯定没有第一台服务器存放的session，所以此时 整个登录拦截功能就会出现问题，我们能如何解决这个问题呢？早期的方案是session拷贝，就是说虽然每个tomcat上都有不同的session，但是每当任意一台服务器的session修改时，都会同步给其他的Tomcat服务器的session，这样的话，就可以实现session的共享了

但是这种方案具有两个大问题

1、每台服务器中都有完整的一份session数据，服务器压力过大。

2、session拷贝数据时，可能会出现延迟

![image-20240320110353355](F:\note\image\image-20240320110353355.png)

#### 解决方案

基于redis来完成，把session换成redis，redis数据本身就是共享的，就可以避免session共享的问题了

![image-20240320110630674](F:\note\image\image-20240320110630674.png)

## 基于Redis实现共享session登录

使用Redis保存session，可以直接使用String数据类型，以手机号为key，验证码为value。

使用Redis保存用户信息时，可以使用Hash数据类型也可以使用String数据类型。既然保存对象信息，那就选择hash。

在后台生成一个随机串token作为key，用户信息为value，请求接口时携带这个token就能完成我们的整体逻辑了

### 流程：

输入手机号生成验证码，将验证码保存到redis，登录时校验输入的验证码与redis中的验证码是否一致，如果一致，则根据手机号查询用户信息，不存在则新建，最后将用户数据保存到redis，并且生成token作为redis的key。

当我们校验用户是否登录时，会去携带着token进行访问，从redis中取出token对应的value，判断是否存在这个数据，如果没有则拦截，如果存在则将其保存到threadLocal中，并且放行。

![image-20240320112135358](F:\note\image\image-20240320112135358.png)





![image-20240320112356513](F:\note\image\image-20240320112356513.png)

### 修改代码

UserServiceImpl

```java
import cn.hutool.core.bean.BeanUtil;
import cn.hutool.core.bean.copier.CopyOptions;
import cn.hutool.core.lang.UUID;
import cn.hutool.core.util.ObjectUtil;
import cn.hutool.core.util.RandomUtil;
import com.baomidou.mybatisplus.core.conditions.update.LambdaUpdateWrapper;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.dongguo.redis.entity.BO.LoginFormBO;
import com.dongguo.redis.entity.DTO.UserDTO;
import com.dongguo.redis.entity.POJO.User;
import com.dongguo.redis.entity.Result;
import com.dongguo.redis.mapper.UserMapper;
import com.dongguo.redis.service.IUserService;
import com.dongguo.redis.utils.RedisConstants;
import com.dongguo.redis.utils.RegexUtils;
import com.dongguo.redis.utils.SystemConstants;
import jakarta.annotation.Resource;
import jakarta.servlet.http.HttpSession;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.stereotype.Service;
import java.time.Duration;
import java.util.HashMap;
import java.util.Map;

import static com.dongguo.redis.utils.RedisConstants.LOGIN_CODE_KEY;
import static com.dongguo.redis.utils.RedisConstants.LOGIN_CODE_TTL;

/**
 * <p>
 * 服务实现类
 * </p>
 */
@Service
@Slf4j
public class UserServiceImpl extends ServiceImpl<UserMapper, User> implements IUserService {
    @Autowired
    private UserMapper userMapper;
    @Resource
    private StringRedisTemplate stringRedisTemplate;

    @Override
    public Result sendCode(String phone, HttpSession session) {
        //1校验手机号是否符合规定
        if (StringUtils.isBlank(phone)) {
            return Result.fail("手机号不能为空");
        }
        if (phone.length() != 11) {
            return Result.fail("手机号" + phone + "不符合要求");
        }
        boolean isMatch = RegexUtils.isPhoneInvalid(phone);
        if (isMatch) {
            return Result.fail("手机号" + phone + "不符合要求");
        }
        //2生成验证码
        String code = RandomUtil.randomNumbers(6);
        //3保存到session中
//            session.setAttribute("code", code);
        //保存到redis中
        stringRedisTemplate.opsForValue().set(LOGIN_CODE_KEY + phone,
                code,
                Duration.ofMinutes(LOGIN_CODE_TTL));
        //4发送验证码
        log.debug("验证码发送成功:{}", code);
        return Result.ok("验证码发送成功:" + code);
    }

    @Override
    public Result login(LoginFormBO loginForm, HttpSession session) {
        if (ObjectUtil.isEmpty(loginForm)) {
            return Result.fail("数据为空");
        }
        if (StringUtils.isBlank(loginForm.getPhone()) || StringUtils.isBlank(loginForm.getCode())) {
            return Result.fail("手机号或者验证码不能为空");
        }
        boolean isMatch = RegexUtils.isPhoneInvalid(loginForm.getPhone());
        if (isMatch) {
            return Result.fail("手机号" + loginForm.getPhone() + "不符合要求");
        }
        String code = stringRedisTemplate.opsForValue().get(RedisConstants.LOGIN_CODE_KEY + loginForm.getPhone());
//        String code = session.getAttribute("code").toString();
        if (!loginForm.getCode().equals(code)) {
            return Result.fail("验证码错误");
        }

        LambdaUpdateWrapper<User> wrapper = new LambdaUpdateWrapper<>();
        wrapper.eq(User::getPhone, loginForm.getPhone());
        User user = userMapper.selectOne(wrapper);
        if (ObjectUtil.isEmpty(user)) {
            //注册新用户
            User newUser = new User()
                    .setPhone(loginForm.getPhone())
                    .setNickName(SystemConstants.USER_NICK_NAME_PREFIX + RandomUtil.randomString(SystemConstants.MAX_PAGE_SIZE));
            userMapper.insert(newUser);
        }
        //登录
        String token = UUID.randomUUID().toString(true);
        UserDTO userDTO = new UserDTO();
        BeanUtil.copyProperties(user, userDTO);
        Map<String, Object> userMap = new HashMap<>();
        BeanUtil.copyProperties(userDTO, userMap, new CopyOptions().setConverter((fieldName,filedValue) ->filedValue.toString()));
        stringRedisTemplate.opsForHash().putAll(RedisConstants.LOGIN_USER_KEY + token, userMap);
        stringRedisTemplate.expire(RedisConstants.LOGIN_USER_KEY + token, Duration.ofMinutes(RedisConstants.LOGIN_USER_TTL));
//        session.setAttribute("user", userDTO);
        return Result.ok(token);
    }
}
```

LoginInterceptor拦截器

```java
import cn.hutool.core.bean.BeanUtil;
import cn.hutool.core.util.ObjectUtil;
import com.dongguo.redis.entity.DTO.UserDTO;
import com.dongguo.redis.support.threadlocal.UserThreadLocalCache;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.web.servlet.HandlerInterceptor;
import java.util.Map;

import static com.dongguo.redis.utils.RedisConstants.LOGIN_USER_KEY;


/**
 * 登录拦截器
 */
public class LoginInterceptor implements HandlerInterceptor {
    private StringRedisTemplate stringRedisTemplate;

    public LoginInterceptor(StringRedisTemplate stringRedisTemplate) {
        this.stringRedisTemplate = stringRedisTemplate;
    }
    /**
     * 在控制器方法（即处理请求的@RequestMapping注解的方法）之前调用
     * @param request
     * @param response
     * @param handler
     * @return
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
   /*     //获取session
        HttpSession session = request.getSession();
        //获取session中用户信息
        Object user = session.getAttribute("user");
        if (user == null){
            //不存在，即未进行登录，进行拦截
            return false;
        }
        //存在，保存用户信息到threadLocal
        UserThreadLocalCache.setUser((UserDTO)user);
        */

        String token = request.getHeader("authorization");
        if (token == null){
            //不存在，即未进行登录，进行拦截
            response.setStatus(401);
            return false;
        }
        Map<Object, Object> userMap = stringRedisTemplate.opsForHash().entries(LOGIN_USER_KEY + token);
        if (ObjectUtil.isEmpty(userMap)){
            response.setStatus(401);
            return false;
        }
        UserDTO userDTO = BeanUtil.mapToBean(userMap, UserDTO.class,false);

        //存在，保存用户信息到threadLocal
        UserThreadLocalCache.setUser(userDTO);
        //放行
        return true;
    }

    /**
     * 在整个请求处理完成之后调用
     * @param request
     * @param response
     * @param handler
     * @param ex
     * @throws Exception
     */
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        // 移除ThreadLocal用户信息
        UserThreadLocalCache.removeUser();
    }
}
```

MvcConfig传入stringRedisTemplate

```java
import com.dongguo.redis.support.interceptor.LoginInterceptor;
import jakarta.annotation.Resource;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;


@Configuration
public class MvcConfig implements WebMvcConfigurer {
    @Resource
    private StringRedisTemplate stringRedisTemplate;
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        //登录拦截器
        registry.addInterceptor(new LoginInterceptor(stringRedisTemplate))
                //排除不需要拦截的路径，视情况添加
                .excludePathPatterns(
                        "/v3/**",  //swagger也需要排除
                        "/swagger-ui/**",
                        "/swagger-ui.html",
                        "/shop/**", //店铺信息
                        "/voucher/**",  //优惠券信息
                        "/shop-type/**",    //店铺类型信息
                        "/blog/hot",    //查询热门博客
                        "/user/sendCode",  //发送短信验证码
                        "/user/login"  //登录
                ).order(1);
    }
}
```

SwaggerOpenApiConfig新增AUTHORIZATION

```java
import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Contact;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.info.License;
import io.swagger.v3.oas.models.security.SecurityRequirement;
import io.swagger.v3.oas.models.security.SecurityScheme;
import org.springframework.boot.SpringBootConfiguration;
import org.springframework.context.annotation.Bean;
import org.springframework.http.HttpHeaders;

import java.util.HashMap;

@SpringBootConfiguration
public class SwaggerOpenApiConfig {
    /***
     * 构建Swagger3.0文档说明
     * @return 返回 OpenAPI
     */
    @Bean
    public OpenAPI customOpenAPI() {

        // 联系人信息(contact)，构建API的联系人信息，用于描述API开发者的联系信息，包括名称、URL、邮箱等
        // name：文档的发布者名称 url：文档发布者的网站地址，一般为企业网站 email：文档发布者的电子邮箱
        Contact contact = new Contact()
                .name("东郭")                             // 作者名称
                .email("dongguo@qq.com")                   // 作者邮箱
                .url("https://www.dongguo.com")  // 介绍作者的URL地址
                .extensions(new HashMap<String, Object>()); // 使用Map配置信息（如key为"name","email","url"）

        // 授权许可信息(license)，用于描述API的授权许可信息，包括名称、URL等；假设当前的授权信息为Apache 2.0的开源标准
        License license = new License()
                .name("Apache 2.0")                         // 授权名称
                .url("https://www.apache.org/licenses/LICENSE-2.0.html")    // 授权信息
                .identifier("Apache-2.0")                   // 标识授权许可
                .extensions(new HashMap<String, Object>());// 使用Map配置信息（如key为"name","url","identifier"）

        //创建Api帮助文档的描述信息、联系人信息(contact)、授权许可信息(license)
        Info info = new Info()
                .title("Swagger3.0 (Open API) 框架学习示例文档")      // Api接口文档标题（必填）
                .description("学习Swagger框架而用来定义测试的文档")     // Api接口文档描述
                .version("1.0.0")                                  // Api接口版本
                .termsOfService("https://dongguo.com/")            // Api接口的服务条款地址
                .license(license)                                  // 设置联系人信息
                .contact(contact);                                 // 授权许可信息
        // 返回信息
        return new OpenAPI()
                .openapi("3.0.1")  // Open API 3.0.1(默认)
                .schemaRequirement(HttpHeaders.AUTHORIZATION, this.securityScheme())
                //全局安全校验项，也可以在对应的controller上加注解SecurityRequirement
                .addSecurityItem(new SecurityRequirement().addList(HttpHeaders.AUTHORIZATION))
                .info(info);       // 配置Swagger3.0描述信息
    }

    /**
     * 参考https://springdoc.org/#how-do-i-add-authorization-header-in-requests
     * @return
     */
    private SecurityScheme securityScheme() {
        SecurityScheme securityScheme = new SecurityScheme();
        //类型
        securityScheme.setType(SecurityScheme.Type.APIKEY);
        //请求头的name
        securityScheme.setName(HttpHeaders.AUTHORIZATION);
        //token所在未知
        securityScheme.setIn(SecurityScheme.In.HEADER);
        return securityScheme;
    }
}
```

![image-20240320144136466](F:\note\image\image-20240320144136466.png)

### 解决登录token过期问题

在用户登录时，将用户信息缓存到redis中，并设置过期时间30分。但是如果超过了30分钟，那token就无效了，我们需要只要是用户还在访问系统，那就刷新token有效期。

![image-20240320151038915](F:\note\image\image-20240320151038915.png)

```java
    /**
     * 在控制器方法（即处理请求的@RequestMapping注解的方法）之前调用
     * @param request
     * @param response
     * @param handler
     * @return
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
        String token = request.getHeader("authorization");
        if (token == null){
            //不存在，即未进行登录，进行拦截
            response.setStatus(401);
            return false;
        }
        String tokenKey = LOGIN_USER_KEY + token;
        Map<Object, Object> userMap = stringRedisTemplate.opsForHash().entries(tokenKey);
        if (ObjectUtil.isEmpty(userMap)){
            response.setStatus(401);
            return false;
        }
        UserDTO userDTO = BeanUtil.mapToBean(userMap, UserDTO.class,false);

        //存在，保存用户信息到threadLocal
        UserThreadLocalCache.setUser(userDTO);
        //刷新token有效期
        stringRedisTemplate.expire(tokenKey, LOGIN_USER_TTL, TimeUnit.MINUTES);
        //放行
        return true;
    }
```

### 解决状态登录刷新问题

虽然我们在拦截器中设置了刷新token有效期的操作，但是这个登录拦截器他只拦截需要登录才能访问的路径，假设当前用户访问了一些不需要拦截的路径，那么这个拦截器就不会生效，所以此时token刷新的动作实际上就不会执行，这个方案是存在问题的



既然之前的拦截器无法对不需要拦截的路径生效，那么我们可以再添加一个拦截器，在第一个拦截器中拦截所有的路径，把第二个拦截器做的事情放入到第一个拦截器中，同时刷新令牌，因为第一个拦截器有了threadLocal的数据，所以此时第二个拦截器只需要判断拦截器中的user对象是否存在即可。

![image-20240320151337707](F:\note\image\image-20240320151337707.png)

RefreshTokenInterceptor 拦截器负责刷新token

```java
import cn.hutool.core.bean.BeanUtil;
import cn.hutool.core.util.StrUtil;
import com.dongguo.redis.entity.DTO.UserDTO;
import com.dongguo.redis.support.threadlocal.UserThreadLocalCache;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.web.servlet.HandlerInterceptor;
import java.util.Map;
import java.util.concurrent.TimeUnit;

import static com.dongguo.redis.utils.RedisConstants.LOGIN_USER_KEY;
import static com.dongguo.redis.utils.RedisConstants.LOGIN_USER_TTL;

public class RefreshTokenInterceptor implements HandlerInterceptor {

    private StringRedisTemplate stringRedisTemplate;

    public RefreshTokenInterceptor(StringRedisTemplate stringRedisTemplate) {
        this.stringRedisTemplate = stringRedisTemplate;
    }
    /**
     * 在控制器方法（即处理请求的@RequestMapping注解的方法）之前调用
     * @param request
     * @param response
     * @param handler
     * @return
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
       /*     //获取session
        HttpSession session = request.getSession();
        //获取session中用户信息
        Object user = session.getAttribute("user");
        if (user == null){
            //不存在，即未进行登录，进行拦截
            return false;
        }
        //存在，保存用户信息到threadLocal
        UserThreadLocalCache.setUser((UserDTO)user);
        */
        // 1.获取请求头中的token
        String token = request.getHeader("authorization");
        if (StrUtil.isBlank(token)) {
            return true;
        }
        // 2.基于TOKEN获取redis中的用户
        String tokenKey  = LOGIN_USER_KEY + token;
        Map<Object, Object> userMap = stringRedisTemplate.opsForHash().entries(tokenKey);
        // 3.判断用户是否存在
        if (userMap.isEmpty()) {
            return true;
        }
        // 5.将查询到的hash数据转为UserDTO
        UserDTO userDTO = BeanUtil.mapToBean(userMap, UserDTO.class,false);
        // 6.存在，保存用户信息到 ThreadLocal
        UserThreadLocalCache.setUser(userDTO);
        // 7.刷新token有效期
        stringRedisTemplate.expire(tokenKey, LOGIN_USER_TTL, TimeUnit.MINUTES);
        // 8.放行
        return true;
    }
    /**
     * 在整个请求处理完成之后调用
     * @param request
     * @param response
     * @param handler
     * @param ex
     * @throws Exception
     */
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        // 移除用户
        UserThreadLocalCache.removeUser();
    }
}
```

LoginInterceptor：

```java
import com.dongguo.redis.support.threadlocal.UserThreadLocalCache;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.web.servlet.HandlerInterceptor;


/**
 * 登录拦截器
 */
public class LoginInterceptor implements HandlerInterceptor {

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
        if (UserThreadLocalCache.getUser() == null){
            response.setStatus(401);
            return false;
        }
        return true;
    }
}
```

MvcConfig

在 Spring MVC 的配置中注册这两个拦截器，让拦截器生效

RefreshTokenInterceptor先拦截，拦截所有请求，LoginInterceptor后拦截，拦截需要登录才能访问的请求

```java
import com.dongguo.redis.support.interceptor.LoginInterceptor;
import com.dongguo.redis.support.interceptor.RefreshTokenInterceptor;
import jakarta.annotation.Resource;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;


@Configuration
public class MvcConfig implements WebMvcConfigurer {
    @Resource
    private StringRedisTemplate stringRedisTemplate;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        // token刷新的拦截器
        registry.addInterceptor(new RefreshTokenInterceptor(stringRedisTemplate))
                .addPathPatterns("/**")
                .order(0);

        //登录拦截器
        registry.addInterceptor(new LoginInterceptor())
                //排除不需要拦截的路径，视情况添加
                .excludePathPatterns(
                        "/v3/**",  //swagger也需要排除
                        "/swagger-ui/**",
                        "/swagger-ui.html",
                        "/shop/**", //店铺信息
                        "/voucher/**",  //优惠券信息
                        "/shop-type/**",    //店铺类型信息
                        "/blog/hot",    //查询热门博客
                        "/user/sendCode",  //发送短信验证码
                        "/user/login"  //登录
                ).order(1);
    }
}
```

