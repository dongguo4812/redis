# 项目架构

![image-20240319171124630](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403191712307.png)

## 1.创建项目redis_dianping

后端项目redis_dianping

前端就不整了，使用swagger测试接口即可

## 2.引入依赖

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-redis</artifactId>
        <exclusions>
            <exclusion>
                <artifactId>spring-data-redis</artifactId>
                <groupId>org.springframework.data</groupId>
            </exclusion>
            <exclusion>
                <artifactId>lettuce-core</artifactId>
                <groupId>io.lettuce</groupId>
            </exclusion>
        </exclusions>
    </dependency>
    <dependency>
        <groupId>org.springframework.data</groupId>
        <artifactId>spring-data-redis</artifactId>
    </dependency>
    <dependency>
        <groupId>io.lettuce</groupId>
        <artifactId>lettuce-core</artifactId>
    </dependency>
    <dependency>
        <groupId>org.apache.commons</groupId>
        <artifactId>commons-pool2</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
        <scope>runtime</scope>
    </dependency>
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>com.baomidou</groupId>
        <artifactId>mybatis-plus-boot-starter</artifactId>
    </dependency>
    <!--hutool-->
    <dependency>
        <groupId>cn.hutool</groupId>
        <artifactId>hutool-all</artifactId>
    </dependency>
    <dependency>
        <groupId>org.apache.commons</groupId>
        <artifactId>commons-lang3</artifactId>
    </dependency>
    <dependency>
        <groupId>com.alibaba</groupId>
        <artifactId>fastjson</artifactId>
    </dependency>
    <dependency>
        <groupId>org.aspectj</groupId>
        <artifactId>aspectjweaver</artifactId>
    </dependency>
    <dependency>
        <groupId>org.redisson</groupId>
        <artifactId>redisson</artifactId>
    </dependency>
</dependencies>
```



## 3.application.yml配置

```yaml
server:
  port: 8081
spring:
  application:
    name: redis_dianping
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://127.0.0.1:3306/redis?useSSL=false&serverTimezone=UTC
    username: root
    password: root
  data:
    redis:
      host: 192.168.122.131
      port: 6379
      password: root
    lettuce:
      pool:
        max-active: 10
        max-idle: 10
        min-idle: 1
        time-between-eviction-runs: 10s
  jackson:
    default-property-inclusion: non_null # JSON处理时忽略非空字段
mybatis-plus:
  type-aliases-package: com.dongguo.redis.entity # 别名扫描包
logging:
  level:
    com.dongguo.redis: debug

```

## 4.配置类

MybatisConfig   MyBatis Plus分页插件

```java
import com.baomidou.mybatisplus.annotation.DbType;
import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;
import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class MybatisConfig {
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() {
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));
        return interceptor;
    }
}

```

RegexUtils正则校验工具类

```java
import cn.hutool.core.util.StrUtil;

/**
 * true 为无效  false为有效
 */
public class RegexUtils {
    /**
     * 手机号正则
     */
    public static final String PHONE_REGEX = "^1([38][0-9]|4[579]|5[0-3,5-9]|6[6]|7[0135678]|9[89])\\d{8}$";
    /**
     * 邮箱正则
     */
    public static final String EMAIL_REGEX = "^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\\.[a-zA-Z0-9_-]+)+$";
    /**
     * 密码正则。4~32位的字母、数字、下划线
     */
    public static final String PASSWORD_REGEX = "^\\w{4,32}$";
    /**
     * 验证码正则, 6位数字或字母
     */
    public static final String VERIFY_CODE_REGEX = "^[a-zA-Z\\d]{6}$";
    /**
     * 是否是无效手机格式
     * @param phone 要校验的手机号
     * @return true:符合，false：不符合
     */
    public static boolean isPhoneInvalid(String phone){
        return mismatch(phone, PHONE_REGEX);
    }
    /**
     * 是否是无效邮箱格式
     * @param email 要校验的邮箱
     * @return true:符合，false：不符合
     */
    public static boolean isEmailInvalid(String email){
        return mismatch(email, EMAIL_REGEX);
    }

    /**
     * 是否是无效验证码格式
     * @param code 要校验的验证码
     * @return true:符合，false：不符合
     */
    public static boolean isCodeInvalid(String code){
        return mismatch(code, VERIFY_CODE_REGEX);
    }

    // 校验是否不符合正则格式
    private static boolean mismatch(String str, String regex){
        if (StrUtil.isBlank(str)) {
            return true;
        }
        return !str.matches(regex);
    }
}

```



# 短信登录实战短信登录实战

## 基于Session实现登录流程

先不考虑使用redis实现，基于Session实现登录流程

**发送验证码：**

用户在提交手机号后，会校验手机号是否合法，如果不合法，则要求用户重新输入手机号

如果手机号合法，后台此时生成对应的验证码，同时将验证码进行保存到session，然后再通过短信的方式将验证码发送给用户

**短信验证码登录、注册：**

用户将验证码和手机号进行输入，后台从session中拿到当前验证码，然后和用户输入的验证码进行校验，如果不一致，则无法通过校验，如果一致，则后台根据手机号查询用户，如果用户不存在，则为用户创建账号信息，保存到数据库，存在则登录，无论是否存在，都会将用户信息保存到session中，方便后续获得当前登录信息

**校验登录状态:**

用户在请求时候，会从cookie中携带者JsessionId到后台，后台通过JsessionId从session中拿到用户信息，如果没有session信息，则进行拦截，如果有session信息，则将用户信息保存到threadLocal中，并且放行



![image-20240319171441782](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403191714868.png)

实现发送短信验证码功能

![image-20240319171506381](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403191715065.png)

点击登录，输入手机号，点击发送验证码

### 发送短信验证码功能

UserServiceImpl：

```java
        @Override
        public Result sendCode(String phone, HttpSession session) {
            //1校验手机号是否符合规定
            if (StringUtils.isBlank(phone)) {
                return Result.fail("手机号不能为空");
            }
            if (phone.length() != 11) {
                return Result.fail("手机号" + phone + "不符合要求");
            }
            boolean isMatch = RegexUtils.isPhoneInvalid(phone);
            if (isMatch) {
                return Result.fail("手机号" + phone + "不符合要求");
            }
            //2生成验证码
            String code = RandomUtil.randomNumbers(6);
            //3保存到session中
            session.setAttribute("code", code);
            log.debug("验证码发送成功:{}", code);
            return Result.ok("验证码发送成功:" + code);
        }
```

UserController：

```java
    @Operation(
            summary = "sendCode",
            description = "发送手机验证码"
    )
    @PostMapping("/sendCode")
    public Result sendCode(@RequestParam(value = "phone") String phone, HttpSession session) {
        return userService.sendCode(phone, session);
    }
```



### 短信验证码登录功能

UserServiceImpl

```java
    @Override
    public Result login(LoginFormBO loginForm, HttpSession session) {
        if (ObjectUtil.isEmpty(loginForm)) {
            return Result.fail("数据为空");
        }
        if (StringUtils.isBlank(loginForm.getPhone()) || StringUtils.isBlank(loginForm.getCode())) {
            return Result.fail("手机号或者验证码不能为空");
        }
        boolean isMatch = RegexUtils.isPhoneInvalid(loginForm.getPhone());
        if (isMatch) {
            return Result.fail("手机号" + loginForm.getPhone() + "不符合要求");
        }
        String code = session.getAttribute("code").toString();
        if (!loginForm.getCode().equals(code)) {
            return Result.fail("验证码错误");
        }

        LambdaUpdateWrapper<User> wrapper = new LambdaUpdateWrapper<>();
        wrapper.eq(User::getPhone, loginForm.getPhone());
        User user = userMapper.selectOne(wrapper);
        if (ObjectUtil.isEmpty(user)) {
            //注册新用户
            User newUser = new User()
                    .setPhone(loginForm.getPhone())
                    .setNickName(SystemConstants.USER_NICK_NAME_PREFIX + RandomUtil.randomString(SystemConstants.MAX_PAGE_SIZE));
            userMapper.insert(newUser);
        }
        //登录
        String token = UUID.randomUUID().toString(true);
        UserDTO userDTO = new UserDTO();
        BeanUtil.copyProperties(user, userDTO);
        session.setAttribute("user",userDTO);
        return Result.ok(token);
    }
```

UserController

```java
    /**
     * 登录功能  目前只实现手机+验证码登录即可
     *
     * @param loginForm 登录参数，包含手机号、验证码；或者手机号、密码
     */
    @PostMapping("/login")
    public Result login(@RequestBody LoginFormBO loginForm, HttpSession session) {
        return userService.login(loginForm,session);
    }
```

### 实现登录拦截功能

当用户发起请求时，会访问我们向tomcat注册的端口，任何程序想要运行，都需要有一个线程对当前端口号进行监听，tomcat也不例外，当监听线程知道用户想要和tomcat连接连接时，那会由监听线程创建socket连接，socket都是成对出现的，用户通过socket像互相传递数据，当tomcat端的socket接受到数据后，此时监听线程会从tomcat的线程池中取出一个线程执行用户请求，在我们的服务部署到tomcat后，线程会找到用户想要访问的工程，然后用这个线程转发到工程中的controller，service，dao中，并且访问对应的DB，在用户执行完请求后，再统一返回，再找到tomcat端的socket，再将数据写回到用户端的socket，完成请求和响应

![image-20240320094027340](F:\note\image\image-20240320094027340.png)

通过以上讲解，我们可以得知 每个用户其实对应都是去找tomcat线程池中的一个线程来完成工作的， 使用完成后再进行回收，既然每个请求都是独立的，所以在每个用户去访问我们的工程时，我们可以使用threadlocal来做到线程隔离，每个线程操作自己的一份数据

![image-20240320094215135](F:\note\image\image-20240320094215135.png)

拦截器LoginInterceptor

```java
import com.dongguo.redis.entity.DTO.UserDTO;
import com.dongguo.redis.support.threadlocal.UserThreadLocalCache;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;
import org.springframework.web.servlet.HandlerInterceptor;


/**
 * 登录拦截器
 */
public class LoginInterceptor implements HandlerInterceptor {

    /**
     * 在控制器方法（即处理请求的@RequestMapping注解的方法）之前调用
     * @param request
     * @param response
     * @param handler
     * @return
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
        //获取session
        HttpSession session = request.getSession();
        //获取session中用户信息
        Object user = session.getAttribute("user");
        if (user == null){
            //不存在，即未进行登录，进行拦截
            return false;
        }
        //存在，保存用户信息到threadLocal
        UserThreadLocalCache.setUser((UserDTO)user);
        //放行
        return true;
    }

    /**
     * 在整个请求处理完成之后调用
     * @param request
     * @param response
     * @param handler
     * @param ex
     * @throws Exception
     */
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        // 移除ThreadLocal用户信息
        UserThreadLocalCache.removeUser();
    }
}
```

MvcConfig：

在 Spring MVC 的配置中注册这个拦截器，让拦截器生效

```java
import com.dongguo.redis.support.interceptor.LoginInterceptor;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;


@Configuration
public class MvcConfig implements WebMvcConfigurer {


    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        //登录拦截器
        registry.addInterceptor(new LoginInterceptor())
                //排除不需要拦截的路径，视情况添加
                .excludePathPatterns(
                        "/v3/**",  //swagger也需要排除
                        "/swagger-ui/**",
                        "/swagger-ui.html",

                        "/shop/**", //店铺信息
                        "/voucher/**",  //优惠券信息
                        "/shop-type/**",    //店铺类型信息
                        "/blog/hot",    //查询热门博客
                        "/user/sendCode",  //发送短信验证码
                        "/user/login"  //登录
                ).order(1);
    }
}

```



### 获取用户信息

测试拦截器功能，必须登录后才能获取用户信息

![image-20240320101747433](F:\note\image\image-20240320101747433.png)

这个接口用户信息中的一些敏感信息是不需要返回的，所以直接返回UserDto对象就足够了。

并且拦截器会将session中的用户信息放入到ThreadLocal中，所以直接从ThreadLocal中获取user信息即可。

UserController：

```java
    /**
     * 请求接口时，拦截器会将session中的用户信息放入到ThreadLocal中
     * 所以直接从ThreadLocal中获取user信息即可。
     * @return
     */
    @GetMapping("/me")
    public Result me() {
        UserDTO user = UserThreadLocalCache.getUser();
        return Result.ok(user);
    }
```

### session共享问题

集群中，每个tomcat中都有一份属于自己的session,假设用户第一次访问第一台tomcat，并且把自己的信息存放到第一台服务器的session中，但是第二次这个用户访问到了第二台tomcat，那么在第二台服务器上，肯定没有第一台服务器存放的session，所以此时 整个登录拦截功能就会出现问题，我们能如何解决这个问题呢？早期的方案是session拷贝，就是说虽然每个tomcat上都有不同的session，但是每当任意一台服务器的session修改时，都会同步给其他的Tomcat服务器的session，这样的话，就可以实现session的共享了

但是这种方案具有两个大问题

1、每台服务器中都有完整的一份session数据，服务器压力过大。

2、session拷贝数据时，可能会出现延迟

![image-20240320110353355](F:\note\image\image-20240320110353355.png)

#### 解决方案

基于redis来完成，把session换成redis，redis数据本身就是共享的，就可以避免session共享的问题了

![image-20240320110630674](F:\note\image\image-20240320110630674.png)

## 基于Redis实现共享session登录

使用Redis保存session，可以直接使用String数据类型，以手机号为key，验证码为value。

使用Redis保存用户信息时，可以使用Hash数据类型也可以使用String数据类型。这里选择hash。

在后台生成一个随机串token作为key，用户信息为value，请求接口时携带这个token就能完成我们的整体逻辑了

### 流程：

输入手机号生成验证码，将验证码保存到redis，登录时校验输入的验证码与redis中的验证码是否一致，如果一致，则根据手机号查询用户信息，不存在则新建，最后将用户数据保存到redis，并且生成token作为redis的key。

当我们校验用户是否登录时，会去携带着token进行访问，从redis中取出token对应的value，判断是否存在这个数据，如果没有则拦截，如果存在则将其保存到threadLocal中，并且放行。

![image-20240320112135358](F:\note\image\image-20240320112135358.png)





![image-20240320112356513](F:\note\image\image-20240320112356513.png)

### 修改代码