# 亿级系统中常见的四种统计

## 聚合统计

统计多个集合元素的聚合结果，  交集差集并集等集合统计

使用set

## 排序统计

抖音短视频最新评论留言的场景，设计一个展现列表，需要按照时间排序和分页展示

可以使用list。

在面对需要展示最新列表、排行榜等场景时，如果数据更新频繁或者需要分页显示，建议使用Zset，时间戳作为score

## 二值统计

集合元素的取值就只有0和1两种，在钉钉上班签到打卡的场景中，我们只用记录有签到1 没签到0   

bitmap

## 基数统计

指统计一个集合中不重复的元素个数

HyperLogLog



# 微信文章阅读量统计实战

![QQ浏览器截图20240309214040](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403092144351.png)

## 用户阅读文章贡献一个阅读量

分析：使用string的incr实现增加阅读量。

ArticleService：

```java
import jakarta.annotation.Resource;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;
import static com.dongguo.redis.utils.CacheKeyUtil.CACHE_ARTICLE_KEY;

@Slf4j
@Service
public class ArticleService {
    @Resource
    private RedisTemplate redisTemplate;

    public void addReading(String articleId) {
        String key = CACHE_ARTICLE_KEY + articleId;
        Long number = redisTemplate.opsForValue().increment(key);
        log.info("文章编号:{}, 阅读量:{}", articleId, number);
    }


    public Integer getReading(String articleId) {
        String key = CACHE_ARTICLE_KEY + articleId;
        Object obj = redisTemplate.opsForValue().get(key);
        log.info("文章编号:{}, 阅读量:{}", articleId, obj == null ? 0 : obj);
        return (Integer) obj;
    }
}

```



```java
import com.dongguo.redis.service.ArticleService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.annotation.Resource;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/article")
@Tag(
        name = "ArticleController",
        description = "文章控制器接口")
public class ArticleController {

    @Resource
    private ArticleService articleService;

    @Operation(
            summary = "需求1.0:增加阅读量",
            description = "用户阅读文章贡献一个阅读量"
    )
    @PostMapping("/addReading/{articleId}")
    public void addReading(@PathVariable(value = "articleId") String articleId) {
        articleService.addReading(articleId);
    }

    @Operation(
            summary = "获取阅读量",
            description = "获取阅读量"
    )
    @PostMapping("/getReading/{articleId}")
    public Integer getReading(@PathVariable(value = "articleId") String articleId) {
        return articleService.getReading(articleId);
    }
}

```



## 同篇文章一个微信号只能贡献一个阅读量

这时候产品经理告诉你，之前需求有问题，一个微信号可以无限制的增加文章的阅读量，要求进行修改。

分析：一篇文章一个微信号只能增加一次阅读量，使用set保存该文章贡献阅读量的微信号id，如果未阅读过该篇文章，就增加一次阅读量

ArticleService：

```java
    public void addReadingOnlyOnce(String articleId, String weChatId) {
        String key = CACHE_ARTICLE_KEY + articleId;
        String weChatKey = CACHE_WECHAT_KEY + articleId + ":" + weChatId;
        Boolean member = redisTemplate.opsForSet().isMember(weChatKey, weChatId);
        if (Boolean.FALSE.equals(member)) {
            Long number = redisTemplate.opsForValue().increment(key);
            log.info("文章编号:{}, 阅读量:{}", articleId, number);
            redisTemplate.opsForSet().add(weChatKey, weChatId);
        }
    }
```

ArticleController：

```java
    @Operation(
            summary = "需求2.0:增加阅读量",
            description = "同篇文章一个微信号只能贡献一个阅读量"
    )
    @PostMapping("/addReadingOnlyOnce")
    public void addReadingOnlyOnce(@RequestParam(value = "articleId") String articleId, @RequestParam(value = "weChatId") String weChatId) {
        articleService.addReadingOnlyOnce(articleId, weChatId);
    }
```



## 同篇文章一个微信号每天只能贡献一次阅读量

不久后产品经理又改需求，一个微信号可以无限制的增加文章的阅读量，那文章的阅读量太少了，要求进行修改。

改成同篇文章一个微信号每天只能贡献一次阅读量，隔天可以再贡献一次阅读量。

分析：使用set保存该文章贡献阅读量的微信号id，并设置过期时间为隔天零点。当天未阅读过该篇文章，就增加一次阅读量

ArticleService：

```java
    public void addReadingOnlyOnceOfDay(String articleId, String weChatId) {
        String key = CACHE_ARTICLE_KEY + articleId;
        String weChatKey = CACHE_WECHAT_KEY + articleId + ":" +  weChatId;
        Boolean hasKey = redisTemplate.hasKey(weChatKey);
        Boolean member = redisTemplate.opsForSet().isMember(weChatKey, weChatId);
        if (Boolean.FALSE.equals(member)) {
            Long number = redisTemplate.opsForValue().increment(key);
            log.info("文章编号:{}, 阅读量:{}", articleId, number);
            redisTemplate.opsForSet().add(weChatKey, weChatId);
            //当该key第一次赋值时设置过期时间为明天0点,可以使用定时任务
            if (Boolean.FALSE.equals(hasKey)) {
                // 获取当前日期
                Date today = new Date();
                // 获取明天的日期
                Date tomorrow = DateUtil.offsetDay(today, 1);
                // 获取明天凌晨的日期时间（0点）
                Date tomorrowMidnight = DateUtil.beginOfDay(tomorrow);
                redisTemplate.expireAt(weChatKey, tomorrowMidnight);
            }
        }
    }
```

ArticleController：

```java
    @Operation(
            summary = "需求3.0:增加阅读量",
            description = "同篇文章一个微信号每天只能贡献一次阅读量"
    )
    @PostMapping("/addReadingOnlyOnceOfDay")
    public void addReadingOnlyOnceOfDay(@RequestParam(value = "articleId") String articleId, @RequestParam(value = "weChatId") String weChatId) {
        articleService.addReadingOnlyOnceOfDay(articleId, weChatId);
    }
```





# 淘宝网站首页亿级UV的redis统计实战

## 常见业务术语

### UV

Unique Visitor 独立访客，一般理解为客户端ip  需要去重

### PV

page view 页面浏览量 不用去重

### DAU

daily active user 日活跃用户量

登录或者使用了某个产品的用户数 （登录用户 去重 ）

常用于反应网站、互联网应用或者网络游戏的运营情况

### MAU

Monthly Active user 月活跃用户量



很多计数类场景，比如每日注册 IP 数、每日访问 IP 数、页面实时访问数 PV、访问用户数 UV等。

因为主要的目标是高效、巨量地进行计数，所以对存储的数据的内容并不太关心。

也就是说它只能用于统计巨量数量，不太涉及具体的统计对象的内容和精准性。

 

## 分析

UV： 独立访客。需要去重，一个用户一天内的多次访问只能算作一次。

游客访问先判断是否访问过，没有则增加UV。



可以使用reids的hash， 但是Hash在存储大量数据时可能会消耗大量的内存空间。例如<DateKey,<ip,1>>，如果存储的是用户的IP地址，并且每个IP地址占用一定的字节，那么亿级别的UV数据将会占用非常大的内存空间。

更有效的方法可能是使用Redis提供的HyperLogLog数据结构。HyperLogLog是一种用于基数统计的算法，它可以在使用极少的内存空间的同时，给出近似但精度相对较高的统计结果。

TmallUniqueVisitorsService：

```java
import jakarta.annotation.Resource;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;
import java.util.Random;
import static com.dongguo.redis.utils.CacheKeyUtil.CACHE_TMALL_UV_KEY;

@Service
@Slf4j
public class TmallUniqueVisitorsService {
    @Resource
    private RedisTemplate redisTemplate;


    public Long getUV() {
        Long size = redisTemplate.opsForHyperLogLog().size(CACHE_TMALL_UV_KEY);
        log.info("当前UV: {}", size);
        return size;
    }

    public void addUV() {
        String key = CACHE_TMALL_UV_KEY;
        Random random = new Random();
        //每次点击，模拟200个ip访问
        for (int i = 0; i < 200; i++) {
            String randomIp = random.nextInt(255) + "." + random.nextInt(255) + "." + random.nextInt(255) + "." + random.nextInt(255);
            //PFCOUNT
            redisTemplate.opsForHyperLogLog().add(key, randomIp);
            log.info("当前访问ip: {}", randomIp);
        }
    }
}
```

TmallUniqueVisitorsController：

```java
import com.dongguo.redis.service.TmallUVService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.annotation.Resource;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/tmallUV")
@Tag(
        name = "TmallUniqueVisitorsController",
        description = "天猫UV控制器接口")
public class TmallUniqueVisitorsController {

    @Resource
    private TmallUniqueVisitorsService tmallUniqueVisitorsService;
    @Operation(
            summary = "addUV",
            description = "新增UV"
    )
    @PostMapping("/addUV")
    public void addUV() {
        tmallUniqueVisitorsService.addUV();
    }

    @Operation(
            summary = "getUV",
            description = "查询UV"
    )
    @GetMapping("/getUV")
    public Long getUV() {
        return tmallUniqueVisitorsService.getUV();
    }
}
```

使用hypeloglog统计的UV存在误差。400个IP访问后获得的UV为403，800个ip访问后获得的UV为809

# 美团地图位置附近的酒店推送实战

关于地理位置的肯定是geo了。使用到GEORADIUS命令：以给定的经纬度为中心，找出某一半径内的酒店

HotelService：

```java
import jakarta.annotation.Resource;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.geo.*;
import org.springframework.data.redis.connection.RedisGeoCommands;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import static com.dongguo.redis.utils.CacheKeyUtil.CACHE_HOTEL_KEY;

@Slf4j
@Service
public class HotelService {
    @Resource
    private RedisTemplate redisTemplate;

    public String addHotel() {
        String key = CACHE_HOTEL_KEY;
        //初始化三个酒店
        Map<String, Point> map = new HashMap<>();
        map.put("我的位置", new Point(116.403669, 39.915312));
        map.put("锦江酒店", new Point(116.403963, 39.915119));
        map.put("华住酒店", new Point(116.403414, 39.924091));
        map.put("开元酒店", new Point(116.746579, 40.482509));
        redisTemplate.opsForGeo().add(key, map);
        return map.toString();
    }

    public List getGeo(String member) {
        String key = CACHE_HOTEL_KEY;
        return redisTemplate.opsForGeo().position(key, member);
    }

    public GeoResults getGeoRadius(Point point) {
        String key = CACHE_HOTEL_KEY;
        //查找半径10公里
        Distance distance = new Distance(10, Metrics.KILOMETERS);
        Circle circle = new Circle(point, distance);
        //返回50条
        RedisGeoCommands.GeoRadiusCommandArgs args = RedisGeoCommands
                .GeoRadiusCommandArgs.newGeoRadiusArgs()    //创建地理位置查询的参数构造器。
                .includeDistance()      //返回的地理位置都会附带其到圆心的距离。
                .includeCoordinates()   //返回的地理位置都会附带其具体的经纬度坐标。
                .sortAscending();   //按照距离圆心的距离进行升序排序。
        return redisTemplate.opsForGeo().radius(key, circle, args);
    }

    public GeoResults getGeoRadiusByMember(String member) {
        String key = CACHE_HOTEL_KEY;
        //返回50条
        RedisGeoCommands.GeoRadiusCommandArgs args = RedisGeoCommands
                .GeoRadiusCommandArgs.newGeoRadiusArgs()
                .includeDistance()
                .includeCoordinates()
                .sortAscending();
        //查找半径10公里
        Distance distance = new Distance(10, Metrics.KILOMETERS);
        return redisTemplate.opsForGeo().radius(key, member, distance, args);
    }
}
```

HotelController：

```java
import com.dongguo.redis.service.HotelService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.annotation.Resource;
import org.springframework.data.geo.GeoResults;
import org.springframework.data.geo.Point;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/hotel")
@Tag(
        name = "HotelController",
        description = "美团酒店控制器接口")
public class HotelController {
    @Resource
    private HotelService hotelService;

    @Operation(
            summary = "addHotel",
            description = "新增酒店"
    )
    @PostMapping("/addHotel")
    public String addHotel() {
        return hotelService.addHotel();
    }

    @Operation(
            summary = "getGeo",
            description = "根据名称获取经纬度"
    )
    @GetMapping("/getGeo/{member}")
    public List getGeo(@PathVariable(value = "member") String member) {
        return hotelService.getGeo(member);
    }

    /**
     *   {
     *     "x": 116.40366822481155,
     *     "y": 39.91531234219449
     *   }
     * @param point
     * @return
     */
    @Operation(
            summary = "getGeoRadius",
            description = "通过经纬度查找附近地点"
    )
    @PostMapping("/getGeoRadius")
    public GeoResults getGeoRadius(@RequestBody Point point) {
        return hotelService.getGeoRadius(point);
    }

    @Operation(
            summary = "getGeoRadiusByMember",
            description = "通过地址查找附近地点"
    )
    @GetMapping("/getGeoRadiusByMember/{member}")
    public GeoResults getGeoRadiusByMember(@PathVariable(value = "member") String member) {
        return hotelService.getGeoRadiusByMember(member);
    }
}
```

# 游戏签到统计实战

统计2024-03-04和2024-03-06  连续三天都签到的玩家。

分析：对于是否签到的场景可以使用bitmap，在签到统计时，每个玩家的签到用bit为就能表示。

在 Spring Data Redis 中，通常没有直接对应于 `BITOP` 、`bitCount`	命令的方法。需要使用原生的 Redis 命令。

GameSignService：

```java
import jakarta.annotation.Resource;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.redis.core.RedisCallback;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;
import static com.dongguo.redis.utils.CacheKeyUtil.CACHE_GAME_SIGN_KEY;

@Slf4j
@Service
public class GameSignService {
    @Resource
    private RedisTemplate redisTemplate;

    /**
     * 以日期为key,玩家id为offset
     */
    public void addGamer() {
        String oneKey = CACHE_GAME_SIGN_KEY + "20240304";
        redisTemplate.opsForValue().setBit(oneKey, 1001, Boolean.TRUE);
        redisTemplate.opsForValue().setBit(oneKey, 1002, Boolean.TRUE);
        redisTemplate.opsForValue().setBit(oneKey, 1003, Boolean.TRUE);

        String twoKey = CACHE_GAME_SIGN_KEY + "20240305";
        redisTemplate.opsForValue().setBit(twoKey, 1001, Boolean.TRUE);
        redisTemplate.opsForValue().setBit(twoKey, 1003, Boolean.TRUE);

        String threeKey = CACHE_GAME_SIGN_KEY + "20240306";
        redisTemplate.opsForValue().setBit(threeKey, 1001, Boolean.TRUE);
        redisTemplate.opsForValue().setBit(threeKey, 1002, Boolean.TRUE);
        redisTemplate.opsForValue().setBit(threeKey, 1003, Boolean.TRUE);

    }

    public Long getSignThreeDayCount() {
        String destKey = CACHE_GAME_SIGN_KEY + "destKey";
        String oneKey = CACHE_GAME_SIGN_KEY + "20240304";
        String twoKey = CACHE_GAME_SIGN_KEY + "20240305";
        String threeKey = CACHE_GAME_SIGN_KEY + "20240305";
        //取交集将结果保存到destKey中
        bitOp("AND", destKey, oneKey, twoKey, threeKey);
        //获取destKey中1的个数
        return bitCount(destKey);
    }

    /**
     * @param operation  位操作类型 AND、OR、XOR 和 NOT
     * @param destKey    用于存储执行位操作后的结果
     * @param sourceKeys 源键（source keys）的列表
     */
    public void bitOp(String operation, String destKey, String... sourceKeys) {
        // 构建并执行原生 Redis 命令
        Object count = redisTemplate.execute((RedisCallback<Long>) connection -> {
            // 转换操作名、目标键和源键为字节数组
            byte[] opBytes = operation.getBytes();
            byte[] destKeyBytes = destKey.getBytes();
            byte[][] sourceKeyBytes = new byte[sourceKeys.length][];
            for (int i = 0; i < sourceKeys.length; i++) {
                sourceKeyBytes[i] = sourceKeys[i].getBytes();
            }

            // 合并操作字节数组和所有键的字节数组
            byte[][] args = new byte[sourceKeyBytes.length + 2][];
            args[0] = opBytes;
            args[1] = destKeyBytes;
            System.arraycopy(sourceKeyBytes, 0, args, 2, sourceKeyBytes.length);

            // 执行 BITOP 命令
            // 注意：这里我们直接传递命令名称 "BITOP" 和参数数组
            return (Long) connection.execute("BITOP", args);
        });
    }

    /**
     * 计算key中1的个数
     * @param key
     * @return
     */
    public Long bitCount(String key) {
        return (Long) redisTemplate.execute((RedisCallback<Long>) connection -> {
            // 转换键为字节数组
            byte[] keyBytes = key.getBytes();
            // 执行 BITCOUNT 命令
            return connection.bitCount(keyBytes);
        });
    }
}
```

GameSignController：

```java
import com.dongguo.redis.service.GameSignService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.annotation.Resource;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/gameSign")
@Tag(
        name = "GameSignController",
        description = "游戏签到控制器接口")
public class GameSignController {
    @Resource
    private GameSignService gameSignService;

    @Operation(
            summary = "addGamer",
            description = "初始化数据"
    )
    @PostMapping("/addGamer")
    public void addGamer() {
        gameSignService.addGamer();
    }

    @Operation(
            summary = "getSignThreeDayCount",
            description = "连续三天签到的玩家"
    )
    @PostMapping("/getSignThreeDayCount")
    public Long getSignThreeDayCount() {
        return gameSignService.getSignThreeDayCount();
    }
}
```

# 微信抢红包实战

着微信抢红包的普及，用户在微信群或朋友圈中发放红包，吸引其他人参与抢红包，丰富了人们的社交方式和娱乐方式，增强了人与人之间的互动和联系。

## 分析 

用户发一次红包可能拆分成多个小红包，每个人只能抢一次，所以需要记录哪些人抢到了红包，不允许重复抢红包；

红包可以设置期限，红包过期，将剩余金额退回。

### 1.发红包

使用list

### 2.抢红包

需要支持高并发，单Redis无需加锁就能保证原子性。

### 3.记录

每个人只能抢一次，记录哪些人抢到了红包

使用hash记录每个人抢的红包金额

### 4红包算法

通过算法保证红包金额随机性，并且保证每个红包大致的金额范围，接近均值分配。

所有人抢到红包的金额之和等于红包金额。每个人至少抢到一分钱。

使用二倍均值法：

每次抢到的金额=随机区间(0, (剩余红包金额M / 剩余人数N) * 2)，即每次抢到的金额为大于0 至 小于剩余红包金额M / 剩余人数N) * 2。



## 代码

RedPackageService：

```java
import cn.hutool.core.util.IdUtil;
import jakarta.annotation.Resource;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;
import java.lang.Long;
import java.util.Arrays;
import java.util.Random;
import java.util.concurrent.TimeUnit;

import static com.dongguo.redis.utils.CacheKeyUtil.CACHE_RED_PACKAGE_CONSUME_KEY;
import static com.dongguo.redis.utils.CacheKeyUtil.CACHE_RED_PACKAGE_KEY;

@Service
@Slf4j
public class RedPackageService {
    @Resource
    private RedisTemplate redisTemplate;


    public String send(Long totalMoney, Integer redPackageCount) {
        //先拆分红包
        Long[] splitRedPackage = splitRedPackage(totalMoney, redPackageCount);

        //list保存红包
        String redPackageKey = IdUtil.simpleUUID();
        String key = CACHE_RED_PACKAGE_KEY + redPackageKey;
        redisTemplate.opsForList().leftPushAll(key, splitRedPackage);
        redisTemplate.expire(key, 1, TimeUnit.DAYS);
        return redPackageKey + Arrays.toString(Arrays.stream(splitRedPackage)
                .mapToLong(Long::valueOf)
                .toArray());
    }

    /**
     * 红包金额二倍均值算法
     *
     * @param totalMoney
     * @param redPackageCount
     * @return
     */
    private Long[] splitRedPackage(Long totalMoney, Integer redPackageCount) {
        //已经划分的总金额
        Long useMoney = 0L;
        //保存每个红包划分的金额
        Long[] redPackageMoney = new Long[redPackageCount];
        Random random = new Random();
        for (int i = 0; i < redPackageCount; i++) {
            if (i == redPackageCount - 1) {
                //最后一个红包
                redPackageMoney[i] = totalMoney - useMoney;
            } else {
                //二倍均值法 获取最大值
                Long unUseMoney = totalMoney - useMoney;
                Long avgMoney = (unUseMoney / redPackageCount - i) * 2;
                //生成一个在 1 到 avgMoney - 1 之间的随机整数。
                redPackageMoney[i] = 1 + random.nextLong(avgMoney - 1);
            }
            useMoney = useMoney + redPackageMoney[i];
        }
        return redPackageMoney;
    }


    public String grab(String redPackageKey, String userId) {
        Boolean hasKey = redisTemplate.opsForHash().hasKey(CACHE_RED_PACKAGE_CONSUME_KEY + redPackageKey, userId);
        //没有抢过
        if (!hasKey) {
            Object redPackage = redisTemplate.opsForList().leftPop(CACHE_RED_PACKAGE_KEY + redPackageKey);
            if (null != redPackage) {
                //抢红包成功，进行记录
                redisTemplate.opsForHash().put(CACHE_RED_PACKAGE_CONSUME_KEY + redPackageKey, userId, redPackage);
                log.info("用户id:" + userId + " 抢到红包，红包金额：" + redPackage);
                //后续可通过消息队列异步到mysql
                return "用户id:" + userId + " 抢到红包，红包金额：" + redPackage;
            } else {
                //抢红包失败
                return "抢红包失败，红包已被抢完了!";
            }
        }
        return "抢红包失败，用户ID：" + userId + "已经抢过红包!";
    }
}
```



```java
import com.dongguo.redis.service.RedPackageService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.annotation.Resource;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/redPackage")
@Tag(
        name = "RedPackageController",
        description = "红包控制器接口")
public class RedPackageController {
    @Resource
    private RedPackageService redPackageService;
    @Operation(
            summary = "send",
            description = "发红包",
            parameters = {
            @Parameter(name = "totalMoney", description = "红包总金额", required = true, example = "1"),
            @Parameter(name = "RedPackageCount", description = "红包数量", required = true, example = "1")
    }
    )
    @PostMapping("/send")
    public String findUser(@RequestParam("totalMoney") Long totalMoney, @RequestParam("RedPackageCount") Integer RedPackageCount) {
        return redPackageService.send(totalMoney, RedPackageCount);
    }
    @Operation(
            summary = "grab",
            description = "抢红包",
            parameters = {
                    @Parameter(name = "redPackageKey", description = "红包的key", required = true, example = "1"),
                    @Parameter(name = "userId", description = "用户ID", required = true, example = "1")
            }
    )
    @PostMapping("/grab")
    public String rob(@RequestParam("redPackageKey") String redPackageKey, @RequestParam("userId") String userId) {
        return redPackageService.grab(redPackageKey, userId);
    }
}
```



# B站视频分享短链接推广实战

![image-20240317101453074](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403171015536.png)

真实的链接：https://www.bilibili.com/video/BV1Hy4y1B78T?p=1&share_medium=android&share_plat=android&share_source=COPY&share_tag=s_i&timestamp=1605941821&unique_k=xlPwAV

分享的链接：https://b23.tv/xlPwAV

将长链接使用短链接算法映射成短链接，使用短链接就可以访问真实地址。使用hash实现短链接与长链接的映射。

使用短连接的好处：

1.简单方便，利于推广

2.http传输数据小，有助于带宽节约和高并发

3.防止尾巴参数泄密，不安全（连接不携带敏感信息）





## 代码

ShortUrlUtils：短链接算法，通过映射算法后，跳转到真是地址

```java
import cn.hutool.crypto.digest.DigestUtil;

public class ShortUrlUtils {

    public static void main(String[] args) {
        String sLongUrl = "https://www.bilibili.com/video/BV1Be411R7zM?p=64&vd_source=8bae88bb736eed7ead3addb46e4849f3"; // 长链接
        String[] aResult = shortUrl(sLongUrl);
        // 打印出结果
        for (int i = 0; i < aResult.length; i++) {
            //4个短连接，任意一个都可以使用
            System.out.println("[" + i + "]:::" + aResult[i]);
        }
    }

    public static String[] shortUrl(String url) {

        // 要使用生成 URL 的字符
        String[] chars = new String[] { "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p",
                "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A",
                "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V",
                "W", "X", "Y", "Z"
        };

        String sMD5EncryptResult = DigestUtil.md5Hex(url);       // 对传入网址进行 MD5 加密，key是加密字符串
        String hex = sMD5EncryptResult;

        String[] resUrl = new String[4];
        for (int i = 0; i < 4; i++) {
            // 把加密字符按照8位一组16进制与0x3FFFFFFF进行位与运算
            String sTempSubString = hex.substring(i * 8, i * 8 + 8);

            // 这里需要使用 long 型来转换，因为 Inteter.parseInt() 只能处理 31 位 , 首位为符号位 , 如果不用 long ，则会越界
            long lHexLong = 0x3FFFFFFF & Long.parseLong(sTempSubString, 16);
            String outChars = "";
            for (int j = 0; j < 6; j++) {
                long index = 0x0000003D & lHexLong;     // 把得到的值与 0x0000003D 进行位与运算，取得字符数组 chars 索引
                outChars += chars[(int) index];         // 把取得的字符相加
                lHexLong = lHexLong >> 5;             // 每次循环按位右移 5 位
            }
            resUrl[i] = outChars;                       // 把字符串存入对应索引的输出数组
        }
        return resUrl;
    }
}
```



ShortUrlService：

```java
import com.dongguo.redis.utils.ShortUrlUtils;
import jakarta.annotation.Resource;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;
import java.io.IOException;
import java.util.Random;

import static com.dongguo.redis.utils.CacheKeyUtil.CACHE_SHORT_URL_KEY;

@Service
@Slf4j
public class ShortUrlService {
    @Resource
    private RedisTemplate redisTemplate;

    public String encode(String longUrl) {
        String[] keys = ShortUrlUtils.shortUrl(longUrl);
        //任意取出其中一个
        String shortUrl = keys[new Random().nextInt(4)];

        log.info("生成短连接{}", shortUrl);
        redisTemplate.opsForHash().put(CACHE_SHORT_URL_KEY, shortUrl, longUrl);
        return shortUrl;
    }


    public void decode(HttpServletResponse response, String shortUrl) {
        String longUrl = (String) redisTemplate.opsForHash().get(CACHE_SHORT_URL_KEY, shortUrl);
        log.info("跳转连接{}" + longUrl);
        try {
            response.sendRedirect(longUrl);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}
```

ShortUrlController：

```java
import com.dongguo.redis.service.ShortUrlService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.annotation.Resource;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

/**
 * @Author: Administrator
 * @Date: 2024-02-28
 */
@RestController
@RequestMapping("/shortUrl")
@Tag(
        name = "ShortUrlController",
        description = "短连接控制器接口")
@Slf4j
public class ShortUrlController {
    @Resource
    private ShortUrlService shortUrlService;

    @Operation(
            summary = "encode",
            description = "长连接生成短连接"
    )
    @GetMapping("/encode")
    public String encode(@RequestParam("longUrl") String longUrl) {
        return shortUrlService.encode(longUrl);
    }

    @Operation(
            summary = "decode",
            description = "获取长连接"
    )
    @GetMapping("/decode")
    public void decode(HttpServletResponse response, @RequestParam("shortUrl") String shortUrl) {
        shortUrlService.decode(response, shortUrl);
    }
}
```

