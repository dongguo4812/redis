redis通过IO多路复用来提升网络性能，并且支持各种不同的多路复用的实现，并且将这些实现进行封装，提供了统一的高性能时间库API库AE

判断当前环境，是否支持哪个文件

![image-20240327161719243](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403271617668.png)



![image-20240327161404234](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403271614449.png)

linux的IO多路复用默认实现是 epoll

![image-20240327162113255](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403271621818.png)

来看下redis单线程网络模型的整个流程

![image-20240327162148848](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403271621890.png)

![image-20240327162213122](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403271622362.png)

![image-20240327162219021](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403271622042.png)

![image-20240327162234367](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403271622276.png)

![image-20240327162328455](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403271623434.png)

![image-20240327162338873](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403271623117.png)

![image-20240327162400595](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403271624792.png)

![image-20240327162409646](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403271624657.png)

![image-20240327162417585](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403271624597.png)

当我们的客户端想要去连接我们服务器，会去先到IO多路复用模型去进行排队，会有一个连接应答处理器，他会去接受读请求，然后又把读请求注册到具体模型中去，此时这些建立起来的连接，如果是客户端请求处理器去进行执行命令时，他会去把数据读取出来，然后把数据放入到client中， clinet去解析当前的命令转化为redis认识的命令，接下来就开始处理这些命令，从redis中的command中找到这些命令，然后就真正的去操作对应的数据了，当数据操作完成后，会去找到命令回复处理器，再由他将数据写出。

redis6.0版本中引入了多线程，目的是为了提高IO读写效率。因此在解析客户端命令、写响应结果时采用了多线程。但是核心的命令执行，IO多路复用模块依然是由主线程执行。

![image-20240327162439366](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403271624006.png)