# 缓存预热

缓存预热就是系统启动前,提前将相关的缓存数据直接加载到缓存系统。避免在用户请求的时候,先查询数据库,然后再将数据缓存的问题! 

我们的解决思路就是采用的是定时任务在系统启动时执行一次刷新缓存。这种做法的目的是减轻数据库的压力，并提高系统的响应速度。

但是缓存预热也要避免预热过程中对数据库造成过大的压力。

# 缓存雪崩(Cache Avalanche)

Redis主机挂掉或崩溃，导致大量原本应该访问缓存的请求都去查询数据库。对数据库造成巨大的压力，甚至可能引发数据库崩溃

![image-20240311102415210](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403111024420.png)

## 解决方案

对于情况1，可以采取以下策略：

- redis缓存集群高可用

主从+哨兵 或redis Cluster集群 ，避免全盘崩溃。

- 多级缓存结合预防缓存雪崩

ehcache本地缓存+redis缓存

- 服务限流降级

hystrix或者sentinel限流 、降级确保核心功能的可用性

- 开启redis持久化 （AOF/RDB）

发生故障后快速恢复缓存

![image-20240311100925546](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403111009994.png)

用户发送一个请求，系统 A 收到请求后，先查本地 ehcache 缓存，如果没查到再查 Redis。如果 ehcache 和 Redis 都没有，再查数据库，将数据库中的结果，写入 ehcache 和 Redis 中。

限流组件，可以设置每秒的请求，有多少能通过组件，剩余的未通过的请求，怎么办？**走降级**！可以返回一些默认的值，或者友情提示，或者空值。

好处：

- 数据库绝对不会死，限流组件确保了每秒只有多少个请求能通过。
- 只要数据库不死，就是说，对用户来说，2/5 的请求都是可以被处理的。
- 只要有 2/5 的请求可以被处理，就意味着你的系统没死，对用户来说，可能就是点击几次刷不出来页面，但是多点几次，就可以刷出来了。



# 缓存穿透(Cache Penetration)

请求去查询一条记录，先查redis没有数据，后查mysql也没有。都查不到该条记录

但是请求每次都会打到数据库上面，导致后台数据库压力暴增 。可能会导致数据库由于压力过大而宕掉。



举个黑客攻击的栗子。数据库 id 是从 1 开始的，结果黑客发过来的请求 id 全部都是负数。这样的话，缓存中不会有，请求每次都“**视缓存于无物**”，直接查询数据库。这种恶意攻击场景的缓存穿透就会直接把数据库给打死。

![image-20240311102615514](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403111026682.png)

## 解决方案

1.空对象缓存或者缺省值

每次系统 A 从数据库中只要没查到，就写一个空值到缓存里去，比如 `set -999 UNKNOWN` 。然后设置一个过期时间，这样的话，下次有相同的 key 来访问的时候，在缓存失效之前，都可以直接从缓存中取数据。

2.布隆过滤器解决缓存穿透

如果黑客如果每次使用不同的负数 id 来攻击，写空值的方法可能就不奏效了。

更为经常的做法是在缓存之前增加布隆过滤器，将数据库中所有可能的数据哈希映射到布隆过滤器中。然后对每个请求进行如下判断：

- 请求数据的 key 不存在于布隆过滤器中，可以确定数据就一定不会存在于数据库中，系统可以立即返回不存在。
- 请求数据的 key 存在于布隆过滤器中，则继续再向缓存中查询。

使用布隆过滤器能够对访问的请求起到了一定的初筛作用，避免了因数据不存在引起的查询压力。

![image-20240311123518513](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403111236668.png)

# 缓存击穿(Hotspot Invalid)

大量的请求同时查询一个key时，此时这个key正好失效，导致大量的请求都达到数据库，导致数据库压力暴增，进而宕机。  即热点key失效。



## 解决方案

1.对于频繁访问的热点key，可以考虑不设置过期时间

2.使用互斥锁。synchronized双重校验锁/分布式锁

多个线程同时去查询数据库的这条数据,那么我们可以在第一个查询数据的请求上使用一个互斥锁来锁住它

其他的线程走到这一步拿不到锁就等着,等第一个线程查询到了数据,然后做缓存。后面的线程进来发现已经有缓存了,就直接走缓存。

3.多缓存策略，差异失效时间

也可以是多级缓存

两个缓存（A、B）的失效时间不同，当尝试从第一个缓存（A）中获取数据时，如果数据不存在或缓存访问失败，系统就会尝试从第二个缓存（B）中获取数据。

4.随机退避

随机退避是一种通过让请求线程在缓存失效时随机等待一段时间再尝试获取数据的策略，以分散对数据库的请求压力，减轻缓存击穿问题的影响。

# 总结

![image-20240312085610519](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403120856873.png)
