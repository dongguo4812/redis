缓存双写一致性之更新策略



![image-20240315112652628](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403151127175.png)

## 写数据库后写缓存的策略

同步直写策略：

写数据库后就同步写reids缓存，缓存和数据库中的数据一致，对于一致性要求高的数据，使用同步直写策略。

异步缓写策略：

写数据库后异步写redis缓存，异常情况出现，借助消息队列实现重试机制，对于一致性要求不高的数据，比如仓库、物流系统，



异步实现可以基于MQ或者Canal来实现：

1）基于MQ的异步通知：



![image-20240315134704214](F:\note\image\image-20240315134704214.png)

解读：

- 商品服务完成对数据的修改后，只需要发送一条消息到MQ中。
- 缓存服务监听MQ消息，然后完成对缓存的更新

依然有少量的代码侵入。



2）基于Canal的通知

![image-20240315134723752](F:\note\image\image-20240315134723752.png)

解读：

- 商品服务完成商品修改后，业务直接结束，没有任何代码侵入
- Canal监听MySQL变化，当发现变化后，立即通知缓存服务
- 缓存服务接收到canal通知，更新缓存

代码零侵入



## 数据库和缓存一致性的更新策略

以mysql的数据为准，对缓存操作尽最大努力即可，保证数据库和缓存的最终一致性。

### 先更新数据库，再更新缓存

场景1：更新mysql的某商品的库存，当前商品的库存是100，先更新mysql修改为99，然后更新redis。mysql更新成功，更新redis时失败了，导致mysql中商品库存是99，而redis的缓存还是100.

数据库和缓存数据不一致，读到了redis脏数据。

场景2：A、B两个线程发起更新请求。

正常逻辑：

1、 A update mysql 99

2、 A update reids 99

3、B update mysql 80

4、B update redis 80

异常逻辑：

1、 A update mysql 99

2、B update mysql 80

3、B update redis80

4、A update reids 99

缓存数据被覆盖，导致数据库和缓存数据不一致

单线程的情况下可以考虑这个策略。

### 先更新缓存，再更新数据库

这种方式不太推荐，因为在业务上一般是以数据库数据为准，数据库时做兜底的，所以是不会先更新缓存的。

如果业务上以缓存为主，可以考虑先更新缓存，再更新数据库。

异常逻辑：

1、 A update reids 99

2、B update redis 80

3、B update mysql 80

4、A update mysql 99

数据被覆盖，导致数据库和缓存数据不一致

### 先删除缓存，再更新数据库

1.A线程先删除redis的数据（网络延迟中）

2.B线程读取缓存数据，缓存中没有，读取数据库，将数据库数据回写到redis中

3.A更新mysql。

redis中缓存的还是旧数据，导致数据库和缓存数据不一致



解决方案：延迟双删

删除缓存后，延迟一段时间再次进行删除。那么该延迟多久再进行删除呢？

1.==延迟的时间要大于回写缓存执行的时间。==在实际环境中进行多次测试和调整，以找到最适合当前系统的值。这种方式会导致吞吐量降低。我们可以使用异步线程进行延迟删除。 但是还是存在可能由于网络延迟的关系导致回写缓存时间超过了延迟的时间。

回写缓存的时间不好预估，延迟双删的等待时间就不好设置。

2.我们也可以启动一个后台线程，例如看门口 watch dog，实时调整延迟的时间。

### 先更新数据库，再删除缓存

1.线程A更新数据库（网络延迟）

2.线程B读取缓存中的旧值

3.线程A删除缓存

在更新数据库和删除缓存的间隙存在数据库和缓存不一致。



如果缓存删除失败呢？ 订阅binlog日志+消息队列重试

![在这里插入图片描述](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403151525351.png)

流程如下图所示:

(1)更新数据库数据

(2)数据库会将操作信息写入binlog日志当中

(3)订阅程序提取出所需要的数据以及key

(4)另起一段非业务代码,获得该信息

(5)尝试删除缓存操作,发现删除失败

(6)将这些信息发送至消息队列

(7)重新从消息队列中获得该数据,重试操作。

使用消息队列实现重试机制，如果重试超过一定次数后，那就要发送错误信息，通知运维人员了。





### 最终选择方案

通常使用先更新数据库，再删除缓存的方案。

不过这种情况很难做到实时一致性，只能保证最终一致性。

# Canal服务端

**Canal [kə'næl]**，译意为水道/管道/沟渠，canal是阿里巴巴旗下的一款开源项目，基于Java开发。基于数据库增量日志解析，提供增量数据订阅&消费。GitHub的地址：https://github.com/alibaba/canal

历史背景是早期阿里巴巴因为杭州和美国双机房部署,存在跨机房数据同步的业务需求,实现方式主要是基于业务trigger (触发器)获取增量变更。从2010年开始，阿里巴巴逐步尝试采用解析数据库日志获取增量变更进行同步，由此衍生出了canal项目；

基于日志增量订阅和消费的业务包括

- 数据库镜像

- 数据库实时备份

- 索引构建和实时维护(拆分异构索引、倒排索引等)

- 业务 cache 刷新

- 带业务逻辑的增量数据处理



Canal是基于mysql的主从同步来实现的，MySQL主从同步的原理如下：



![image-20240315154920124](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403151549276.png)

- 当master主服务器上的数据发生改变时,则将其改变写入二进制事件日志( binary log）文件中;
- salve从服务器会在一定时间间隔内对master主服务器上的二进制日志进行探测,探测其是否发生过改变,如果探测到master主服务器的二进制事件日志发生了改变,则开始一个I/O Thread请求master二进制事件日志;
- 同时master主服务器为每个I/O Thread启动一个dump Thread,用于向其发送二进制事件日志;
- slave从服务器将接收到的二进制事件日志保存至自己本地的中继日志文件(relay log)中;
- salve从服务器将启动SQL Thread从中继日志中读取二进制日志,在本地重放,使得其数据和主服务器保持一致;

而Canal就是把自己伪装成MySQL的一个slave节点，从而监听master的binary log变化。再把得到的变化信息通知给Canal的客户端，进而完成对其它数据库的同步。

![image-20240315154945973](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403151549025.png)

## MySQL配置

Canal是基于MySQL的主从同步功能，因此必须先开启MySQL的主从功能才可以。这里我是用的是mysql版的MySQL。

### 1.查看MySQL版本

查看到MySQL版本是8.0.27

![image-20240315160829253](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403151608699.png)

### 2.查看当前MySQL服务器的二进制日志



![image-20240315161048331](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403151610335.png)

### 3.查看MySQL服务器是否启用了binlog二进制日志

![image-20240315161440893](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403151614007.png)

如果没有开启，开启MySQL的binlog写入功能，找到mysql的安装目录：E:\software\mysql\mysql-8.0.27-winx64下的my.ini.

在修改之前最好进行备份，在mysqld下添加

```shell
log-bin=mysql-bin #开启 binlog
binlog-format=ROW #选择 ROW 模式
server_id=1    #配置MySQL replaction需要定义，不要和canal的 slaveId重复
```



![image-20240315162010723](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403151620882.png)

binlog写入模式：

ROW模式 除了记录sql语句之外，还会记录每个字段的变化情况，能够清楚的记录每行数据的变化历史，但会占用较多的空间。

STATEMENT模式只记录了sql语句，但是没有记录上下文信息，在进行数据恢复的时候可能会导致数据的丢失情况；

MIX模式比较灵活的记录，理论上说当遇到了表结构变更的时候，就会记录为statement模式。当遇到了数据更新或者删除情况下就会变为row模式；

### 4.修改配置重启MySQL，再次查看否启用了binlog二进制日志

### 5.设置用户权限，授权canal连接MySQL的账号

添加一个canal账户。允许用户连接到主服务器以进行复制操作的权限，当然你也可以使用GRANT ALL ON *.* TO 'canal'@'%';*.*授予所有权限。

```sql
drop user if exists 'canal'@'%';
create user canal@'%' IDENTIFIED by 'canal';
GRANT SELECT, REPLICATION SLAVE, REPLICATION CLIENT,SUPER ON *.* TO 'canal'@'%';
FLUSH PRIVILEGES;
```

查看mysql库的user用户表

![image-20240315163526698](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403151635838.png)

## 安装Canal

要在centOS中安装canal，安装canal前要先安装好Java环境。

### 1.下载

https://github.com/alibaba/canal/releases/tag/canal-1.1.7

**此为部署安装包，没有管理界面，可满足基础使用。**

![image-20240315164641497](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403151646936.png)

### 2解压

创建canal文件夹，解压到canal文件夹中

```shell
[root@redis opt]# tar -zxvf canal.deployer-1.1.7.tar.gz -C /opt/canal
```

### 3配置instance.properties

/opt/canal/conf/example目录下

指定mysql主机master的ip地址

```
# position info
canal.instance.master.address=192.168.1.3:3306
```

指定mysql新建的canal账户

```
# username/password
canal.instance.dbUsername=canal
canal.instance.dbPassword=canal
```

### 4.启动

/opt/canal/bin目录下

```shell
[root@redis opt]# cd canal/bin/
[root@redis bin]# ll
总用量 16
-rwxr-xr-x. 1 root root  226 11月 16 2022 restart.sh
-rwxr-xr-x. 1 root root 1244 11月 16 2022 startup.bat
-rwxr-xr-x. 1 root root 3805 10月  8 14:38 startup.sh
-rwxr-xr-x. 1 root root 1356 11月 16 2022 stop.sh
[root@redis bin]# ./startup.sh
```

### 5.查看

查看server日志 logs/canal 下  

`cat canal.log`

```shell
2024-03-15 19:15:48.014 [main] INFO  com.alibaba.otter.canal.deployer.CanalLauncher - ## set default uncaught exception handler
2024-03-15 19:15:48.019 [main] INFO  com.alibaba.otter.canal.deployer.CanalLauncher - ## load canal configurations
2024-03-15 19:15:48.062 [main] INFO  com.alibaba.otter.canal.deployer.CanalStarter - ## start the canal server.
2024-03-15 19:15:48.127 [main] INFO  com.alibaba.otter.canal.deployer.CanalController - ## start the canal server[127.0.0.1(127.0.0.1):11111]
2024-03-15 19:15:50.471 [main] INFO  com.alibaba.otter.canal.deployer.CanalStarter - ## the canal server is running now ......
```

查看logs/example  

`cat example.log`

```shell
2024-03-15 19:15:50.424 [main] INFO  c.a.otter.canal.instance.core.AbstractCanalInstance - start successful....
2024-03-15 19:15:50.562 [destination = example , address = /192.168.1.3:3306 , EventParser] WARN  c.a.o.c.p.inbound.mysql.rds.RdsBinlogEventParserProxy - ---> begin to find start position, it will be long time for reset or first position
2024-03-15 19:15:50.562 [destination = example , address = /192.168.1.3:3306 , EventParser] WARN  c.a.o.c.p.inbound.mysql.rds.RdsBinlogEventParserProxy - prepare to find start position just show master status
2024-03-15 19:15:52.421 [destination = example , address = /192.168.1.3:3306 , EventParser] WARN  c.a.o.c.p.inbound.mysql.rds.RdsBinlogEventParserProxy - ---> find start position successfully, EntryPosition[included=false,journalName=mysql-bin.000085,position=3711,serverId=1,gtid=,timestamp=1710214183000] cost : 1812ms , the next step is binlog dump
```

6.如果防火墙开启，需要开放1111端口

```shell
[root@redis bin]# firewall-cmd --permanent --add-port=11111/tcp
success
[root@redis bin]# firewall-cmd --reload
success
```



# Canal实现Redis与Mysql数据双写一致性实战



Canal提供了各种语言的客户端，当Canal监听到binlog变化时，会通知Canal的客户端。

![image-20240315171737746](F:\note\image\image-20240315171737746.png)

我们可以利用Canal提供的Java客户端，监听Canal通知消息。当收到变化的消息时，完成对缓存的更新。



## 创建需要监控的表

```sql
CREATE TABLE `t_user` (
  `id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,
  `username` VARCHAR(50) NOT NULL DEFAULT '' COMMENT '用户名',
  `password` VARCHAR(50) NOT NULL DEFAULT '' COMMENT '密码',
  `sex` TINYINT(4) NOT NULL DEFAULT '0' COMMENT '性别 0=女 1=男 ',
  `deleted` TINYINT(4) UNSIGNED NOT NULL DEFAULT '0' COMMENT '删除标志，默认0不删除，1删除',
  `update_time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  `create_time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  PRIMARY KEY (`id`)
) ENGINE=INNODB AUTO_INCREMENT=1001 DEFAULT CHARSET=utf8 COMMENT='用户表';
 
SELECT * FROM t_user;
```

## canal客户端

### 创建canal项目

redis_canal

### pom引入canal依赖

```xml
    <dependencies>
        <dependency>
            <groupId>com.dongguo</groupId>
            <artifactId>redis_core</artifactId>
            <version>0.0.1-SNAPSHOT</version>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>com.alibaba.otter</groupId>
            <artifactId>canal.client</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
        </dependency>
        <!--SpringBoot集成druid连接池-->
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>druid-spring-boot-starter</artifactId>
        </dependency>
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>druid</artifactId>
        </dependency>
        <!--Mysql数据库驱动-->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
        </dependency>
    </dependencies>
```

### 配置application.yml

```yaml
server:
  port: 8088
spring:
  application:
    name: redis_canal
  # ========================alibaba.druid相关配置=====================
  datasource:
    type: com.alibaba.druid.pool.DruidDataSource
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/redis?useUnicode=true&characterEncoding=utf-8&useSSL=false
    username: root
    password: root
    druid:
      test-while-ide: false
  # ========================redis相关配置=====================
  data:
    redis:
      host: 192.168.122.131
      port: 6379
      password: root
```

### ClientSample代码

RedisCanalClientExample: 

在SpringBoot项目启动时，执行init()方法

```java

import com.alibaba.fastjson.JSON;
import com.alibaba.otter.canal.client.CanalConnector;
import com.alibaba.otter.canal.client.CanalConnectors;
import com.alibaba.otter.canal.protocol.CanalEntry;
import com.alibaba.otter.canal.protocol.CanalEntry.*;
import com.alibaba.otter.canal.protocol.Message;
import jakarta.annotation.PostConstruct;
import jakarta.annotation.Resource;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.stereotype.Component;
import java.net.InetSocketAddress;
import java.util.HashMap;
import java.util.List;
import java.util.UUID;
import java.util.concurrent.TimeUnit;

@Component
public class RedisCanalClientExample {
    @Resource
    private StringRedisTemplate stringRedisTemplate;
    public static final String CANAL_IP_ADDR = "192.168.122.131";
    public static final String CACHE_USER_KEY = "redis:user:";
    private void redisInsert(List<Column> columns) {
        HashMap map = new HashMap();
        for (CanalEntry.Column column : columns) {
            System.out.println(column.getName() + " : " + column.getValue() + "    update=" + column.getUpdated());
            map.put(column.getName(), column.getValue());

        }
        if (columns.size() > 0) {
            stringRedisTemplate.opsForValue().set(CACHE_USER_KEY + columns.get(0).getValue(), JSON.toJSONString(map));
        }
    }

    private void redisDelete(List<CanalEntry.Column> columns) {
        if (columns.size() > 0) {
            stringRedisTemplate.delete(CACHE_USER_KEY + columns.get(0).getValue());

        }
    }

    private void redisUpdate(List<CanalEntry.Column> columns) {
        HashMap map = new HashMap();
        for (CanalEntry.Column column : columns) {
            System.out.println(column.getName() + " : " + column.getValue() + "    update=" + column.getUpdated());
            map.put(column.getName(), column.getValue());
        }
        if (columns.size() > 0) {
            stringRedisTemplate.opsForValue().set(CACHE_USER_KEY + columns.get(0).getValue(), JSON.toJSONString(map));

            System.out.println("---------update after: " + JSON.toJSONString(map));

        }
    }

    public void printEntry(List<CanalEntry.Entry> entries) {
        for (CanalEntry.Entry entry : entries) {
            if (entry.getEntryType() == CanalEntry.EntryType.TRANSACTIONBEGIN || entry.getEntryType() == CanalEntry.EntryType.TRANSACTIONEND) {
                continue;
            }

            CanalEntry.RowChange rowChage;
            try {
                //获取变更的row数据
                rowChage = CanalEntry.RowChange.parseFrom(entry.getStoreValue());
            } catch (Exception e) {
                throw new RuntimeException("ERROR ## parser of eromanga-event has an error,data:" + entry.toString(), e);
            }
            //获取变动类型
            CanalEntry.EventType eventType = rowChage.getEventType();
            System.out.println(String.format("================&gt; binlog[%s:%s] , name[%s,%s] , eventType : %s",
                    entry.getHeader().getLogfileName(), entry.getHeader().getLogfileOffset(),
                    entry.getHeader().getSchemaName(), entry.getHeader().getTableName(), eventType));

            for (CanalEntry.RowData rowData : rowChage.getRowDatasList()) {
                if (eventType == CanalEntry.EventType.INSERT) {
                    redisInsert(rowData.getAfterColumnsList());
                } else if (eventType == CanalEntry.EventType.DELETE) {
                    redisDelete(rowData.getBeforeColumnsList());
                } else {//EventType.UPDATE
                    redisUpdate(rowData.getAfterColumnsList());
                }
            }
        }
    }

    @PostConstruct
    public void init() {
        System.out.println("--------------init()--------------");

        // 创建链接canal服务器
        CanalConnector connector = CanalConnectors.newSingleConnector(new InetSocketAddress(CANAL_IP_ADDR, 11111),
                "example",
                "",
                "");
        int batchSize = 1000;
        //空闲空转计数器
        int emptyCount = 0;
        System.out.println("--------------canal init ok, 开始监听mysql变化--------------");
        try {
            connector.connect();
            connector.subscribe("redis.t_user");
            connector.rollback();
            int totalEmptyCount = 10 * 60;
            while (emptyCount < totalEmptyCount) {
                System.out.println("我是canal，每秒一次正在监听：" + UUID.randomUUID());
                //获取指定数量的数据
                Message mes = connector.getWithoutAck(batchSize);
                long batchId = mes.getId();
                int size = mes.getEntries().size();
                if (batchId == -1 || size == 0) {
                    emptyCount++;
                    try {
                        TimeUnit.SECONDS.sleep(1);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                } else {
                    //计数器重新置零
                    emptyCount = 0;
                    printEntry(mes.getEntries());
                }
                //提交确认
                connector.ack(batchId);
            }
            System.out.println("已经监听了" + totalEmptyCount + "秒，无任何消息，请重启重试......");
        } finally {
            connector.disconnect();
        }
    }
}
```

### 测试

启动项目后，canal会持续监控mysql中redis库t_user表数据的变更。

直接在数据库中执行增删改操作：

监测到数据新增

```shell
我是canal，每秒一次正在监听：82d486ce-b59d-44eb-9275-49ce0ea7c19a
================&gt; binlog[mysql-bin.000085:8209] , name[redis,t_user] , eventType : INSERT
id : 11    update=true
username : zhangsan    update=true
password : 123456    update=true
sex : 0    update=true
deleted : 0    update=true
update_time : 2024-03-15 20:21:37    update=true
create_time : 2024-03-15 20:21:37    update=true
我是canal，每秒一次正在监听：9dbc654e-a963-4c59-9f78-17ce58a7caf0
我是canal，每秒一次正在监听：563e3ca5-a3e3-45ec-899d-7f25ef53b84e
我是canal，每秒一次正在监听：15828d88-175d-45f2-9369-dfec33a7141d

```

redis新增缓存

![image-20240315213341024](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403152133670.png)



监测到数据更新

```shell
我是canal，每秒一次正在监听：9ee0bcd4-ea1e-41b5-8b7a-db4310fadf12
我是canal，每秒一次正在监听：e9ab447d-9d42-4ccd-bfcd-a4e05781cac2
================&gt; binlog[mysql-bin.000085:8538] , name[redis,t_user] , eventType : UPDATE
id : 11    update=false
username : zhangsan    update=false
password : 111111    update=true
sex : 0    update=false
deleted : 0    update=false
update_time : 2024-03-15 20:22:07    update=true
create_time : 2024-03-15 20:21:37    update=false
---------update after: {"password":"111111","update_time":"2024-03-15 20:22:07","deleted":"0","create_time":"2024-03-15 20:21:37","sex":"0","id":"11","username":"zhangsan"}
我是canal，每秒一次正在监听：921fb0f7-4a9d-4cca-b87a-ee66dbd581c6
我是canal，每秒一次正在监听：31bb4fbd-8cd2-4142-a93a-d251928a0533
```

![image-20240315213419679](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403152134622.png)

监测到数据删除

```shell
我是canal，每秒一次正在监听：327bd9ba-6119-4cbf-ace9-d0005eba4ef2
我是canal，每秒一次正在监听：b27c7b4e-6a88-4d24-b2e8-e580ff98d8c1
================&gt; binlog[mysql-bin.000085:8890] , name[redis,t_user] , eventType : DELETE
我是canal，每秒一次正在监听：7909531a-b8de-4d39-b35c-56c303eac2c2
我是canal，每秒一次正在监听：d97b9eb2-e88f-45b7-8e93-f306c2c74948
```

已经获取不到key了

```shell
127.0.0.1:6379> get redis:user:11
(nil)
```

## canal-starter客户端

GitHub上的第三方开源的canal-starter客户端。地址：https://github.com/NormanGyllenhaal/canal-client

与SpringBoot完美整合，自动装配，比官方客户端要简单好用很多。但是canal-starter已经很久没更新了，只支持到java8.

### 创建canal项目

redis_canal_8

### pom引入canal依赖

```xml
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <!--SpringBoot集成druid连接池-->
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>druid-spring-boot-starter</artifactId>
            <version>1.1.16</version>
        </dependency>
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>druid</artifactId>
            <version>1.1.7</version>
        </dependency>
        <!--Mysql数据库驱动-->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>8.0.33</version>
        </dependency>
        <dependency>
            <groupId>top.javatool</groupId>
            <artifactId>canal-spring-boot-starter</artifactId>
            <version>1.2.1-RELEASE</version>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>1.18.30</version>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
        </dependency>
    </dependencies>
```

### 配置application.yml

```yaml
server:
  port: 8088
spring:
  application:
    name: redis_canal
  # ========================alibaba.druid相关配置=====================
  datasource:
    type: com.alibaba.druid.pool.DruidDataSource
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/redis?useUnicode=true&characterEncoding=utf-8&useSSL=false
    username: root
    password: root
    druid:
      test-while-ide: false
  # ========================redis相关配置=====================
  redis:
    host: 192.168.122.131
    port: 6379
    password: root

canal:
  destination: example # canal的集群名字，要与安装canal时设置的名称一致
  server: 192.168.122.131:11111 # canal服务地址
# 设置canal消息日志打印级别
logging:
  level:
    top.javatool.canal.client: debug
```

### redis配置类

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;
import java.io.Serializable;

/**
 * redis序列化工具类
 */

@Configuration
public class RedisConfig {


    /**
     * @param lettuceConnectionFactory
     * @return redis序列化的工具配置类
     * 1) "order:696"  序列化过
     * 2) "\xac\xed\x00\x05t\x00\order:696"   没有序列化过
     */
    @Bean
    public RedisTemplate<String, Serializable> redisTemplate(LettuceConnectionFactory lettuceConnectionFactory) {
        RedisTemplate<String, Serializable> redisTemplate = new RedisTemplate<>();
        redisTemplate.setConnectionFactory(lettuceConnectionFactory);
        //设置key序列化方式string
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        //设置value的序列化方式json
        redisTemplate.setValueSerializer(new GenericJackson2JsonRedisSerializer());
        redisTemplate.setHashKeySerializer(new StringRedisSerializer());
        redisTemplate.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());
        redisTemplate.afterPropertiesSet();
        return redisTemplate;
    }
}
```



### 实体类User

```java
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import javax.persistence.Column;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.Table;
import java.util.Date;

@Table(name = "t_user")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class User {
    @Id
    @GeneratedValue(generator = "JDBC")
    private Long id;

    /**
     * 用户名
     */
    private String username;

    /**
     * 密码
     */
    private String password;

    /**
     * 性别 0=女 1=男 
     */
    private Integer sex;

    /**
     * 删除标志，默认0不删除，1删除
     */
    private Integer deleted;

    /**
     * 更新时间
     */
    @Column(name = "update_time")
    private Date updateTime;

    /**
     * 创建时间
     */
    @Column(name = "create_time")
    private Date createTime;
}
```

### UserEntryHandler

实现EntryHandler 接口，泛型为想要订阅的数据库表的实体对象， 该接口的方法为 java 8 的 default 方法，方法可以不实现，如果只要监听增加操作，只实现增加方法即可
下面以一个t_user表的user实体对象为例, 默认情况下，将使用实体对象的jpa 注解 @Table中的表名来转换为

```java
import com.dongguo.redis.entity.User;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Component;
import top.javatool.canal.client.annotation.CanalTable;
import top.javatool.canal.client.handler.EntryHandler;
import javax.annotation.Resource;


/**
 * 获取到User对象后同步到缓存
 *
 * @author yang peng
 * @date 2019/4/1915:19
 */
@CanalTable(value = "t_user") //canal监控对应的数据库表
@Component
@Slf4j
public class UserEntryHandler implements EntryHandler<User> {
    private static final String CACHE_USER_KEY = "redis:user:";
    @Resource
    private RedisTemplate redisTemplate;

    @Override
    public void insert(User user) {
        log.info("增加 {}", user);
        redisTemplate.opsForValue().set(CACHE_USER_KEY + user.getId(), user);
    }

    @Override
    public void update(User before, User after) {
        log.info("修改 before {}", before);
        log.info("修改 after {}", after);
        redisTemplate.opsForValue().set(CACHE_USER_KEY + before.getId(), before);
    }

    @Override
    public void delete(User user) {
        log.info("删除 {}", user);
        redisTemplate.delete(CACHE_USER_KEY + user.getId());
    }
}
```

### 测试

直接在数据库中执行增删改操作

新增 

```shell
2024-03-16 15:16:58.368  INFO 44896 --- [xecute-thread-2] c.dongguo.redis.canal.UserEntryHandler   : 增加 User(id=10, username=zhangsan, password=123456, sex=0, deleted=0, updateTime=Sat Mar 16 15:16:57 CST 2024, createTime=Sat Mar 16 15:16:57 CST 2024)
```



更新

```shell
2024-03-16 15:17:19.433  INFO 44896 --- [xecute-thread-3] c.dongguo.redis.canal.UserEntryHandler   : 修改 before User(id=null, username=null, password=123456, sex=null, deleted=null, updateTime=Sat Mar 16 15:16:57 CST 2024, createTime=null)
2024-03-16 15:17:19.433  INFO 44896 --- [xecute-thread-3] c.dongguo.redis.canal.UserEntryHandler   : 修改 after User(id=10, username=zhangsan, password=111111, sex=0, deleted=0, updateTime=Sat Mar 16 15:17:18 CST 2024, createTime=Sat Mar 16 15:16:57 CST 2024)
```



删除

```shell
2024-03-16 15:17:40.491  INFO 44896 --- [xecute-thread-4] c.dongguo.redis.canal.UserEntryHandler   : 删除 User(id=10, username=zhangsan, password=111111, sex=0, deleted=0, updateTime=Sat Mar 16 15:17:18 CST 2024, createTime=Sat Mar 16 15:16:57 CST 2024)
```

## behappy-canal客户端

如果使用java8以上的版本可以开率behappy-canal，behappy-canal作为canal-starter的升级版

要求：java17/springboot3.x,回到spring_canal项目。

### 引入canal依赖

```xml
        <dependency>
            <groupId>io.github.behappy-project</groupId>
            <artifactId>behappy-canal-spring-boot-starter</artifactId>
        </dependency>
```

### 配置application.yml

```yaml
canal:
  # canal服务地址
  server: 192.168.122.131:11111
    # canal的集群名字，要与安装canal时设置的名称一致
  destination: example
```

接下来的代码和canal-starter是一致的。

### 实体类User

```java
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.util.Date;

@Table(name = "t_user")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class User {
    @Id
    @GeneratedValue(generator = "JDBC")
    private Long id;

    /**
     * 用户名
     */
    private String username;

    /**
     * 密码
     */
    private String password;

    /**
     * 性别 0=女 1=男 
     */
    private Integer sex;

    /**
     * 删除标志，默认0不删除，1删除
     */
    private Integer deleted;

    /**
     * 更新时间
     */
    @Column(name = "update_time")
    private Date updateTime;

    /**
     * 创建时间
     */
    @Column(name = "create_time")
    private Date createTime;
}
```

### UserEntryHandler

```java
import com.dongguo.redis.entity.User;
import jakarta.annotation.Resource;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Component;
import org.xiaowu.behappy.canal.client.annotation.CanalTable;
import org.xiaowu.behappy.canal.client.handler.EntryHandler;


/**
 * 获取到User对象后同步到缓存
 *
 * @author yang peng
 * @date 2019/4/1915:19
 */
@Component
@Slf4j
@CanalTable(value = "t_user")
public class UserEntryHandler implements EntryHandler<User> {
    private static final String CACHE_USER_KEY = "redis:user:";
    @Resource
    private RedisTemplate redisTemplate;

    @Override
    public void insert(User user) {
        log.info("增加 {}", user);
        redisTemplate.opsForValue().set(CACHE_USER_KEY + user.getId(), user);
    }

    @Override
    public void update(User before, User after) {
        log.info("修改 before {}", before);
        log.info("修改 after {}", after);
        redisTemplate.opsForValue().set(CACHE_USER_KEY + before.getId(), before);
    }

    @Override
    public void delete(User user) {
        log.info("删除 {}", user);
        redisTemplate.delete(CACHE_USER_KEY + user.getId());
    }
}
```

### 测试

直接在数据库中执行增删改操作

新增

```shell
2024-03-16T17:34:22.906+08:00  INFO 37444 --- [redis_canal] [xecute-thread-4] c.dongguo.redis.canal.UserEntryHandler   : 增加 User(id=10, username=zhanbgsan, password=123456, sex=0, deleted=0, updateTime=Sat Mar 16 17:34:22 CST 2024, createTime=Sat Mar 16 17:34:22 CST 2024)
```

更新

```shell
2024-03-16T17:35:09.027+08:00  INFO 37444 --- [redis_canal] [xecute-thread-5] c.dongguo.redis.canal.UserEntryHandler   : 修改 before User(id=null, username=null, password=123456, sex=null, deleted=null, updateTime=Sat Mar 16 17:34:22 CST 2024, createTime=null)
2024-03-16T17:35:09.027+08:00  INFO 37444 --- [redis_canal] [xecute-thread-5] c.dongguo.redis.canal.UserEntryHandler   : 修改 after User(id=10, username=zhanbgsan, password=111111, sex=0, deleted=0, updateTime=Sat Mar 16 17:35:08 CST 2024, createTime=Sat Mar 16 17:34:22 CST 2024)
```

删除

```shell
2024-03-16T17:35:24.067+08:00  INFO 37444 --- [redis_canal] [xecute-thread-6] c.dongguo.redis.canal.UserEntryHandler   : 删除 User(id=10, username=zhanbgsan, password=111111, sex=0, deleted=0, updateTime=Sat Mar 16 17:35:08 CST 2024, createTime=Sat Mar 16 17:34:22 CST 2024)
```

