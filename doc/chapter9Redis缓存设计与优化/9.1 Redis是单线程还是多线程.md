# Redis是单线程还是多线程

一些面试官会问redis是单线程吗？redis是单线程还是多线程？



分析：这个问法其实并不严谨，因为不同版本有不同的架构，不限定版本问是否单线程是不严谨的。



回答：

在redis3.X及之前的版本，redis是单线程的。

在redis4.X版本，redis引入了多线程的支持，主要是用于处理某些特定的后台任务，比如：异步删除（lazy free）机制。但是负责处理客户端请求的线程还是单线程。

在redis6.0及以后的版本已经全面支持多线程。

但是Redis的多线程只是用来处理网络数据的读写和协议解析的，对于命令执行Redis仍然使用单线程来处理。

因为默认情况下多线程是禁用的，只使用主线程进行处理。所以处理网络数据的读写和协议解析还是单线程的。



注：即使多线程默认是禁用的，持久化（RDB和AOF）、异步删除、集群数据同步等操作还是通过额外的线程来异步执行。

![image-20240228190744647](https://gitee.com/dongguo4812_admin/image/raw/master/image/202402281925348.png)



Redis6.0以前，我们通常说Redis是单线程主要是指Redis的网络IO和键值对读写是由一个线程来完成的，Redis在处理客户端的请求时包括获取请求(socket 读）、解析请求、执行命令、内容返回(socket写)等都由一个主线程顺序串行处理的，这就是所谓的“单线程”。这也是Redis对外提供键值存储服务的主要流程。

![image-20240309080522680](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403090805197.png)

在Redis 6.0中新增了多线程的功能来提高I/O的读写性能，他的主要实现思路是将主线程的IO读写任务拆分给一组独立的线程去执行，这样就可以使多个socket的读写可以并行化了，采用多路IO复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），将最耗时的Socket的读取、请求解析、写入单独外包出去，剩下的命令执行仍然由主线程串行执行并和内存的数据交互。

![image-20240309142416786](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403091424164.png)



结论：==Redis命令工作线程是单线程的，但是对于整个Redis来说是多线程的；==

单线程保证命令执行的线程安全，多线程解决网络IO阻塞问题。

# Redis为什么使用单线程

Redis4.0之前一直采用单线程的主要原因：

Redis是基于内存操作的，因此它的瓶颈是物理机器的内存或网络带宽而并非CPU，既然CPU不是性能瓶颈，那么就采用单线程的解决方案了。

例如：Linux系统下Redis使用管道技术每秒可以处理多达一百万个请求。

而且引入多线程还需要面对上下文切换带来的开销和多线程锁竞争问题。



然而在Redis4.0中开始支持多线程，例如后台异步删除，对于之后的版本，Redis会越来越具有多线程特性。



## 单线程redis为什么这么快

1.基于内存操作：

Redis的所有数据都存在内存中，直接在内存中读写数据，所以性能比较高；

2.数据结构：

Redis 的数据结构是专门优化设计的，而这些简单的数据结构的查找和操作的时间复杂度大部分都是O(1)，因此性能比较高；

3.单线程模型

单线程开发和维护更简单，避免了不必要的上下文切换开销和多线程锁竞争，而且单线程不会导致死锁问题的发生

4.采用l/O多路复用技术

通过IO多路复用功能来监听多个socket连接客户端，这样就可以让单个线程高效的处理多个连接请求。同时也避免了IO阻塞。



# 既然Redis单线程那么快，为什么引入多线程

单线程面临到的问题：

最经典的删除大key问题，正常情况下单线程使用del指令可以很快的删除数据，而当被删除的key是一个非常大的对象时，例如时包含了成千上万个元素的 hash集合时，那么del指令就会造成Redis主线程卡顿。

于是Redis4.0为了解决删除数据效率比较低的问题增加了多线程模块。

`unlink key`:异步删除指定的 key。它不会立即同步删除数据，而是将 key 从 keyspace 中暂时移除，并将删除任务添加到一个异步队列中，由后台线程在稍后的时间执行真正的删除操作。

`flushdb async`:异步删除当前数据库中的所有 key。

`flushall async`:异步删除所有数据库中的所有 key

`unlink key`是Redis 4.0新提出的命令，而`flushdb async`和`flushall async`则是在Redis 4.0中针对原有命令新增了异步执行的选项。



redis之父antirez一直强调"Lazy Redis is better Redis".

lazy free的本质就是执行某些耗时的操作时，如删除大量数据，使用异步（Lazy）操作则可以将这些耗时的任务放到后台线程去执行，主线程可以继续处理其他请求，从而提高了整体的吞吐量和响应性。

# Redis6.0默认禁用多线程

Redis将所有数据放在内存中，可以处理到8W到10W的QPS。对于80%的公司来说，单线程的Redis已经足够使用了。

## 如何开启多线程

如果在实际应用中，发现Redis实例的吞吐量没有达到预期，可以考虑使用多线程机制，提升实例的吞吐量。

需要在redis.conf中完成两个配置

1.设置io-thread-do-reads配置项为yes，表示启动多线程。

2.设置线程个数。关于线程数的设置，官方的建议是如果为4核的CPU，建议线程数设置为2或3，如果为8核CPU建议线程数设置为6。线程数一定要小于机器核数，线程数并不是越大越好。